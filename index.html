<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="温故而知新">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="温故而知新">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="tlv">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>温故而知新</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">温故而知新</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">8</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/01/19/mysql-lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="tlv">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温故而知新">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/19/mysql-lock/" class="post-title-link" itemprop="url">MySQL -- 锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-20T00:00:00+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-11 21:27:38" itemprop="dateModified" datetime="2022-05-11T21:27:38+08:00">2022-05-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Storage/" itemprop="url" rel="index"><span itemprop="name">Storage</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Storage/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>18 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Mysql-锁总结"><a href="#Mysql-锁总结" class="headerlink" title="Mysql 锁总结"></a>Mysql 锁总结</h2><h3 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h3><ul>
<li>乐观锁</li>
<li>悲观锁</li>
</ul>
<p>乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新的问题：</p>
<ol>
<li>乐观锁会”乐观的”假定大概率不会发生并发更新冲突，访问、处理数据过程中不加锁，只在更新数据时再根据版本号或时间戳判断是否有冲突，有则处理，无则提交事务</li>
<li>悲观锁会”悲观的”假定大概率会发生并发更新冲突，访问、处理数据前就加排他锁，在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁；</li>
</ol>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><ul>
<li>共享锁（读锁、S Lock）</li>
<li>排它锁（写锁、X Lock）</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>X</th>
<th>S</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>S</td>
<td>不兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<h3 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h3><ul>
<li>全局锁</li>
<li>表锁</li>
<li>页锁</li>
<li>行锁</li>
</ul>
<h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><ul>
<li>MetaDataLock（元数据锁 MDL）</li>
<li>行锁</li>
<li>gap锁</li>
<li>next-key lock</li>
<li>意向锁</li>
<li>插入意向锁</li>
<li>自增锁</li>
</ul>
<h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。<br>之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。<br>全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都 select 出来存成文本。<br>FTWRL通过持有以下两把全局的MDL(MetaDataLock)锁：</p>
<ul>
<li>全局读锁(lock_global_read_lock) 会导致所有的更新操作被堵塞</li>
<li>全局COMMIT锁(make_global_read_lock_block_commit) 会导致所有的活跃事务无法提交</li>
</ul>
<p>FLUSH TABLES WITH READ LOCK执行后整个系统会一直处于只读状态，直到显示执行UNLOCK TABLES</p>
<h2 id="MDL"><a href="#MDL" class="headerlink" title="MDL"></a>MDL</h2><h3 id="MDL作用"><a href="#MDL作用" class="headerlink" title="MDL作用"></a>MDL作用</h3><p>​    为了在并发环境下维护表元数据的数据一致性，在表上有活动事务（显式或隐式）的时候，不可以对元数据进行写入操作。因此从MySQL5.5版本开始引入了MDL锁（metadata lock），来保护表的元数据信息，用于解决或者保证DDL操作与DML操作之间的一致性。<br>​    对于引入MDL，其主要解决了2个问题，一个是事务隔离问题，比如在可重复隔离级别下，会话A在2次查询期间，会话B对表结构做了修改，两次查询结果就会不一致，无法满足可重复读的要求；另外一个是数据复制的问题，比如会话A执行了多条更新语句期间，另外一个会话B做了表结构变更并且先提交，就会导致slave在重做时，先重做alter，再重做update时就会出现复制错误的现象。<br>​    所以在对表进行上述操作时，如果表上有活动事务（未提交或回滚），请求写入的会话会等待在Metadata lock wait 。</p>
<table>
<thead>
<tr>
<th>会话1</th>
<th>会话2</th>
</tr>
</thead>
<tbody><tr>
<td>BEGIN;</td>
<td></td>
</tr>
<tr>
<td>SELECT * FROM XXX</td>
<td></td>
</tr>
<tr>
<td></td>
<td>DROP TABLE XXX</td>
</tr>
<tr>
<td>SELECT * FROM XXX</td>
<td></td>
</tr>
</tbody></table>
<p>​    若没有MDL锁的保护，则事务2可以直接执行DDL操作，并且导致事务1出错，5.1版本即是如此。5.5版本加入MDL锁就在于保护这种情况的发生，由于事务1开启了查询，那么获得了MDL锁，锁的模式为SHARED_READ，事务2要执行DDL，则需获得EXCLUSIVE锁，两者互斥，所以事务2需要等待。</p>
<h3 id="MDL锁类型"><a href="#MDL锁类型" class="headerlink" title="MDL锁类型"></a>MDL锁类型</h3><p>由于MySQL是Server-Engine架构，尽管InnoDB层已经有了IS、IX这样的意向锁，所以MDL锁是在Server中实现</p>
<p>MDL锁还能实现其他粒度级别的锁，比如全局锁、库级别的锁、表空间级别的锁，这是InnoDB存储引擎层不能直接实现的锁</p>
<p>与InnoDB锁的实现一样，MDL锁也是类似对一颗树的各个对象从上至下进行加锁。但是MDL锁对象的层次更多，简单来看有如下的层次：</p>
<img src="/images/mysql-lock/0823959122513a6fe17bc80567715e03.png" alt="img" style="zoom:150%;" />

<p>上图中显示了最常见的4种MDL锁的对象，并且注明了常见的SQL语句会触发的锁。</p>
<p>与InnoDB层类似的是，某些类型的MDL锁会从上往下一层层进行加锁。</p>
<p>比如LOCK TABLE … WRITE这样的SQL语句，其首先会对GLOBAL级别加INTENTION_EXCLUSIVE锁，再对SCHEMA级别加INTENTION_EXCLUSIVE锁，最后对TABLE级别加SHARED_NO_READ_WRITE锁</p>
<h3 id="MDL锁对象、范围"><a href="#MDL锁对象、范围" class="headerlink" title="MDL锁对象、范围"></a>MDL锁对象、范围</h3><table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>范围/对象</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>GLOBAL</td>
<td>全局锁（MySQL实例）</td>
<td>范围</td>
<td>主要作用是防止DDL和写操作的过程中执行 set golbal_read_only =on 或<br />flush tables with read <em>lock</em>;</td>
</tr>
<tr>
<td>COMMIT</td>
<td>提交保护锁</td>
<td>范围</td>
<td>主要作用是执行flush tables with read <em>lock</em>后，防止已经开始在执行的写事务提交</td>
</tr>
<tr>
<td>SCHEMA</td>
<td>库锁</td>
<td>对象</td>
<td></td>
</tr>
<tr>
<td>TABLE</td>
<td>表锁</td>
<td>对象</td>
<td></td>
</tr>
<tr>
<td>FUNCTION</td>
<td>函数锁</td>
<td>对象</td>
<td></td>
</tr>
<tr>
<td>PROCEDURE</td>
<td>存储过程锁</td>
<td>对象</td>
<td></td>
</tr>
<tr>
<td>TRIGGER</td>
<td>触发器锁</td>
<td>对象</td>
<td></td>
</tr>
<tr>
<td>EVENT</td>
<td>事件锁</td>
<td>对象</td>
<td></td>
</tr>
</tbody></table>
<h3 id="MDL持有时间"><a href="#MDL持有时间" class="headerlink" title="MDL持有时间"></a>MDL持有时间</h3><table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>MDL_STATEMENT</td>
<td>从语句开始执行时获取，到语句执行结束时释放。</td>
</tr>
<tr>
<td>MDL_TRANSACTION</td>
<td>在一个事务中涉及所有表获取MDL，一直到事务commit或者rollback(线程中终清理)才释放。</td>
</tr>
<tr>
<td>MDL_EXPLICIT</td>
<td>需要MDL_context::release_lock()显式释放。语句或者事务结束,也仍然持有，如Lock table, flush .. with lock语句等。</td>
</tr>
</tbody></table>
<h3 id="MDL锁模式"><a href="#MDL锁模式" class="headerlink" title="MDL锁模式"></a>MDL锁模式</h3><p>数据库锁一般将锁划分为读锁(共享锁)和写锁(排它锁)，为了进一步提高并发性，还会加入意向共享锁和意向排它锁。</p>
<p>mysql设计得更复杂，如下表：</p>
<table>
<thead>
<tr>
<th>锁模式</th>
<th>对应SQL</th>
</tr>
</thead>
<tbody><tr>
<td>MDL_INTENTION_EXCLUSIVE</td>
<td>意向排他锁 GLOBAL对象、SCHEMA对象操作会加此锁</td>
</tr>
<tr>
<td>MDL_SHARED</td>
<td>只访问元数据 比如表结构 FLUSH TABLES with READ LOCK</td>
</tr>
<tr>
<td>MDL_SHARED_HIGH_PRIO</td>
<td>仅对MyISAM存储引擎有效，用于访问information_scheam表</td>
</tr>
<tr>
<td>MDL_SHARED_READ</td>
<td>SELECT查询 访问表结构并且读表数据</td>
</tr>
<tr>
<td>MDL_SHARED_WRITE</td>
<td>DML语句 访问表结构并且写表数据</td>
</tr>
<tr>
<td>MDL_SHARED_WRITE_LOW_PRIO</td>
<td>仅对MyISAM存储引擎有效</td>
</tr>
<tr>
<td>MDL_SHARED_UPGRADABLE</td>
<td>ALTER TABLE是mysql5.6引入的新的metadata lock, 在alter table/create index/drop index会加该锁。特点是允许DML，防止DDL；</td>
</tr>
<tr>
<td>MDL_SHARED_READ_ONLY</td>
<td>LOCK xxx READ</td>
</tr>
<tr>
<td>MDL_SHARED_NO_WRITE</td>
<td>FLUSH TABLES xxx,yyy,zzz READ可升级锁，访问表结构并且读写表数据，并且禁止其它事务写。</td>
</tr>
<tr>
<td>MDL_SHARED_NO_READ_WRITE</td>
<td>FLUSH TABLE xxx WRITE可升级锁，访问表结构并且读写表数据，并且禁止其它事务读写。</td>
</tr>
<tr>
<td>MDL_EXCLUSIVE</td>
<td>ALTER TABLE xxx PARTITION BY …防止其他线程读写元数据</td>
</tr>
</tbody></table>
<h3 id="Online-DDL过程"><a href="#Online-DDL过程" class="headerlink" title="Online DDL过程"></a>Online DDL过程</h3><ol>
<li>拿MDL写锁 ： 当A、B线程都来做DDL的时候，如A拿到了DDL写锁，B就阻塞，其它读数据的线程阻塞，该步执行时间短</li>
<li>DDL执行准备： 当A、B线程都来做DDL的时候，如A拿到了DDL写锁，B任然阻塞，其它读数据的线程阻塞，该步执行时间短</li>
<li>降级成MDL读锁 ： 当A、B线程都来做DDL的时候，如A拿到了DDL写锁，B任然阻塞，其它读数据的线程可以读取数据，该步执行时间短</li>
<li>DDL核心执行：（耗时最多的） 当A、B线程都来做DDL的时候，如A拿到了DDL写锁，B任然阻塞，其它读数据的线程可以读取数据（关键是其它线程可以读取数据），该步执行时间长，所以号称在线DDL，因为影响业务线程读取数据的时间很短</li>
<li>升级成MDL写锁: 当A、B线程都来做DDL的时候，如A拿到了DDL写锁，B任然阻塞，，其它读数据的线程阻塞，该步执行时间短</li>
<li>DDL最终提交 ： 当A、B线程都来做DDL的时候，如A拿到了DDL写锁，B任然阻塞，，其它读数据的线程阻塞，该步执行时间短</li>
<li>释放MDL锁 ： 当A、B线程都来做DDL的时候，如A释放写锁，B拿到DDL锁，，其它读数据的线程阻塞，该步执行时间短，继续循环上面个的步骤</li>
</ol>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p><strong>表锁的语法是 lock tables … read/write</strong><br>可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。<br>需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象</p>
<p>例如：<br>线程 A 中执行 lock tables t1 read, t2 write;<br>这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。<br>同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表</p>
<p><strong>InnoDB 这种支持行锁的引擎</strong>，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大</p>
<p>MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p>
<p>MDL 锁是系统默认添加的</p>
<ul>
<li><p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</p>
</li>
<li><p>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p>
</li>
</ul>
<p>Table MDL事故分析：给一个小表加个字段，导致整个库挂了</p>
<img src="/images/mysql-lock/7cf6a3bf90d72d1f0fc156ececdfb0ce.jpg" alt="img" style="zoom:50%;" />

<p>session A 先启动，这时候会对表 t 加一个 MDL 读锁。由于 session B 需要的也是 MDL 读锁，因此可以正常执行。<br>session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞。<br><strong>因为：</strong>申请MDL锁的操作会形成一个队列，队列中写锁获取优先级高于读锁。一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作。事务一旦申请到MDL锁后，直到事务执行完才会将锁释放。<br>所以session D也会因为session C而被blocked</p>
<p>针对以上事故最佳实践：</p>
<ol>
<li>解决长事务，事务不提交，就会一直占着 MDL 锁。要考虑先暂停 DDL，或者 kill 掉这个长事务</li>
<li>比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，<br>拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程（注意mysql版本，是否支持该语法）</li>
</ol>
<h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><ul>
<li>意向锁是一种特殊的<strong>表级锁</strong>，意向锁是为了让 InnoDB 多粒度的锁能共存而设计的</li>
<li>意向锁分为：<ul>
<li><strong>意向共享锁</strong>(intention shared lock, IS)，它预示着，事务有意向对表中的某些行加共享S锁</li>
<li><strong>意向排它锁</strong>(intention exclusive lock, IX)，它预示着，事务有意向对表中的某些行加排它X锁</li>
<li>select … lock in share mode，要设置<strong>IS锁</strong>；select … for update，要设置<strong>IX锁</strong>；</li>
</ul>
</li>
<li>意向锁协议(intention locking protocol)：<ul>
<li>事务要获得某些行的<strong>S锁</strong>，必须先获得表的<strong>IS锁</strong></li>
<li>事务要获得某些行的<strong>X锁</strong>，必须先获得表的<strong>IX锁</strong></li>
<li>意向共享锁和意向排他锁都是系统自动添加和自动释放的，整个过程无需人工干预</li>
</ul>
</li>
<li>主要是用来辅助表级和行级锁的冲突判断，因为 Innodb 支持行级锁，如果没有意向锁，则判断表锁和行锁冲突的时候需要遍历表上所有行锁，有了意向锁，则只要判断表是否存在意向锁就可以知道是否有行锁了。表级别锁的兼容性如下表：</li>
</ul>
<table>
<thead>
<tr>
<th>是否兼容当前锁模式</th>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
</tr>
<tr>
<td>IX</td>
<td>冲突</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
</tr>
<tr>
<td>S</td>
<td>冲突</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IS</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p>意向锁与意向锁兼容，IX、IS 自身以及相互都兼容，不互斥，因为意向锁仅表示下一层级加什么类型的锁，不代表当前层加什么类型的锁；<br>IX 和表级 X、S 互斥；IS 和表级 X 锁互斥。其兼容性正好体现了其作用</p>
<p><strong>比如</strong>：事务A要在一个表上加S锁，如果表中的一行已被事务B加了X锁，那么该锁的申请也应被阻塞<br>如果表中的数据很多，逐行检查锁标志的开销将很大，系统的性能将会受到影响，因为事务B已经设置了IX锁，所以无需逐行遍历了</p>
<h2 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h2><ul>
<li>自增锁是一种特殊的表级锁，主要用于事务中插入自增字段，也就是我们最常用的自增主键id</li>
</ul>
<ol>
<li>自增锁不是事务锁，每次申请完就马上释放，以便其它事务再申请</li>
<li>MySQL 5.0，自增锁的范围是语句级别<ul>
<li>一个语句申请了自增锁，需要等到语句结束后才会释放，<em><strong>影响并发度</strong></em></li>
</ul>
</li>
<li>MySQL 5.1.22，引入了一个新策略，新增参数innodb_autoinc_lock_mode，默认值为1<ul>
<li><code>innodb_autoinc_lock_mode=0</code>，表示采用之前MySQL 5.0的策略，<strong>语句级别</strong></li>
<li><code>innodb_autoinc_lock_mode=1</code><ul>
<li>普通<code>INSERT</code>语句，自增锁在申请后<strong>马上释放</strong>，包括批量的<code>INSERT INTO...VALUES</code></li>
<li>类似<code>INSERT...SELECT</code>这样的<strong>批量插入</strong>（无法明确数量）的语句，还是<strong>语句级别</strong></li>
</ul>
</li>
<li><code>innodb_autoinc_lock_mode=2</code>，所有的申请自增id的动作都是<strong>申请后就释放锁</strong></li>
</ul>
</li>
</ol>
<h2 id="插入意向锁（Insert-Intention-Locks）"><a href="#插入意向锁（Insert-Intention-Locks）" class="headerlink" title="插入意向锁（Insert Intention Locks）"></a>插入意向锁（Insert Intention Locks）</h2><p><a href="https://link.juejin.cn/?target=https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html%23innodb-insert-intention-locks">MySql 手册</a> 是如何解释 <strong>InnoDB</strong> 中的<code>插入意向锁</code>的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An insert intention lock is a type of gap lock set by INSERT operations prior to row insertion. This lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap. Suppose that there are index records with values of 4 and 7. Separate transactions that attempt to insert values of 5 and 6, respectively, each lock the gap between 4 and 7 with insert intention locks prior to obtaining the exclusive lock on the inserted row, but do not block each other because the rows are nonconflicting.</span><br></pre></td></tr></table></figure>

<p><code>插入意向锁</code>的特性可以分成两部分：</p>
<ol>
<li><code>插入意向锁</code>是一种特殊的<code>间隙锁</code> —— <code>间隙锁</code>可以锁定<strong>开区间</strong>内的部分记录。</li>
<li>插入意向锁是在插入一条记录行前，由 <strong>INSERT</strong> 操作产生的一种间隙锁</li>
<li><code>插入意向锁</code>之间互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身（<code>主键</code>、<code>唯一索引</code>）不冲突，那么事务之间就不会出现<strong>冲突等待</strong>。</li>
<li>虽然<code>插入意向锁</code>中含有<code>意向锁</code>三个字，但是它并不属于<code>意向锁</code>而属于<code>间隙锁</code>，因为<code>意向锁</code>是<strong>表锁</strong>而<code>插入意向锁</code>是<strong>行锁</strong></li>
</ol>
<h2 id="行锁、Gap锁、Next-key-Lock"><a href="#行锁、Gap锁、Next-key-Lock" class="headerlink" title="行锁、Gap锁、Next-key Lock"></a>行锁、Gap锁、Next-key Lock</h2><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><ol>
<li>MySQL的行锁是在<strong>存储引擎层</strong>实现的</li>
<li>MyISAM不支持行锁，而InnoDB支持行锁，这是InnoDB替代MyISAM的一个重要原因</li>
</ol>
<h4 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h4><ol>
<li>两阶段锁<ul>
<li>在InnoDB事务中，行锁是在<strong>需要的时候</strong>加上</li>
<li>但并不是在不需要了就立刻释放，而是要等待<strong>事务结束</strong>后才释放</li>
</ul>
</li>
<li>如果事务需要<strong>锁定多行</strong>，要就把最可能<strong>造成锁冲突</strong>和<strong>影响并发度</strong>的锁尽可能<strong>往后放</strong></li>
</ol>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><img src="/images/mysql-lock/mysql-innodb-dead-lock.jpg" alt="img" style="zoom:50%;" />

<ol>
<li>事务A在等待事务B释放id=2的行锁，事务B在等待事务A释放id=1的行锁，导致<strong>死锁</strong></li>
<li>当出现死锁后，有2种处理策略<ul>
<li>等待，直至超时（不推荐）<ul>
<li><strong>业务有损</strong>：业务会出现大量超时</li>
</ul>
</li>
<li>死锁检测（推荐）<ul>
<li><strong>业务无损</strong>：业务设计不会将死锁当成严重错误，当出现死锁时可采取：<em><strong>事务回滚+业务重试</strong></em></li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="锁等待"><a href="#锁等待" class="headerlink" title="锁等待"></a>锁等待</h4><ol>
<li>由参数<code>innodb_lock_wait_timeout</code>控制（MySQL 5.7.15引入）</li>
<li>默认是50s，对于<strong>在线服务</strong>来说是无法接受的</li>
<li>但也<strong>不能设置成很小的值</strong>，因为如果实际上并不是死锁，只是简单的锁等待，会出现很多<strong>误伤</strong></li>
</ol>
<h4 id="死锁检测（推荐）"><a href="#死锁检测（推荐）" class="headerlink" title="死锁检测（推荐）"></a>死锁检测（推荐）</h4><ol>
<li><p>发现死锁后，主动回滚锁链条中的某一事务，让其他事务继续执行</p>
<ul>
<li>需要设置参数<code>innodb_deadlock_detect</code></li>
</ul>
</li>
<li><p>触发死锁检测：<strong>要加锁访问的行上有锁</strong></p>
<ul>
<li><strong>一致性读不会加锁</strong></li>
</ul>
</li>
<li><p>死锁检测并不需要扫描所有事务</p>
<ul>
<li>某个时刻，事务等待状态为：事务B等待事务A，事务D等待事务C</li>
<li>新来事务E，事务E需要等待D，那么只会判断事务CDE是否会形成死锁</li>
</ul>
</li>
<li><p>CPU消耗高</p>
<ul>
<li>每个新来的线程发现自己要加锁访问的行上有锁<ul>
<li>会去判断会不会<strong>由于自己的加入而导致死锁</strong>，总体时间复杂度为 O(n²)</li>
</ul>
</li>
<li>假设有1000个并发线程，最坏情况下死锁检测的操作量级为100W（1000²）<br>解释：假设有 1000 个并发线程，都要同时更新<strong>同一行</strong>，<br>​            <strong>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁</strong><br>​            第 1 个线程来的时候检测数是 0；<br>​            第 2 个线程来的时候，需要检测【线程1】有没有被别人锁住；<br>​            第 3 个线程来的时候，需要检测【线程1，线程2】有没有被其他线程锁住，<br>​            以此类推，第 n 个线程来的时候，检测数是 n - 1，<br>​            所以总的检测数是 0 + 1 + 2 + 3 + 。。。+ (n - 1) = n(n -1)/2，所以时间复杂度应该是 O(n²)<br>​            <strong>也就是 1000 个并发线程同时操作同一行，那么死锁检测操作就是 100 万这个量级的</strong></li>
</ul>
</li>
<li><p>解决方法</p>
<ul>
<li>如果业务能确保一定不会出现死锁，可以<strong>临时关闭死锁检测</strong>，但存在一定的风险（超时）</li>
<li>控制并发度，如果并发下降，那么死锁检测的成本就会降低，这需要在数据库服务端实现<ul>
<li>如果有<strong>中间件</strong>，可以在中间件实现</li>
<li>如果能修改<strong>MySQL源码</strong>，可以在MySQL内部实现</li>
</ul>
</li>
<li>设计上的优化<ul>
<li>将一行改成<strong>逻辑上的多行</strong>来<strong>减少锁冲突</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%innodb_deadlock_detect%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name          <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_deadlock_detect <span class="operator">|</span> <span class="keyword">ON</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+-------+</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%innodb_lock_wait_timeout%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name            <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_lock_wait_timeout <span class="operator">|</span> <span class="number">30</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------+</span></span><br></pre></td></tr></table></figure>
<h3 id="GAP-Lock"><a href="#GAP-Lock" class="headerlink" title="GAP Lock"></a>GAP Lock</h3><ol>
<li>产生幻读的原因：行锁只能锁住行，新插入记录这个动作，要更新的是记录之间的<strong>间隙</strong></li>
<li>为了解决幻读，InnoDB引入了新的锁：<strong>间隙锁</strong>（<strong>Gap Lock</strong>）</li>
<li>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的</li>
</ol>
<h4 id="Gap-Lock-作用场景"><a href="#Gap-Lock-作用场景" class="headerlink" title="Gap Lock 作用场景"></a>Gap Lock 作用场景</h4><ol>
<li>对主键或唯一索引，如果当前读时，where条件全部精确命中(=或者in)，这种场景本身就不会出现幻读，所以只会加行记录锁</li>
<li>没有索引的列，当前读操作时，会加全表gap锁，生产环境要注意</li>
<li>非唯一索引列，如果where条件部分命中(&gt;、&lt;、like等)或者全未命中，则会加附近Gap间隙锁。<br>例如，某表数据如下，非唯一索引2,6,9,9,11,15。如下语句要操作非唯一索引列9的数据，gap锁将会锁定的列是(6,11]，该区间内无法插入数据。</li>
</ol>
<h4 id="Gap-Lock冲突关系"><a href="#Gap-Lock冲突关系" class="headerlink" title="Gap Lock冲突关系"></a>Gap Lock冲突关系</h4><p>跟<strong>间隙锁</strong>存在冲突关系的是<strong>往这个间隙插入一个记录的操作</strong>，<strong>间隙锁之间不会相互冲突</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">    `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `c` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `d` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `c` (`c`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span> (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">session A</th>
<th align="left">session B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BEGIN; <br />SELECT * FROM t WHERE c=7 LOCK IN SHARE MODE;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">BEGIN;<br />SELECT * FROM t WHERE c=7 FOR UPDATE;</td>
</tr>
</tbody></table>
<ol>
<li>session B并不会被阻塞，因为表t里面并没有c=7的记录<ul>
<li>因此session A加的是<strong>间隙锁</strong><code>(5,10)</code>，而session B也是在这个间隙加间隙锁</li>
<li>两个session有共同的目标： 保护这个间隙，不允许插入值，但两者之间不冲突</li>
</ul>
</li>
</ol>
<h3 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h3><ol>
<li>间隙锁和行锁合称<code>Next-Key Lock</code>，每个<code>Next-Key Lock</code>都是<strong>左开右闭</strong>区间</li>
<li><code>SELECT * FROM t WHERE d=5 FOR UPDATE;</code>形成了7个<code>Next-Key Lock</code>，分别是<ul>
<li><code>(-∞,0],(0,5],(5,10],(10,15],(15,20],(20,25],(25,+supremum]</code></li>
<li><code>+supremum</code>：InnoDB给每一个索引加的一个<strong>不存在的最大值supremum</strong></li>
</ul>
</li>
<li>约定：<code>Gap Lock</code>为<strong>左开右开</strong>区间，<code>Next-Key Lock</code>为<strong>左开右闭</strong>区间</li>
</ol>
<h2 id="MySql-加锁规则"><a href="#MySql-加锁规则" class="headerlink" title="MySql 加锁规则"></a>MySql 加锁规则</h2><h3 id="加锁逻辑"><a href="#加锁逻辑" class="headerlink" title="加锁逻辑"></a>加锁逻辑</h3><p><strong>两个“原则”、两个“优化”和一个“bug”</strong><br>MySQL 后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即 <strong>5.x 系列 &lt;=5.7.24</strong>，<strong>8.0 系列 &lt;=8.0.13</strong></p>
<p>原则 1：加锁的基本单位是 next-key lock。next-key lock 是前开后闭区间。<br>原则 2：查找过程中访问到的对象才会加锁。<br>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。<br>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。<br>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p>
<p>优化及回滚策略：</p>
<ol>
<li>锁是<strong>一个一个</strong>加的，为了避免死锁，对<strong>同一组资源</strong>，尽量按照<strong>相同的顺序</strong>访问</li>
<li>在发生死锁的时候，<code>FOR UPDATE</code>占用的资源更多，<strong>回滚成本更大</strong>，因此选择回滚<code>LOCK IN SHARE MODE</code></li>
</ol>
<h3 id="锁兼容列表"><a href="#锁兼容列表" class="headerlink" title="锁兼容列表"></a>锁兼容列表</h3><table>
<thead>
<tr>
<th>是否兼容</th>
<th>gap</th>
<th>insert intention</th>
<th>record</th>
<th>next-key</th>
</tr>
</thead>
<tbody><tr>
<td><strong>gap</strong></td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td><strong>insert intention</strong></td>
<td><strong>否</strong></td>
<td>是</td>
<td>是</td>
<td><strong>否</strong></td>
</tr>
<tr>
<td><strong>record</strong></td>
<td>是</td>
<td>是</td>
<td><strong>否</strong></td>
<td><strong>否</strong></td>
</tr>
<tr>
<td><strong>next-key</strong></td>
<td>是</td>
<td>是</td>
<td><strong>否</strong></td>
<td><strong>否</strong></td>
</tr>
</tbody></table>
<h2 id="加锁、死锁分析"><a href="#加锁、死锁分析" class="headerlink" title="加锁、死锁分析"></a>加锁、死锁分析</h2><p><strong>没有明确说明的情况下 均为RR级别</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `e` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `c` (`c`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `d` (`d`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<h3 id="加锁分析"><a href="#加锁分析" class="headerlink" title="加锁分析"></a>加锁分析</h3><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><ol>
<li><p>等值查询：命中降级成 Row Lock</p>
<table>
<thead>
<tr>
<th align="left">session A</th>
<th align="left">session B</th>
<th align="left">session C</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BEGIN; <br />UPDATE t SET d=d+1 WHERE id=10;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">INSERT INTO t VALUES(1,1,1,1); <br />(Query OK)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">INSERT INTO t VALUES(16,16,16,16); <br />(Query OK)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE id=5; <br />(Query OK)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE id=10; <br />(Blocked)</td>
</tr>
</tbody></table>
<p>session A持有的锁：<code>PRIMARY:X Lock:10</code></p>
</li>
<li><p>等值查询：不命中降级（<strong>Next-Key Lock降级为Gap Lock</strong>）</p>
<table>
<thead>
<tr>
<th align="left">session A</th>
<th align="left">session B</th>
<th align="left">session C</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BEGIN; <br />UPDATE t SET d=d+1 WHERE id=7;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">INSERT INTO t VALUES(1,1,1,1); <br />(Query OK)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">INSERT INTO t VALUES(8,8,8,8);<br />(Blocked)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE id=5;<br />(Query OK)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE id=10; <br />(Query OK)</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- session B Blocked</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> locked_index,locked_type,waiting_lock_mode,blocking_lock_mode <span class="keyword">FROM</span> sys.innodb_lock_waits <span class="keyword">WHERE</span> locked_table<span class="operator">=</span><span class="string">&#x27;`test`.`t`&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------------+-------------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> locked_index <span class="operator">|</span> locked_type <span class="operator">|</span> waiting_lock_mode <span class="operator">|</span> blocking_lock_mode <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------------+-------------------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">PRIMARY</span>      <span class="operator">|</span> RECORD      <span class="operator">|</span> X,GAP             <span class="operator">|</span> X,GAP              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------------+-------------------+--------------------+</span></span><br></pre></td></tr></table></figure>

<p>session A持有的锁：<code>PRIMARY:Gap Lock:(5,10)</code></p>
</li>
<li><p>范围查询 – 起点降级（<strong>Next-Key Lock降级为Row Lock</strong>）</p>
<table>
<thead>
<tr>
<th align="left">session A</th>
<th align="left">session B</th>
<th align="left">session C</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BEGIN; <br />SELECT * FROM t WHERE id&gt;=10 AND id&lt;11 FOR UPDATE;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">INSERT INTO t VALUES (8,8,8,8); <br />(Query OK)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">INSERT INTO t VALUES (13,13,13,13); (Blocked)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE id=10; (Blocked)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE id=15; (Blocked)</td>
</tr>
</tbody></table>
<p>条件会拆分成<code>=10</code>（<code>Row Lock</code>）和<code>&gt;10 &amp; &lt;11</code>，session A持有的锁：<code>PRIMARY:X Lock:10</code>+<code>PRIMARY:Next-Key Lock:(10,15]</code></p>
</li>
<li><p>范围查询 – 尾点延伸 （直到遍历到<strong>第一个不满足的值</strong>为止）</p>
<table>
<thead>
<tr>
<th align="left">session A</th>
<th align="left">session B</th>
<th align="left">session C</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BEGIN;<br />SELECT * FROM t WHERE id&gt;10 AND id&lt;=15 FOR UPDATE;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">INSERT INTO t VALUES (16,16,16,16); (Blocked)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE id=20; (Blocked)</td>
</tr>
</tbody></table>
<p>session A持有的锁：<code>PRIMARY:Next-Key Lock:(10,15]</code>+<code>PRIMARY:Next-Key Lock:(15,20]</code></p>
</li>
</ol>
<h4 id="不唯一索引"><a href="#不唯一索引" class="headerlink" title="不唯一索引"></a>不唯一索引</h4><ol>
<li><p>等值查询 – LOCK IN SHARE MODE</p>
<table>
<thead>
<tr>
<th align="left">session A</th>
<th align="left">session B</th>
<th align="left">session C</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BEGIN; <br />SELECT id FROM t WHERE c=5 LOCK IN SHARE MODE;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">INSERT INTO t VALUES (7,7,7,7); <br />(Blocked)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE id=5;<br /> (Query OK)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE c=10;<br /> (Query OK)</td>
</tr>
</tbody></table>
<p>session A用到了索引覆盖（只查询主键id），并且是加 s锁，所以无需回表对主键id加锁，加锁如下：<br>session A持有的锁：<code>c:Next-Key Lock:(0,5]</code>+<code>c:Gap Lock:(5,10)</code></p>
</li>
<li><p>等值查询 – FOR UPDATE</p>
<table>
<thead>
<tr>
<th align="left">session A</th>
<th align="left">session B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BEGIN; <br />SELECT id FROM t WHERE c=5 FOR UPDATE;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE id=5; <br />(Blocked)</td>
</tr>
</tbody></table>
<p>上一个例子中<code>LOCK IN SHARE MODE</code>只会锁住<strong>覆盖索引</strong>，而<code>FOR UPDATE</code>会同时给<strong>聚簇索引</strong>上<strong>满足条件的行</strong>加上<strong>X Lock</strong>，加锁如下：<br>session A持有的锁：<code>c:Next-Key Lock:(0,5]</code>+<code>c:Gap Lock:(5,10)</code>+<code>PRIMARY:X Lock:5</code></p>
</li>
<li><p>等值查询 – 绕过覆盖索引</p>
<table>
<thead>
<tr>
<th align="left">session A</th>
<th align="left">session B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BEGIN; <br />SELECT d FROM t WHERE c=5 LOCK IN SHARE MODE</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE id=5;<br /> (Blocked)</td>
</tr>
</tbody></table>
<p>无法利用覆盖索引，就必须<strong>回表</strong>，与上面<code>FOR UPDATE</code>的情况一致，加锁如下：<br>session A持有的锁：<code>c:Next-Key Lock:(0,5]</code>+<code>c:Gap Lock:(5,10)</code>+<code>PRIMARY:S Lock:5</code></p>
</li>
<li><p>等值查询 – 相同的值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- c=10有两行，两行之间也存在Gap</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span> (<span class="number">30</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<img src="/images/mysql-lock//image-20210908144035137.png" alt="image-20210908144035137" style="zoom:80%;" />

<table>
<thead>
<tr>
<th align="left">session A</th>
<th align="left">session B</th>
<th align="left">session C</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BEGIN; <br />DELETE FROM t WHERE c=10;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">INSERT INTO t VALUES (12,12,12); <br />(Blocked)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE c=5;<br />(Query OK)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE c=15;<br />(Query OK)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE id=5; <br />(Query OK)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE id=15; <br />(Query OK)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE id=10; <br />(Blocked)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE id=30;<br />(Blocked)</td>
</tr>
</tbody></table>
<img src="/images/mysql-lock//image-20210908144122524.png" alt="image-20210908144122524" style="zoom:80%;" />

<p>session A持有的锁</p>
<ul>
<li><code>c:Next-Key Lock:((c=5,id=5),(c=10,id=10)]</code>+<code>c:Gap Lock:((c=10,id=10),(c=15,id=15))</code></li>
<li><code>PRIMARY:X Lock:10</code>+<code>PRIMARY:X Lock:30</code></li>
</ul>
</li>
<li><p>等值查询 – LIMIT</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 与上面“相同的值”一样</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span> (<span class="number">30</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">session A</th>
<th align="left">session B</th>
<th align="left">session C</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BEGIN; <br />DELETE FROM t WHERE c=10 LIMIT 2;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">INSERT INTO t VALUES (12,12,12,12);<br />(Query OK)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE id=10;<br />(Blocked)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE id=30;<br />(Blocked)</td>
</tr>
</tbody></table>
<p>在遍历到<code>(c=10,id=30)</code>这一行记录后，已经有两行记录满足条件，<strong>循环结束</strong>，session A在二级索引c上的加锁效果如下所示</p>
<img src="/images/mysql-lock//image-20210908151745952.png" alt="image-20210908151745952" style="zoom:90%;" />

<p>session A持有的锁</p>
<ul>
<li><code>c:Next-Key Lock:((c=5,id=5),(c=10,id=10)]</code>+<code>c:Next-Key Lock:((c=10,id=10),(c=10,id=30)]</code></li>
<li><code>PRIMARY:X Lock:10</code>+<code>PRIMARY:X Lock:30</code></li>
</ul>
<p>因此在删除数据时，尽量加上<code>LIMIT</code>，可以<strong>控制删除数据的条数</strong>，也可以<strong>减少加锁的范围</strong></p>
</li>
<li><p>范围查询</p>
<table>
<thead>
<tr>
<th align="left">session A</th>
<th align="left">session B</th>
<th align="left">session C</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BEGIN; <br />SELECT * FROM t WHERE c&gt;=10 AND c&lt;11 FOR UPDATE;</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">INSERT INTO t VALUES (8,8,8,8); (Blocked)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE id=10; (Blocked)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE c=15; (Blocked)</td>
</tr>
</tbody></table>
<p>由于二级索引<code>c</code>是<strong>非唯一索引</strong>，因此没法降级为<strong>行锁</strong><br>session A持有的锁</p>
<ul>
<li><code>c:Next-Key Lock:(5,10]</code>+<code>c:Next-Key Lock:(10,15]</code></li>
<li><code>PRIMARY:X Lock:10</code></li>
</ul>
</li>
</ol>
<h4 id="无索引查询"><a href="#无索引查询" class="headerlink" title="无索引查询"></a>无索引查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> e <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>
<p>RC：对所有记录加 Record Lock 再释放不匹配的记录锁</p>
<ul>
<li>MySQL 加锁时是对处理过程中“扫描”到的记录加锁，不管这条记录最终是不是通过 WHERE 语句剔除了</li>
<li>对于 READ COMMITTED，MySQL 在扫描结束后，会违反上条原则，释放 WHERE 条件不满足的记录锁<br>RR：通过聚簇索引，逐行扫描，逐行加锁，且索引前后都要加 Gap Lock，事务提交后统一释放锁</li>
</ul>
<h4 id="ORDER-BY-DESC"><a href="#ORDER-BY-DESC" class="headerlink" title="ORDER BY DESC"></a>ORDER BY DESC</h4><table>
<thead>
<tr>
<th align="left">session A</th>
<th align="left">session B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BEGIN;<br />SELECT * FROM t WHERE c&gt;=15 AND c &lt;=20 ORDER BY c DESC LOCK IN SHARE MODE;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">INSERT INTO t VALUES (6,6,6);<br />(Blocked)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">INSERT INTO t VALUES (21,21,21);<br />(Blocked)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE id=10;<br />(Query OK)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE id=25;<br />(Query OK)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE id=15;<br />(Blocked)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">UPDATE t SET d=d+1 WHERE id=20;<br />(Blocked)</td>
</tr>
</tbody></table>
<ol>
<li><code>ORDE BY DESC</code>，首先找到第一个满足<code>c=20</code>的行，session A持有锁：<code>c:Next-Key Lock:(15,20]</code></li>
<li>由于二级索引<code>c</code>是<strong>非唯一索引</strong>，继续向<strong>右</strong>遍历，session A持有锁：<code>c:Gap Key Lock:(20,25)</code></li>
<li>向<strong>左</strong>遍历，<code>c=15</code>，session A持有锁：<code>c:Next-Key Lock:(10,15]</code></li>
<li>继续向<strong>左</strong>遍历，<code>c=10</code>，session A持有锁：<code>c:Next-Key Lock:(5,10]</code></li>
<li>上述过程中，满足条件的主键为<code>id=15</code>和<code>id=20</code>，session A持有<strong>聚簇索引</strong>上对应行的<code>S Lock</code></li>
<li>总结，session A持有的锁<ul>
<li><code>c:Next-Key Lock:(5,10]</code>+<code>c:Next-Key Lock:(10,15]</code>+<code>c:Next-Key Lock:(15,20]</code>+<code>c:Gap Key Lock:(20,25)</code></li>
<li><code>PRIMARY:S Lock:15</code>+<code>PRIMARY:S Lock:20</code></li>
</ul>
</li>
</ol>
<h4 id="等值-VS-遍历"><a href="#等值-VS-遍历" class="headerlink" title="等值 VS 遍历"></a>等值 VS 遍历</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id<span class="operator">&gt;</span><span class="number">12</span> <span class="keyword">AND</span> id<span class="operator">&lt;</span><span class="number">18</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">DESC</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>利用上面的加锁规则，加锁范围如下<ul>
<li><code>PRIMARY:Next-Key Lock:(5,10]</code></li>
<li><code>PRIMARY:Next-Key Lock:(5,15]</code></li>
<li><code>PRIMARY:Gap Lock:(15,20)</code></li>
</ul>
</li>
<li>加锁动作是发生在语句执行过程中<ul>
<li><code>ORDER BY DESC</code>，优化器必须先找到<strong>第一个id&lt;18的值</strong></li>
<li>这个过程是通过<strong>索引树的搜索过程</strong>得到的，其实是在引擎内部查找<code>id=18</code></li>
<li>只是最终没找到，而找到了<code>(15,20)</code>这个间隙</li>
<li>然后<strong>向左遍历</strong>，在这个遍历过程，就不是等值查询了</li>
<li>会扫描到 id=10 这一行，所以会加一个 next-key lock (5,10]</li>
</ul>
</li>
<li>在执行过程中，通过<strong>树搜索</strong>的方式定位记录的过程，用的是<strong>等值查询</strong></li>
</ol>
<h4 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">IN</span> (<span class="number">5</span>,<span class="number">20</span>,<span class="number">10</span>) LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Using index：使用了覆盖索引</span></span><br><span class="line"><span class="comment">-- key=c：使用了索引c</span></span><br><span class="line"><span class="comment">-- rows=3：三个值都是通过树搜索定位的</span></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">IN</span> (<span class="number">5</span>,<span class="number">20</span>,<span class="number">10</span>) LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+--------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> t     <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> c             <span class="operator">|</span> c    <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+--------------------------</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>查找c=5：<code>c:Next-Key Lock:(0,5]</code>+<code>c:Gap Lock:(5,10)</code></p>
</li>
<li><p>查找c=10：<code>c:Next-Key Lock:(5,10]</code>+<code>c:Gap Lock:(10,15)</code></p>
</li>
<li><p>查找c=20：<code>c:Next-Key Lock:(15,20]</code>+<code>c:Gap Lock:(20,25)</code></p>
</li>
<li><p>锁是在执行过程中是<strong>一个一个</strong>加的</p>
</li>
</ul>
<ol>
<li><p>ORDER BY DESC</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">IN</span> (<span class="number">5</span>,<span class="number">20</span>,<span class="number">10</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> c <span class="keyword">DESC</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN <span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">IN</span> (<span class="number">5</span>,<span class="number">20</span>,<span class="number">10</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> c <span class="keyword">DESC</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra                                         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> t     <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> c             <span class="operator">|</span> c    <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span>; Backward index scan; <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>ORDER BY DESC</code>：先锁<code>c=20</code>，再锁<code>c=10</code>，最后锁<code>c=5</code></p>
</li>
<li><p><strong>加锁资源相同</strong>，但<strong>加锁顺序相反</strong>，如果语句是并发执行的，可能会出现<strong>死锁</strong></p>
</li>
</ul>
</li>
</ol>
<h3 id="死锁分析"><a href="#死锁分析" class="headerlink" title="死锁分析"></a>死锁分析</h3><h4 id="案例1：插入意向锁死锁案例"><a href="#案例1：插入意向锁死锁案例" class="headerlink" title="案例1：插入意向锁死锁案例"></a>案例1：插入意向锁死锁案例</h4><table>
<thead>
<tr>
<th>trx_1</th>
<th><strong>trx_2</strong></th>
</tr>
</thead>
<tbody><tr>
<td>start transaction;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>start transaction;</td>
</tr>
<tr>
<td>update t set e = 1 where c = 5;<br />索引c上加(0,5] next-key 、(5,10) gap</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set e = 1 where c = 5; <br />因为加锁是一个动态过程，首先加gap锁 (0,5)，因为gap锁兼容，所以可以获取到这个gap锁<br />当扫描到c=5这行时，需要加行锁，但是此行锁已经在被事务1获取，所以无法获取到行锁，<br />所以事务2需要等待事务1释放锁，所以产生锁等待</td>
</tr>
<tr>
<td>insert into t set id = 4, c = 5;<br />插入语句会产生插入意向锁，会判断是否存在(0,5)gap、(0,5] next-key，<br />因为事务2持有(0,5)gap，如果需要插入成功，需要事务2释放(0,5)gap，<br />但是事务2又在等待事务1释放 c=5行锁，因此产生了环形等待，即死锁，所以触发事务2回滚</td>
<td>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</td>
</tr>
</tbody></table>
<h2 id="分析死锁日志"><a href="#分析死锁日志" class="headerlink" title="分析死锁日志"></a>分析死锁日志</h2><ul>
<li>死锁场景：</li>
</ul>
<table>
<thead>
<tr>
<th>session A</th>
<th>session B</th>
</tr>
</thead>
<tbody><tr>
<td>BEGIN;</td>
<td></td>
</tr>
<tr>
<td>SELECT id FROM t WHERE c=5 LOCK IN SHARE MODE;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>BEGIN;</td>
</tr>
<tr>
<td></td>
<td>SELECT id FROM t WHERE c=20 FOR UPDATE;</td>
</tr>
<tr>
<td>SELECT id FROM t WHERE c=20 LOCK IN SHARE MODE;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>SELECT id FROM t WHERE c=5 FOR UPDATE;</td>
</tr>
<tr>
<td>Deadlock found when trying to get lock; try restarting transaction</td>
<td></td>
</tr>
</tbody></table>
<p>MySQL只保留<strong>最后一个死锁的现场</strong>，并且这个现场还不完备</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> ENGINE INNODB STATUS\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> (<span class="number">1</span>) TRANSACTION:</span><br><span class="line">TRANSACTION <span class="number">421596638701408</span>, ACTIVE <span class="number">23</span> sec starting index read</span><br><span class="line">mysql tables <span class="keyword">in</span> use <span class="number">1</span>, locked <span class="number">1</span></span><br><span class="line">LOCK WAIT <span class="number">4</span> lock struct(s), heap size <span class="number">1136</span>, <span class="number">3</span> <span class="type">row</span> lock(s)</span><br><span class="line">MySQL thread id <span class="number">2</span>, OS thread handle <span class="number">140121299891968</span>, query id <span class="number">964</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.1</span> root Sending data</span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c<span class="operator">=</span><span class="number">20</span> LOCK <span class="keyword">IN</span> SHARE MODE</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> (<span class="number">1</span>) WAITING <span class="keyword">FOR</span> THIS LOCK <span class="keyword">TO</span> BE GRANTED:</span><br><span class="line">RECORD LOCKS space id <span class="number">39</span> page <span class="keyword">no</span> <span class="number">5</span> n bits <span class="number">80</span> index c <span class="keyword">of</span> <span class="keyword">table</span> `test`.`t` trx id <span class="number">421596638701408</span> lock mode S waiting</span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">6</span> PHYSICAL RECORD: n_fields <span class="number">2</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">4</span>; hex <span class="number">80000014</span>; <span class="keyword">asc</span>     ;;</span><br><span class="line"> <span class="number">1</span>: len <span class="number">4</span>; hex <span class="number">80000014</span>; <span class="keyword">asc</span>     ;;</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> (<span class="number">2</span>) TRANSACTION:</span><br><span class="line">TRANSACTION <span class="number">8656</span>, ACTIVE <span class="number">14</span> sec starting index read</span><br><span class="line">mysql tables <span class="keyword">in</span> use <span class="number">1</span>, locked <span class="number">1</span></span><br><span class="line"><span class="number">5</span> lock struct(s), heap size <span class="number">1136</span>, <span class="number">4</span> <span class="type">row</span> lock(s)</span><br><span class="line">MySQL thread id <span class="number">5</span>, OS thread handle <span class="number">140121299080960</span>, query id <span class="number">968</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.1</span> root Sending data</span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> (<span class="number">2</span>) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id <span class="number">39</span> page <span class="keyword">no</span> <span class="number">5</span> n bits <span class="number">80</span> index c <span class="keyword">of</span> <span class="keyword">table</span> `test`.`t` trx id <span class="number">8656</span> lock_mode X</span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">6</span> PHYSICAL RECORD: n_fields <span class="number">2</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">4</span>; hex <span class="number">80000014</span>; <span class="keyword">asc</span>     ;;</span><br><span class="line"> <span class="number">1</span>: len <span class="number">4</span>; hex <span class="number">80000014</span>; <span class="keyword">asc</span>     ;;</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> (<span class="number">2</span>) WAITING <span class="keyword">FOR</span> THIS LOCK <span class="keyword">TO</span> BE GRANTED:</span><br><span class="line">RECORD LOCKS space id <span class="number">39</span> page <span class="keyword">no</span> <span class="number">5</span> n bits <span class="number">80</span> index c <span class="keyword">of</span> <span class="keyword">table</span> `test`.`t` trx id <span class="number">8656</span> lock_mode X waiting</span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">3</span> PHYSICAL RECORD: n_fields <span class="number">2</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">4</span>; hex <span class="number">80000005</span>; <span class="keyword">asc</span>     ;;</span><br><span class="line"> <span class="number">1</span>: len <span class="number">4</span>; hex <span class="number">80000005</span>; <span class="keyword">asc</span>     ;;</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> WE ROLL BACK TRANSACTION (<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>(1) TRANSACTION</code>：第一个事务的信息</li>
<li><code>(2) TRANSACTION</code>：第二个事务的信息</li>
<li><code>WE ROLL BACK TRANSACTION (1)</code>：最终的处理结果是回滚第一个事务</li>
</ul>
<h4 id="第一个事务"><a href="#第一个事务" class="headerlink" title="第一个事务"></a>第一个事务</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c<span class="operator">=</span><span class="number">20</span> LOCK <span class="keyword">IN</span> SHARE MODE</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> (<span class="number">1</span>) WAITING <span class="keyword">FOR</span> THIS LOCK <span class="keyword">TO</span> BE GRANTED:</span><br><span class="line">RECORD LOCKS space id <span class="number">39</span> page <span class="keyword">no</span> <span class="number">5</span> n bits <span class="number">80</span> index c <span class="keyword">of</span> <span class="keyword">table</span> `test`.`t` trx id <span class="number">421596638701408</span> lock mode S waiting</span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">6</span> PHYSICAL RECORD: n_fields <span class="number">2</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">4</span>; hex <span class="number">80000014</span>; <span class="keyword">asc</span>     ;;</span><br><span class="line"> <span class="number">1</span>: len <span class="number">4</span>; hex <span class="number">80000014</span>; <span class="keyword">asc</span>     ;;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>(1) WAITING FOR THIS LOCK TO BE GRANTED</code>：表示第一个事务在等待的锁的信息</li>
<li><code>index c of table test.t</code>：表示等待表<code>t</code>的索引<code>c</code>上的锁</li>
<li><code>lock mode S waiting</code>：表示正在执行的语句要加一个<code>S Lock</code>，当前状态为<strong>等待中</strong></li>
<li><code>Record lock</code>：表示这是一个<strong>记录锁</strong>（行数）</li>
<li><code>n_fields 2</code>：表示这个记录有2列（二级索引），即字段<code>c</code>和主键字段<code>id</code></li>
<li><code>len 4; hex 80000014; asc ;;</code>：第一个字段<code>c</code><ul>
<li><code>asc</code>：表示接下来要打印值里面的<strong>可打印字符</strong>，20不是可打印字符，因此显示<strong>空格</strong></li>
</ul>
</li>
<li><code>1: len 4; hex 80000014; asc ;;</code>：第二个字段<code>id</code></li>
<li>第一个事务在等待<code>(c=20,id=20)</code>这一行的行锁</li>
<li>但并没有打印出第一个事务本身所占有的锁，可以通过第二个事务反向推导出来</li>
</ol>
<h4 id="第二个事务"><a href="#第二个事务" class="headerlink" title="第二个事务"></a>第二个事务</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c<span class="operator">=</span><span class="number">5</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> (<span class="number">2</span>) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id <span class="number">39</span> page <span class="keyword">no</span> <span class="number">5</span> n bits <span class="number">80</span> index c <span class="keyword">of</span> <span class="keyword">table</span> `test`.`t` trx id <span class="number">8656</span> lock_mode X</span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">6</span> PHYSICAL RECORD: n_fields <span class="number">2</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">4</span>; hex <span class="number">80000014</span>; <span class="keyword">asc</span>     ;;</span><br><span class="line"> <span class="number">1</span>: len <span class="number">4</span>; hex <span class="number">80000014</span>; <span class="keyword">asc</span>     ;;</span><br><span class="line"></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> (<span class="number">2</span>) WAITING <span class="keyword">FOR</span> THIS LOCK <span class="keyword">TO</span> BE GRANTED:</span><br><span class="line">RECORD LOCKS space id <span class="number">39</span> page <span class="keyword">no</span> <span class="number">5</span> n bits <span class="number">80</span> index c <span class="keyword">of</span> <span class="keyword">table</span> `test`.`t` trx id <span class="number">8656</span> lock_mode X waiting</span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">3</span> PHYSICAL RECORD: n_fields <span class="number">2</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">4</span>; hex <span class="number">80000005</span>; <span class="keyword">asc</span>     ;;</span><br><span class="line"> <span class="number">1</span>: len <span class="number">4</span>; hex <span class="number">80000005</span>; <span class="keyword">asc</span>     ;;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>(2) HOLDS THE LOCK(S)</code>：表示第二个事务持有的锁的信息</li>
<li><code>index c of table test.t</code>：表示锁是加在表<code>t</code>的索引<code>c</code>上</li>
<li><code>0: len 4; hex 80000014; asc ;;</code>+<code>1: len 4; hex 80000014; asc ;;</code><ul>
<li>第二个事务持有<code>(c=20,id=20)</code>这一行的行锁（<code>X Lock</code>）</li>
</ul>
</li>
<li><code>(2) WAITING FOR THIS LOCK TO BE GRANTED</code><ul>
<li>第二个事务等待<code>(c=5,id=5)</code>只一行的行锁</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/01/14/mysql-index/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="tlv">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温故而知新">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/14/mysql-index/" class="post-title-link" itemprop="url">MySQL -- 索引</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-15 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-15T00:00:00+08:00">2020-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-11 21:27:38" itemprop="dateModified" datetime="2022-05-11T21:27:38+08:00">2022-05-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Storage/" itemprop="url" rel="index"><span itemprop="name">Storage</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Storage/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>4.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="索引模型"><a href="#索引模型" class="headerlink" title="索引模型"></a>索引模型</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>键 - 值（key-value）存储数据的结构，类似java的HashMap</p>
<img src="/images/mysql-index/0c62b601afda86fe5d0fe57346ace957.png" alt="img" style="zoom:50%;" />

<p><strong>哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎</strong></p>
<h3 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h3><p><strong>有序数组索引只适用于静态存储引擎</strong>，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据</p>
<img src="/images/mysql-index/bfc907a92f99cadf5493cf0afac9ca49.png" alt="img" style="zoom:50%;" />

<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><ol>
<li>等值查询：可以采用<strong>二分法</strong>，时间复杂度为<code>O(log(N))</code></li>
<li>范围查询：查找<code>[ID_card_X,ID_card_Y]</code><ul>
<li>首先通过<strong>二分法</strong>找到第一个大于等于<code>ID_card_X</code>的记录</li>
<li>然后向<strong>右</strong>遍历，直到找到第一个大于<code>ID_card_Y</code>的记录</li>
</ul>
</li>
</ol>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>往中间插入一个记录就必须得挪动后面所有的记录，成本很高，所以只适用于存储静态数据</p>
<h3 id="搜索树"><a href="#搜索树" class="headerlink" title="搜索树"></a>搜索树</h3><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>查询的时间复杂度：<code>O(log(N))</code>，更新的时间复杂度：<code>O(log(N))</code>（维持树的<strong>平衡</strong>）</p>
<img src="/images/mysql-index/04fb9d24065635a6a637c25ba9ddde68.png" alt="img" style="zoom:50%;" />

<h2 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h2><p>使用B+树作为索引模型</p>
<h3 id="B-树数据结构"><a href="#B-树数据结构" class="headerlink" title="B+树数据结构"></a><strong>B+树数据结构</strong></h3><ul>
<li>B+树是 B 树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址，叶子结点以上各层作为索引使用</li>
<li>一棵 m 阶的 B+树定义如下（<em><strong>B+树的阶数 m 表示一个节点最多能有 m 个子节点,也就是每个节点上最多有m-1的关键字</strong></em>）<ul>
<li>每个结点至多有 m 个子节点</li>
<li>除根结点外，每个结点至少有[m/2]个子节点，根结点至少有两个子节点</li>
<li>有 k 个子节点的结点必有 k 个关键字</li>
</ul>
</li>
<li>B+树的查找与 B 树不同，当索引部分某个结点的关键字与所查的关键字相等时，并不停止查找，应继续沿着这个关键字左边的指针向下，一直查到该关键字所在的叶子结点为止</li>
</ul>
<h3 id="MySQL-B-树索引有多少阶"><a href="#MySQL-B-树索引有多少阶" class="headerlink" title="MySQL B+树索引有多少阶"></a><strong>MySQL B+树索引有多少阶</strong></h3><ul>
<li>对于这个问题,我们需要先了解下磁盘相关知识.<ul>
<li>磁盘的最小存储单位是扇区(512 字节)</li>
<li>磁盘的读取是以块为基本单位,一块大小为 8 个扇区,即 4kb</li>
<li>B+树的每一个节点占用的空间就是一个mysql页大小</li>
</ul>
</li>
</ul>
   <img src="/images/mysql-index/bc946b22c5275a1293f7be8902edb256.png" alt="img" style="zoom:60%;" />

<ul>
<li>以 innodb 引擎的索引数据结构为例,它的存储单元为一页,每页大小默认为 16KB<ul>
<li>假设每个节点中索引元素占 8 个字节,指针占用 6 个字节,那么每页可存(16*1024)/(8+6)=1170 个索引元素</li>
<li>假设 B+树的高度为 3,一条数据大小为 1k,那么:第一层可以存 1170 个元素;第二层可以存 1170 * 1170=1368900 个元素;第三层属于叶子结点,可以存的数据条数为页大小 16KB / 每条数据大小 1KB,即 16 条,那么总共可以存储的数据条数即为 16*1368900=21902400</li>
</ul>
</li>
</ul>
<h3 id="MySQL-索引组织表"><a href="#MySQL-索引组织表" class="headerlink" title="MySQL 索引组织表"></a><strong>MySQL 索引组织表</strong></h3><p>   在 InnoDB 中，表都是根据<strong>主键顺序</strong>以索引的形式存放的，这种存储方式的表称为<strong>索引组织表</strong>，每一个<strong>索引</strong>在InnoDB里面都对应一棵<strong>B+树</strong></p>
   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 建表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> T(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    k <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    INDEX (k)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB;</span><br><span class="line"></span><br><span class="line"># 初始化数据</span><br><span class="line">R1 : (<span class="number">100</span>,<span class="number">1</span>)</span><br><span class="line">R2 : (<span class="number">200</span>,<span class="number">2</span>)</span><br><span class="line">R3 : (<span class="number">300</span>,<span class="number">3</span>)</span><br><span class="line">R4 : (<span class="number">500</span>,<span class="number">5</span>)</span><br><span class="line">R5 : (<span class="number">600</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

   <img src="/images/mysql-index/dcda101051f28502bd5c4402b292e38d.png" alt="img" style="zoom:60%;" />

<ol>
<li>根据叶子节点的内容，索引类型分为聚簇索引（clustered index）和二级索引（secondary index）<ul>
<li>聚簇索引的叶子节点存储的是<strong>整行数据</strong></li>
<li>二级索引的叶子节点存储的是<strong>主键的值</strong></li>
</ul>
</li>
<li><code>select * from T where ID=500</code>：只需要搜索ID树</li>
<li><code>select * from T where k=5</code>：先搜索k树，得到ID的值为500，再到ID树搜索，该过程称为<em><strong>回表</strong></em></li>
<li>基于二级索引的查询需要多扫描一棵索引树，因此<strong>尽量使用主键查询</strong></li>
</ol>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a><strong>索引维护</strong></h3><ol>
<li>B+树为了维护<strong>索引的有序性</strong>，在插入新值时，需要做必要的维护</li>
<li>如果新插入的行ID为700，只需要在R5的记录后插入一个新纪录</li>
<li>如果新插入的行ID为400，需要逻辑上（实际采用链表的形式，直接追加）挪动R3后面的数据，空出位置<ul>
<li>如果R5所在的数据页已经满了，根据B+树的算法，需要申请一个新的数据页，然后将部分数据挪过去，称为<em><strong>页分裂</strong></em></li>
<li>页分裂的影响：<strong>性能</strong>、<strong>数据页的利用率</strong></li>
</ul>
</li>
<li>页合并：页分裂的逆过程<ul>
<li>当<strong>相邻</strong>两个页由于<strong>删除</strong>了数据，利用率很低之后，会将数据页合并</li>
</ul>
</li>
</ol>
<h3 id="索引重建"><a href="#索引重建" class="headerlink" title="索引重建"></a><strong>索引重建</strong></h3>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 重建二级索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> T <span class="keyword">DROP</span> INDEX k;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> T <span class="keyword">ADD</span> INDEX(k);</span><br><span class="line"></span><br><span class="line"># 重建聚簇索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> T <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> T <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(id);</span><br></pre></td></tr></table></figure>

<ol>
<li>重建索引的原因<ul>
<li>索引可能因为<strong>删除和页分裂</strong>等原因，导致<strong>数据页有空洞</strong></li>
<li>重建索引的过程会<strong>创建一个新的索引</strong>，<strong>把数据按顺序插入</strong></li>
<li>这样<strong>页面的利用率最高</strong>，使得索引更紧凑，更省空间</li>
</ul>
</li>
<li>重建二级索引k是合理的，可以达到省空间的目的</li>
<li>重建聚簇索引是不合理的<ul>
<li>不论是<strong>删除聚簇索引</strong>还是<strong>创建聚簇索引</strong>，都会<strong>将整个表重建</strong></li>
<li>替代语句：<code>ALTER TABLE T ENGINE=INNODB</code></li>
</ul>
</li>
</ol>
<h3 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a><strong>自增主键</strong></h3><ol>
<li>逻辑：如果主键为自增，并且在插入新纪录时不指定主键的值，系统会获取当前主键的最大值+1作为新纪录的主键<ul>
<li>适用于<strong>递增插入</strong>的场景，每次插入一条新纪录都是<strong>追加操作</strong>，既不会涉及其他记录的挪动操作，也不会触发页分裂</li>
</ul>
</li>
<li>如果采用<strong>业务字段</strong>作为主键，<strong>很难保证有序插入</strong>，写数据的成本相对较高</li>
<li>主键长度越小，二级索引占用的空间也就越小<ul>
<li>在一般情况下，创建一个自增主键，这样二级索引占用的空间最小</li>
</ul>
</li>
<li>针对实际中一般采用分布式ID生成器的情况<ul>
<li>满足<strong>有序插入</strong></li>
<li>分布式ID<strong>全局唯一</strong></li>
</ul>
</li>
<li>适合直接采用业务字段做主键的场景：KV场景（只有一个唯一索引）<ul>
<li>无须考虑<strong>二级索引的占用空间问题</strong></li>
<li>无须考虑<strong>二级索引的回表问题</strong></li>
</ul>
</li>
</ol>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 建表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> T (</span><br><span class="line">    ID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    k <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    s <span class="type">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    INDEX k(k)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB;</span><br><span class="line"></span><br><span class="line"># 初始化数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> T <span class="keyword">VALUES</span> (<span class="number">100</span>,<span class="number">1</span>,<span class="string">&#x27;aa&#x27;</span>),(<span class="number">200</span>,<span class="number">2</span>,<span class="string">&#x27;bb&#x27;</span>),(<span class="number">300</span>,<span class="number">3</span>,<span class="string">&#x27;cc&#x27;</span>),(<span class="number">500</span>,<span class="number">5</span>,<span class="string">&#x27;ee&#x27;</span>),(<span class="number">600</span>,<span class="number">6</span>,<span class="string">&#x27;ff&#x27;</span>),(<span class="number">700</span>,<span class="number">7</span>,<span class="string">&#x27;gg&#x27;</span>);</span><br></pre></td></tr></table></figure>

<img src="/images/mysql-index/mysql-index-scan-row.png" alt="img" style="zoom:45%;" />

<h4 id="需要回表的查询"><a href="#需要回表的查询" class="headerlink" title="需要回表的查询"></a>需要回表的查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> k <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">AND</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<ol>
<li>在k树上找到k=3的记录，取得ID=300</li>
<li>再到ID树上查找ID=300的记录，对应为R3</li>
<li>在k树上取<strong>下一个</strong>值k=5，取得ID=500</li>
<li>再到ID树上查找ID=500的记录，对应为R4</li>
<li>在k树上取<strong>下一个</strong>值k=6，不满足条件，循环结束</li>
</ol>
<p>整个查询过程读了k树3条记录，回表了2次</p>
<h4 id="不需要回表的查询"><a href="#不需要回表的查询" class="headerlink" title="不需要回表的查询"></a>不需要回表的查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ID <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> k <span class="keyword">BETWEEN</span> <span class="number">3</span> <span class="keyword">AND</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<ol>
<li>只需要查ID的值，而ID的值已经在k树上，可以直接提供查询结果，不需要回表<ul>
<li>因为k树已经覆盖了我们的查询需求，因此称为<strong>覆盖索引</strong></li>
</ul>
</li>
<li>覆盖索引可以<strong>减少树的搜索次数</strong>，显著<strong>提升查询性能</strong>，因此使用覆盖索引是一个常用的性能优化手段</li>
<li>扫描行数<ul>
<li>在存储引擎内部使用覆盖索引在索引k上其实是读取了3个记录，</li>
<li>但对于MySQL的<strong>Server层</strong>来说，存储引擎返回的只有2条记录，因此MySQL认为扫描行数为2</li>
</ul>
</li>
</ol>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tuser` (</span><br><span class="line">    `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `id_card` <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `name` <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `age` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `ismale` TINYINT(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `id_card` (`id_card`),</span><br><span class="line">    KEY `name_age` (`name`,`age`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB</span><br></pre></td></tr></table></figure>

<p>高频请求：根据id_card查询name。可以建立联合索引<code>(id_card,name)</code>，达到<strong>覆盖索引</strong>的效果</p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>B+树的索引结构，可以利用索引的<strong>最左前缀</strong>来定位记录</p>
<img src="/images/mysql-index/mysql-index-leftmost-prefix.jpg" alt="img" style="zoom:45%;" />

<ol>
<li>索引项是按照索引定义里字段出现的顺序来排序的<ul>
<li>如果查找所有名字为<strong>张三</strong>的人时，可以快速定位到ID4，然后<strong>向后遍历</strong>，直到不满足条件为止</li>
<li>如果查找所有名字的第一个字是<strong>张</strong>的人，找到第一个符合条件的记录ID3，然后<strong>向后遍历</strong>，直到不满足条件为止</li>
</ul>
</li>
<li>只要满足最左前缀，就可以利用索引来加速检索，最左前缀有2种情况<ul>
<li><strong>联合索引的最左N个字段</strong></li>
<li><strong>字符串索引的最左M个字符</strong></li>
</ul>
</li>
<li>建立联合索引时，定义索引内字段顺序的原则<ul>
<li><strong>复用</strong>：如果通过调整顺序，可以<strong>少维护一个索引</strong>，往往优先考虑这样的顺序</li>
<li><strong>空间</strong>：维护<code>(name,age)</code>+<code>age</code>比维护<code>(age,name)</code>+<code>name</code>所占用的空间更少</li>
</ul>
</li>
</ol>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tuser <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;张%&#x27;</span> <span class="keyword">AND</span> age<span class="operator">=</span><span class="number">10</span> <span class="keyword">AND</span> ismale<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>依据<strong>最左前缀</strong>原则，上面的查询语句只能用<strong>张</strong>，找到第一个满足条件的记录ID3（优于全表扫描）</li>
<li>然后判断其他条件是否满足<ul>
<li>在MySQL 5.6之前，只能从ID3开始一个个回表，到聚簇索引上找出对应的数据行，再对比字段值<ul>
<li>这里暂时忽略<strong>MRR</strong>：在不影响排序结果的情况下，在取出主键后，回表之前，会对所有获取到的主键进行排序</li>
</ul>
</li>
<li>在MySQL 5.6引入了下推优化（index condition pushdown）<ul>
<li>可以在<strong>索引遍历</strong>过程中，<strong>对索引所包含的字段先做判断</strong>，<strong>直接过滤掉不满足条件的记录</strong>，<strong>减少回表次数</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>无索引下推，回表4次</p>
<img src="/images/mysql-index/mysql-index-pushdown.jpg" alt="img" style="zoom:45%;" />

<p>采用索引下推，回表2次</p>
<img src="/images/mysql-index/mysql-index-no-pushdown.jpg" alt="img" style="zoom:45%;" />

<h3 id="删除冗余索引"><a href="#删除冗余索引" class="headerlink" title="删除冗余索引"></a>删除冗余索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `geek` (</span><br><span class="line">    `a` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `b` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `c` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `d` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`a`,`b`),</span><br><span class="line">    KEY `c` (`c`),</span><br><span class="line">    KEY `ca` (`c`,`a`),</span><br><span class="line">    KEY `cb` (`c`,`b`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"># 索引(`a`,`b`)是业务属性</span><br><span class="line"># 常规查询，应该如何优化索引？</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> geek <span class="keyword">where</span> c<span class="operator">=</span>N <span class="keyword">order</span> <span class="keyword">by</span> a limit <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> geek <span class="keyword">where</span> c<span class="operator">=</span>N <span class="keyword">order</span> <span class="keyword">by</span> b limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>索引<code>ca</code>是不需要的，因为满足<strong>最左前缀</strong>原则，<code>ca(b) = c(ab)</code></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《MySQL实战45讲》<br><a target="_blank" rel="noopener" href="http://zhongmingmao.me/2019/01/21/mysql-index/">http://zhongmingmao.me/2019/01/21/mysql-index/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/01/09/mysql-transaction-isolation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="tlv">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温故而知新">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/09/mysql-transaction-isolation/" class="post-title-link" itemprop="url">MySQL -- 事务隔离</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-10 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-10T00:00:00+08:00">2020-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-11 21:27:38" itemprop="dateModified" datetime="2022-05-11T21:27:38+08:00">2022-05-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Storage/" itemprop="url" rel="index"><span itemprop="name">Storage</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Storage/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>7.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h2><ul>
<li>事务就是要保证一组数据库操作，要么全部成功，要么全部失败</li>
<li>MySQL 中，事务支持是在引擎层实现的<ul>
<li>MyISAM不支持事务</li>
<li>InnoDB支持事务</li>
</ul>
</li>
</ul>
<h2 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h2><ul>
<li>事务特性：<strong>ACID</strong>（Atomicity、Consistency、Isolation、Durability）<ul>
<li>Atomicity（原子性）：事务的所有操作，要么全部完成，要么全部不完成，不会结束在某个中间环节<ul>
<li>事务commit，MySQL crash或者系统宕机，可以通过redolog崩溃恢复</li>
<li>事务rollback，通过undolog进行数据恢复</li>
</ul>
</li>
<li>Consistency（一致性）：事务开始之前和事务结束之后，数据库的完整性限制未被破坏<ul>
<li>事务的一致性就是在事务定义层级（数据库、应用层、甚至多个应用）里，用AID特性和回滚手段满足了该层级的约束，即可满足该层级的C</li>
</ul>
</li>
<li>Isolation（隔离性）：每个读写事务的对象对其他事务的操作对象能相互隔离，即该事务提交前对其他事务都不可见<ul>
<li>通过MVCC、锁实现</li>
</ul>
</li>
<li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失<ul>
<li>通过redolog实现</li>
</ul>
</li>
</ul>
</li>
<li>数据库上有多个事务同时执行的时候，就可能出现<strong>脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）</strong>的问题<ul>
<li>解决方案：<strong>隔离级别</strong></li>
<li>隔离级别越高，效率就会越低</li>
<li>脏读：读到其他事务未提交的数据</li>
<li>不可重复读：前后读取的记录内容不一致 </li>
<li>幻读：前后读取的记录数量不一致</li>
</ul>
</li>
<li>SQL的标准隔离级别：<ul>
<li><strong>READ-UNCOMMITTED（读未提交）</strong><ul>
<li>一个事务还未提交时，它所做的变更能被别的事务看到</li>
</ul>
</li>
<li><strong>READ-COMMITTED（读已提交）</strong><ul>
<li>一个事务提交之后，它所做的变更才会被其他事务看到</li>
</ul>
</li>
<li><strong>REPEATABLE-READ（可重复读）</strong><ul>
<li>一个事务在执行过程中所看到的数据，总是跟这个事务在启动时看到的数据是一致的</li>
<li>同样，在RR隔离级别下，未提交的变更对其他事务也是不可见的</li>
</ul>
</li>
<li><strong>SERIALIZABLE（串行化）</strong><ul>
<li>对同一行记录，写会加写锁，读会加读锁，锁级别是<strong>行锁</strong></li>
<li>当出现读写锁冲突时，后访问的事务必须等前一个事务执行完成，才能继续执行<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%isolation%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span>           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> tx_isolation  <span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-----------------+</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="隔离级别数据形态"><a href="#隔离级别数据形态" class="headerlink" title="隔离级别数据形态"></a>隔离级别数据形态</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> T(c <span class="type">int</span>) engine<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T(c) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<img src="/images/mysql-transaction-isolation/7dea45932a6b722eb069d2264d0066f8.png" alt="img" style="zoom:45%;" />

<table>
<thead>
<tr>
<th align="left">隔离级别</th>
<th align="left">V1</th>
<th align="left">V2</th>
<th align="left">V3</th>
<th align="left">实现方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">READ-UNCOMMITTED</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left"><strong>没有read-view概念</strong>，直接返回<strong>记录上的最新值</strong>（<strong>内存</strong>，InnoDB Buffer Pool）</td>
</tr>
<tr>
<td align="left">READ-COMMITTED</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">2</td>
<td align="left"><strong>每个SQL语句开始执行时</strong>创建<strong>read-view</strong>，根据read-view读取数据</td>
</tr>
<tr>
<td align="left">REPEATABLE-READ</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left"><strong>事务启动时</strong>创建<strong>read-view</strong>，整个事务存在期间都用这个read-view，根据read-view读取数据</td>
</tr>
<tr>
<td align="left">SERIALIZABLE</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">用<strong>加锁</strong>（行锁）的方式来避免并行访问</td>
</tr>
</tbody></table>
<h2 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>InnoDB支持MVCC多版本，其中RC（Read Committed）和RR（Repeatable Read）隔离级别是利用consistent read view（一致读视图）方式支持的。 所谓consistent read view就是在某一时刻给事务系统trx_sys打snapshot（快照），把当时trx_sys状态（包括活跃读写事务数组）记下来，之后的所有读操作根据其事务ID（即trx_id）与snapshot中的trx_sys的状态作比较，以此判断read view对于事务的可见性</p>
<h3 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h3><ul>
<li><strong>m_low_limit_id（低水位）</strong>：活跃事务列表里面<strong>最小的事务ID</strong></li>
<li><strong>m_up_limit_id（高水位）</strong>：当前系统已经创建的事务id的最大值+1（<strong>并不是数组内的最大</strong>）</li>
<li><strong>m_creator_trx_id（视图创建事务ID）</strong>：创建该ReadView的事务，该事务ID的数据修改可见。</li>
<li><strong>m_ids（活跃事务ID）</strong>：当快照创建时的活跃读写事务列表</li>
<li><strong>m_low_limit_no（事务number）</strong>：事务number，事务提交时候获取同时写入Undo log中的值。事务number小于该值的对该ReadView不可见。利用该信息可以Purge不需要的Undo</li>
<li><strong>m_closed</strong>： 标记该ReadView closed，用于优化减少trx_sys-&gt;mutex这把大锁的使用。可以看到在view_close的时候如果是在不持有trx_sys-&gt;mutex锁的情况下，会仅将ReadView标记为closed，并不会把ReadView从m_views的list中移除</li>
</ul>
<img src="/images/mysql-transaction-isolation/882114aaf55861832b4270d44507695e.png" alt="img" style="zoom:45%;" />

<ul>
<li><strong>行隐藏列</strong><ul>
<li>RowID：隐藏的自增ID，当建表没有指定主键，InnoDB会使用该RowID创建一个聚簇索引</li>
<li>DB_TRX_ID：最近修改（更新/删除/插入）该记录的事务ID</li>
<li>DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本</li>
</ul>
</li>
</ul>
<h3 id="可见性判断"><a href="#可见性判断" class="headerlink" title="可见性判断"></a>可见性判断</h3><ul>
<li>如果记录trx_id小于m_up_limit_id或者等于m_creator_trx_id，表明ReadView创建的时候该事务已经提交，记录可见</li>
<li>如果记录的trx_id大于等于m_low_limit_id，表明事务是在ReadView创建后开启的，其修改，插入的记录不可见</li>
<li>当记录的trx_id在m_up_limit_id和m_low_limit_id之间的时候<ul>
<li>如果id在m_ids数组中，表明ReadView创建时候，事务处于活跃状态，因此记录不可见</li>
<li>如果id不在m_ids数组中，表明ReadView创建时候，事务已经提交，因此记录可见</li>
</ul>
</li>
</ul>
<h3 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h3><ul>
<li>在InnoDB，每个事务都有一个唯一的事务ID（transaction id）<ul>
<li>在<strong>事务开始</strong>的时候向InnoDB的<strong>事务系统</strong>申请的，<strong>按申请的顺序严格递增</strong></li>
</ul>
</li>
<li>每行数据都有多个版本，每次事务更新数据的时候，都会生成一个新的数据版本<ul>
<li>事务会把自己的transaction id赋值给这个数据版本的事务ID，记为<code>row trx_id</code><ul>
<li><strong>每个数据版本都有对应的row trx_id</strong></li>
</ul>
</li>
<li>同时也要<strong>逻辑保留</strong>旧的数据版本，通过新的数据版本和<code>undolog</code>可以<strong>计算</strong>出旧的数据版本<img src="/images/mysql-transaction-isolation/mysql-innodb-row-multi-version-20210606133912235.png" alt="img" style="zoom:45%;" /></li>
</ul>
</li>
<li>虚线框是同一行记录的4个版本</li>
<li>当前最新版本为V4，k=22，是被<code>transaction id</code>为25的事务所更新的，因此它的<code>row trx_id</code>为25虚线箭头就是undolog，而V1、V2和V3并不是物理真实存在的<ul>
<li>每次需要的时候根据<strong>当前最新版本</strong>与<code>undolog</code>计算出来的</li>
<li>例如当需要V2时，就通过V4依次执行U3和U2算出来的</li>
</ul>
</li>
</ul>
<h2 id="RR隔离的实现"><a href="#RR隔离的实现" class="headerlink" title="RR隔离的实现"></a>RR隔离的实现</h2><p>每条记录在<strong>更新</strong>的时候都会同时（<strong>在redolog和binlog提交之前</strong>）记录一条<strong>回滚操作</strong>记录上的最新值，通过回滚操作，都可以得到前一个状态的值</p>
<h2 id="事务启动"><a href="#事务启动" class="headerlink" title="事务启动"></a>事务启动</h2><ol>
<li><code>BEGIN/START TRANSACTION</code>：事务<strong>并未立马启动</strong>，在执行到后续的第一个<strong>一致性读</strong>语句，事务才真正开始</li>
<li><code>START TRANSACTION WITH CONSISTENT SNAPSHOT;</code>：事务<strong>立马启动</strong></li>
</ol>
<h2 id="执行分析"><a href="#执行分析" class="headerlink" title="执行分析"></a>执行分析</h2><p><strong>例子中如果没有特别说明，都是默认 autocommit=1</strong></p>
<h3 id="初始化表"><a href="#初始化表" class="headerlink" title="初始化表"></a>初始化表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 建表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">    `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `k` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line"># 表初始化</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t (id, k) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">1</span>), (<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo-1"></a>Demo-1</h3><img src="/images/mysql-transaction-isolation/823acf76e53c0bdba7beab45e72e90d6.png" alt="img" />

<h4 id="事务A查询"><a href="#事务A查询" class="headerlink" title="事务A查询"></a>事务A查询</h4><ul>
<li><p><strong>假设</strong></p>
<ul>
<li>事务A开始前，系统里只有一个活跃事务ID是99</li>
<li>事务ABC的事务ID分别是100，101和102，且当前系统只有这4个事务</li>
<li>事务ABC开始前，<code>(1,1)</code>这一行数据的<code>row trx_id</code>是90</li>
<li>视图数组<ul>
<li>事务A：<code>[99,100]</code></li>
<li>事务B：<code>[99,100,101]</code></li>
<li>事务C：<code>[99,100,101,102]</code></li>
</ul>
</li>
<li>低水位与高水位<ul>
<li>事务A：<code>99</code>和<code>100</code></li>
<li>事务B：<code>99</code>和<code>101</code></li>
<li>事务C：<code>99</code>和<code>102</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>查询逻辑</strong></p>
<img src="/images/mysql-transaction-isolation/86ad7e8abe7bf16505b97718d8ac149f.png" alt="img" style="zoom:50%;" />

<p>第一个有效更新是事务C，采用当前读，读取当前最新版本<code>(1,1)</code>，改成<code>(1,2)</code></p>
<ul>
<li>此时最新版本的<code>row trx_id</code>为102，90那个版本成为历史版本<ul>
<li>由于<strong>autocommit=1</strong>，事务C在执行完更新后会立马<strong>释放</strong>id=1的<strong>行锁</strong></li>
</ul>
</li>
<li>第二个有效更新是事务B，采用当前读，读取当前最新版本<code>(1,2)</code>，改成<code>(1,3)</code><ul>
<li>此时最新版本的<code>row trx_id</code>为101，102那个版本成为历史版本</li>
</ul>
</li>
<li>事务A查询时，由于事务B还未提交，当前最新版本为<code>(1,3)</code>，对事务A是不可见的，否则就了脏读了，读取过程如下<ul>
<li>事务A的视图数组为<code>[99,100]</code>，读数据都是从<strong>当前最新版本</strong>开始读</li>
<li>首先找到当前最新版本<code>(1,3)</code>，判断<code>row trx_id</code>为101，比事务A的视图数组的高水位（100）大，<strong>不可见</strong></li>
<li>接着寻找<strong>上一历史版本</strong>，判断<code>row trx_id</code>为102，同样比事务A的视图数组的高水位（100）大，<strong>不可见</strong></li>
<li>再往前寻找，找到版本<code>(1,1)</code>，判断<code>row trx_id</code>为90，比事务A的视图数组的低水位（99）小，<strong>可见</strong></li>
<li>所以事务A的查询结果为1</li>
</ul>
</li>
<li><strong>一致性读</strong>：事务A不论在什么时候查询，看到的数据都是<strong>一致</strong>的，哪怕同一行数据同时会被其他事务更新</li>
</ul>
</li>
<li><h5 id="时间视角"><a href="#时间视角" class="headerlink" title="时间视角"></a>时间视角</h5><ul>
<li>一个数据版本，对于一个事务视图来说，除了该事务本身的更新总是可见以外，还有下面3种情况<ul>
<li>如果版本对应的事务未提交，不可见</li>
<li>如果版本对应的事务已提交，但是是在视图创建之后提交的，不可见</li>
<li><strong>如果版本对应的事务已提交，并且是在视图创建之前提交的，可见</strong></li>
</ul>
</li>
<li>归纳：<em><strong>一个事务只承认自身更新的数据版本以及视图创建之前已经提交的数据版本</strong></em></li>
<li>应用规则进行分析<ul>
<li>事务A的<strong>一致性读视图</strong>是在事务A启动时生成的，在事务A查询时</li>
<li>此时<code>(1,3)</code>的数据版本尚未提交，不可见</li>
<li>此时<code>(1,2)</code>的数据版本虽然提交了，但是是在事务A的<strong>一致性读视图</strong>创建之后提交的，不可见</li>
<li>此时<code>(1,1)</code>的数据版本是在事务A的<strong>一致性读视图</strong>创建之前提交的，可见</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>更新逻辑</strong></p>
<img src="/images/mysql-transaction-isolation/86ad7e8abe7bf16505b97718d8ac149f.png" alt="img" style="zoom:50%;" />

<ul>
<li><p>可能会产生的疑问：  </p>
<ul>
<li>事务 B 的视图数组是先生成的，之后事务 C 才提交，不是应该看不见 (1,2) 吗，怎么能算出 (1,3) ？</li>
<li>如果事务 B 在更新之前查询一次数据，这个查询返回的 k 的值确实是 1，但是，当它要去更新数据的时候，<strong>不能再在历史版本上更新</strong>，否则事务 C 的更新就丢失了</li>
</ul>
</li>
<li><p>更新数据需要先进行<strong>当前读</strong>（current read），再写入数据</p>
<ul>
<li><em><strong>当前读：总是读取已经提交的最新版本</strong></em></li>
<li><strong>当前读伴随着加锁</strong>（更新操作为<strong>X Lock模式的当前读</strong>）</li>
<li>如果当前事务在执行当前读时，其他事务在这之前已经执行了更新操作，但尚未提交（<strong>持有行锁</strong>），当前事务被阻塞</li>
</ul>
</li>
<li><p>事务B的<code>SET k=k+1</code>操作是在最新版<code>(1,2)</code>上进行的，更新后生成新的数据版本<code>(1,3)</code>，对应的<code>row trx_id</code>为101</p>
</li>
<li><p>事务B在进行后续的查询时，发现最新的数据版本为<code>101</code>，与自己的版本号<strong>一致</strong>，认可该数据版本，查询结果为3</p>
</li>
<li><p>当前读</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查询语句</span><br><span class="line">## 读锁（S锁，共享锁）</span><br><span class="line"><span class="keyword">SELECT</span> k <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line">## 写锁（X锁，排他锁）</span><br><span class="line"><span class="keyword">SELECT</span> k <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"># 更新语句，首先采用（X锁的）当前读</span><br></pre></td></tr></table></figure>
<h3 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo-2"></a>Demo-2</h3><p>假设事务 C 不是马上提交的，而是变成了下面的事务 C’</p>
<img src="/images/mysql-transaction-isolation/cda2a0d7decb61e59dddc83ac51efb6e.png" /></li>
</ul>
</li>
</ul>
<img src="/images/mysql-transaction-isolation/540967ea905e8b63630e496786d84c92.png" alt="img" style="zoom:50%;" />

<ul>
<li>事务C’没有自动提交，依然持有当前最新版本版本<code>(1,2)</code>上的<strong>写锁</strong>（X Lock）</li>
<li>事务B执行更新语句，采用的是<strong>当前读</strong>（X Lock模式），会被阻塞，必须等事务C’释放这把写锁后，才能继续执行</li>
</ul>
<h2 id="RR-amp-RC"><a href="#RR-amp-RC" class="headerlink" title="RR &amp; RC"></a>RR &amp; RC</h2><h3 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h3><ul>
<li>RR的实现核心为<strong>一致性读</strong>（consistent read）</li>
<li>事务更新数据的时候，只能用<strong>当前读</strong>（current read）</li>
<li>如果当前的记录的行锁被其他事务占用的话，就需要进入<strong>锁等待</strong></li>
<li>在RR隔离级别下，只需要在事务<strong>启动</strong>时创建一致性读视图，之后事务里的其他查询都共用这个一致性读视图</li>
<li>对于RR，查询只承认<strong>事务启动前</strong>就已经提交的数据</li>
<li>表结构不支持RR，只支持当前读<ul>
<li>因为表结构没有对应的行数据，也没有row trx_id</li>
</ul>
</li>
</ul>
<h3 id="RC"><a href="#RC" class="headerlink" title="RC"></a>RC</h3><ul>
<li>在RC隔离级别下，每个<strong>语句执行前</strong>都会<strong>重新计算</strong>出一个新的一致性读视图</li>
<li>在RC隔离级别下，再来考虑Demo1，事务A与事务B的查询语句的结果</li>
<li><code>START TRANSACTION WITH CONSISTENT SNAPSHOT</code>的原意：创建一个持续整个事务的一致性视图<ul>
<li>在RC隔离级别下，一致性读视图会被<strong>重新计算</strong>，等同于普通的<code>START TRANSACTION</code></li>
</ul>
</li>
<li>事务A的查询语句的一致性读视图是在执行这个语句时才创建的<ul>
<li>数据版本<code>(1,3)</code>未提交，不可见</li>
<li>数据版本<code>(1,2)</code>提交了，并且在事务A<strong>当前的一致性读视图</strong>创建之前提交的，<strong>可见</strong></li>
<li>因此事务A的查询结果为2</li>
</ul>
</li>
<li>事务B的查询结果为3</li>
<li>对于RC，查询只承认<strong>语句启动前</strong>就已经提交的数据</li>
</ul>
<img src="/images/mysql-transaction-isolation/mysql-innodb-trx-rc-20210606162844432.png" alt="img" style="zoom:50%;" />

<h2 id="多版本"><a href="#多版本" class="headerlink" title="多版本"></a>多版本</h2><p>变更记录：1-&gt;2-&gt;3-&gt;4</p>
<img src="/images/mysql-transaction-isolation/mysql-read-view.png" alt="img" style="zoom:50%;" />

<ol>
<li>当前值为4，但在查询这条记录的时候，<strong>不同时刻启动的事务会有不同的视图</strong></li>
<li>在视图A、B和C，这一个记录的值分别是1、2和4</li>
<li>同一条记录在系统中可以存在多个版本，这就是<strong>MVCC</strong>（<strong>多版本并发控制</strong>）</li>
<li>对于视图A，要得到1，必须<br>将当前值依次执行图中的所有回滚操作<ul>
<li>这会存在一定的<strong>性能开销</strong></li>
<li>这里的视图是<strong>逻辑视图</strong>，<strong>并不是快照</strong></li>
<li>这里的视图是InnoDB（<strong>存储引擎层</strong>）的read-view，也不是Server层都VIEW（虚表）</li>
</ul>
</li>
<li>即使此时有另外一个事务正在将4改成5，这个事务跟视图A、B和C所对应的事务并不冲突</li>
</ol>
<h3 id="删除回滚段"><a href="#删除回滚段" class="headerlink" title="删除回滚段"></a>删除回滚段</h3><ol>
<li><strong>当没有事务需要用到这些回滚段时</strong>，回滚段就会被删除</li>
<li>不被事务所需要的回滚段：<strong>比系统中最早视图还要早的回滚段</strong></li>
</ol>
<h3 id="长事务"><a href="#长事务" class="headerlink" title="长事务"></a>长事务</h3><ol>
<li>长事务意味着系统里面存在<strong>很老的事务视图</strong></li>
<li>长事务随时可能访问数据库里面的任何数据，在这个事务提交之前，它<br>可能用到的回滚段都必须保留<ul>
<li>因此这会导致<strong>占用大量的存储空间</strong></li>
<li>&lt;= MySQL5.5，回滚段跟数据字典一起放在<strong>ibdata</strong>文件里，即使长事务最终提交，回滚段被清理，<strong>文件也不会变小</strong></li>
</ul>
</li>
<li>RC隔离级别一般不会导致回滚段过长的问题</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询持续时间超过<span class="number">60</span>s的事务</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(timediff(now(),trx_started))<span class="operator">&gt;</span><span class="number">60</span>;</span><br></pre></td></tr></table></figure>

<h2 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h2><ol>
<li>启动方式<ul>
<li>显式启动事务，<strong>begin(start transaction) + commit/rollback</strong></li>
<li>set autocommit=0 + commit/rollback<ul>
<li>set autocommit=0：关闭自动提交</li>
<li>一些客户端框架会在默认连接成功后执行set autocommit=0，导致<strong>接下来的查询都在事务中</strong></li>
<li>如果是<strong>长连接</strong>，就会导致<strong>意外的长事务</strong></li>
</ul>
</li>
</ul>
</li>
<li>推荐方式<ul>
<li><em><strong>set autocommit=1 + begin(start transaction) + commit/rollback</strong></em></li>
<li>set autocommit=1 + begin(start transaction) + (commit and chain)/(rollback and chain)<ul>
<li>适用于频繁使用事务的业务</li>
<li>省去再次执行begin语句的开销</li>
<li>从程序开发的角度能够明确地知道每个语句是否处于事务中</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="避免长事务的方案"><a href="#避免长事务的方案" class="headerlink" title="避免长事务的方案"></a>避免长事务的方案</h2><h3 id="应用开发端"><a href="#应用开发端" class="headerlink" title="应用开发端"></a>应用开发端</h3><ol>
<li>确保<strong>set autocommit=1</strong>，可以通过<strong>general_log</strong>来确认</li>
<li>确认程序中是否有<strong>不必要的只读事务</strong></li>
<li>业务连接数据库的时候，预估<strong>每个语句执行的最长时间</strong>（<strong>max_execution_time</strong>）</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%general_log%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span>                                         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> general_log      <span class="operator">|</span> OFF                                           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> general_log_file <span class="operator">|</span> <span class="operator">/</span>data_db3<span class="operator">/</span>mysql<span class="operator">/</span><span class="number">3323</span><span class="operator">/</span>data<span class="operator">/</span>ym_DB_12_100071.log <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+-----------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Introduced <span class="number">5.7</span><span class="number">.8</span></span><br><span class="line"># <span class="number">0</span> <span class="operator">-</span><span class="operator">&gt;</span> disable</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%max_execution_time%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name      <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> max_execution_time <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+-------+</span></span><br></pre></td></tr></table></figure>

<h3 id="数据库端"><a href="#数据库端" class="headerlink" title="数据库端"></a>数据库端</h3><ol>
<li>监控<strong>information_schema.innodb_trx</strong>，设置长事务阈值，告警或者Kill（工具：pt-kill）</li>
<li>在业务功能的测试阶段要求输出所有的general_log，分析日志行为并提前发现问题</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《MySQL实战45讲》</p>
<p><a target="_blank" rel="noopener" href="http://zhongmingmao.me/2019/01/16/mysql-transaction-isolation/">http://zhongmingmao.me/2019/01/16/mysql-transaction-isolation/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/01/04/mysql-redo-binlog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="tlv">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温故而知新">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/04/mysql-redo-binlog/" class="post-title-link" itemprop="url">MySQL -- redolog & binlog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-05 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-05T00:00:00+08:00">2020-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-11 21:27:38" itemprop="dateModified" datetime="2022-05-11T21:27:38+08:00">2022-05-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Storage/" itemprop="url" rel="index"><span itemprop="name">Storage</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Storage/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>5.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T(ID <span class="type">int</span> <span class="keyword">primary</span> key, c <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> c<span class="operator">=</span>c<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><img src="/images/mysql-redo-binlog/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img" style="zoom:30%;" />

<ol>
<li>通过连接器，客户端与MySQL建立连接</li>
<li>update语句会把<strong>T表上的所有查询缓存清空</strong></li>
<li>分析器会通过词法分析和语法分析识别这是一条更新语句</li>
<li>优化器会决定使用id这个索引（聚簇索引）</li>
<li>执行器负责具体执行，找到匹配的一行，然后更新</li>
<li>更新过程中还会涉及<strong>redolog</strong>（重做日志）和<strong>binlog</strong>（归档日志）的操作</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><ul>
<li><p>如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程<strong>IO</strong> 成本、查找成本都很高</p>
<ul>
<li><strong>IO成本</strong>就是寻址时间和上下文切换所需要的时间，最主要是用户态和内核态的上下文切换。用户态是无法直接访问磁盘等硬件上的数据的，只能通过操作系统去调内核态的接口，用内核态的线程去访问。 这里的上下文切换指的是同进程的线程上下文切换，所谓上下文就是线程运行需要的环境信息。 首先，用户态线程需要将一些中间计算结果保存CPU寄存器，保存CPU指令的地址到程序计数器（执行顺序保证），还要保存栈的信息等一些线程私有的信息。 然后切换到内核态的线程执行，就需要把线程的私有信息从寄存器，程序计数器里读出来，然后执行读磁盘上的数据。读完后返回，又要把线程的信息写进寄存器和程序计数器。 切换到用户态后，用户态线程又要读之前保存的线程执行的环境信息出来，恢复执行。这个过程主要是消耗时间资源。</li>
</ul>
</li>
<li><p>为了解决这个问题，MySQL 使用的是 WAL 技术( Write-Ahead Logging)：<strong>先写日志，再写磁盘</strong></p>
</li>
<li><p>当有一条记录需要更新的时候，InnoDB会把记录先写入redolog（redolog buffer），并<strong>更新内存</strong>（buffer pool）</p>
<ul>
<li>InnoDB会在适当 redolog – InnoDB的时候（例如系统空闲），将这个操作记录到磁盘里面（<strong>刷脏页</strong>）</li>
</ul>
</li>
<li><p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB</p>
<img src="/images/mysql-redo-binlog/16a7950217b3f0f4ed02db5db59562a7.png" alt="img" style="zoom:40%;" />

<ul>
<li>redo log的总大小为4G，<strong>循环写</strong></li>
<li>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头<ul>
<li>redolog是<strong>顺序写</strong>，数据文件是<strong>随机写</strong></li>
</ul>
</li>
<li>checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件</li>
<li>write pos 和 checkpoint 之间空闲部分，可以用来记录新的操作<ul>
<li>write pos 追上 checkpoint，磁盘写满，不能再执行新的更新，需要擦掉一些记录，把 checkpoint 推进一下</li>
<li>write pos 未追上 checkpoint，可以执行新的更新</li>
<li>果checkpoint赶上了write pos，说明redolog已<strong>空</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe</p>
</li>
<li><p>如果redolog太小，会导致很快被写满，然后就不得不强行刷redolog，导致频繁刷盘，这样WAL机制的能力就无法发挥出来</p>
<ul>
<li>如果磁盘能达到几TB，那么可以将redolog设置4个一组，每个日志文件大小为1GB</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># innodb_log_file_size -&gt; 单个redolog文件的大小</span><br><span class="line"># innodb_log_files_in_group -&gt; redolog文件个数</span><br><span class="line"># 50331648 Byte = 48 MB</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;%innodb_log_file%&#x27;;</span><br><span class="line">+---------------------------+----------+</span><br><span class="line">| Variable_name             | Value    |</span><br><span class="line">+---------------------------+----------+</span><br><span class="line">| innodb_log_file_size      | 50331648 |</span><br><span class="line">| innodb_log_files_in_group | 2        |</span><br><span class="line">+---------------------------+----------+</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;%innodb_flush_log_at_trx_commit%&#x27;;</span><br><span class="line">+--------------------------------+-------+</span><br><span class="line">| Variable_name                  | Value |</span><br><span class="line">+--------------------------------+-------+</span><br><span class="line">| innodb_flush_log_at_trx_commit | 1     |</span><br><span class="line">+--------------------------------+-------+</span><br></pre></td></tr></table></figure>

<p><strong>官网文档解释</strong>：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit">innodb_flush_log_at_trx_commit</a></p>
<p><code>innodb_flush_log_at_trx_commit</code> 作用于事务提交时：</p>
<ul>
<li>1: 每次事务提交都要做一次fsync，这是最安全的配置，即使宕机也不会丢失事务；</li>
<li>2: 则在事务提交时只做write操作，只保证写到系统的page cache，因此实例crash不会丢失事务，但宕机则可能丢失事务；</li>
<li>0: 事务提交不会触发redo写操作，而是留给后台线程每秒一次的刷盘操作，因此实例crash将最多丢失1秒钟内的事务。</li>
</ul>
<img src="/images/mysql-redo-binlog/5.png" alt="redo持久化程度" style="zoom:80%;" />

<h3 id="binlog-Server"><a href="#binlog-Server" class="headerlink" title="binlog - Server"></a>binlog - Server</h3><ul>
<li>redo log属于InnoDB引擎特有的日志，Server层也有自己的日志，称为 <strong>binlog</strong>（归档日志）</li>
<li><strong>为什么会有两份日志呢？</strong><ul>
<li>一开始并没有InnoDB，采用的是MyISAM，但<strong>MyISAM没有crash-safe的能力</strong>，<strong>binlog日志只能用于归档</strong></li>
<li>InnoDB是以插件的形式引入MySQL的，<strong>为了实现crash-safe</strong>，InnoDB采用了<strong>redolog</strong>的方案</li>
</ul>
</li>
<li>binlog一开始的设计就是<strong>不支持崩溃恢复</strong>（原库）的，如果不考虑搭建从库等操作，<strong>binlog是可以关闭的</strong>（sql_log_bin）</li>
<li>redolog vs binlog<ul>
<li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用</li>
<li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”<ul>
<li>逻辑日志：<strong>提供给别的引擎用</strong>，是大家都能理解的逻辑，例如<strong>搭建从库</strong></li>
<li>物理日志：<strong>只能内部使用</strong>，其他引擎无法共享内部的物理格式</li>
</ul>
</li>
<li>redo log 是<strong>循环写</strong>，<strong>空间固定</strong>，<strong>不能持久保存</strong>，没有<strong>归档</strong>功能； binlog是<strong>追加写</strong>，<strong>空间不受限制</strong>，有<strong>归档</strong>功能</li>
<li>MySQL **InnoDB事务的持久性(Durability)**是通过redolog实现</li>
<li>binlog有两种模式：<ul>
<li><strong>statement格式</strong>：SQL语句</li>
<li><strong>row格式</strong>：行内容（记两条，更新前和更新后），<strong>推荐</strong><ul>
<li>日志一样的可以用于<strong>重放</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;%sql_log_bin%&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| sql_log_bin   | ON    |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="update-内部流程"><a href="#update-内部流程" class="headerlink" title="update 内部流程"></a>update 内部流程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T(ID <span class="type">int</span> <span class="keyword">primary</span> key, c <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> T <span class="keyword">set</span> c<span class="operator">=</span>c<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<img src="/images/mysql-redo-binlog/mysql-innodb-update-procedure-1.jpg" alt="img" style="zoom:45%;" />

<p>注：深绿色是在Server层执行，浅绿色是在InnoDB引擎中执行。</p>
<ol>
<li>执行器先通过InnoDB获取id=2这一行，id是主键，InnoDB可以通过聚簇索引找到这一行<ul>
<li>如果<strong>id=2这一行所在的数据页</strong>本来就在内存（<strong>InnoDB Buffer Pool</strong>）中，直接返回给执行器</li>
<li>否则先从磁盘读入内存，然后再返回</li>
</ul>
</li>
<li>执行器拿到InnoDB返回的行数据，进行**+1**操作，得到新的一行数据，再调用InnoDB的引擎接口写入这行数据</li>
<li>InnoDB首先将这行新数据更新到内存（InnoDB Buffer Pool）中，同时将这个更新操作记录到redolog（物理记录）<ul>
<li>更新到内存中，在事务提交后，后续的查询就可以直接在内存中读取该数据页，但此时的数据可能还没有真正落盘<ul>
<li>但在<strong>事务提交前，其他事务是无法看到这个内存修改的</strong></li>
<li>而在<strong>事务提交后，说明已经成功写入了redolog，可崩溃恢复，不会丢数据，因此可以直接读内存的数据</strong></li>
</ul>
</li>
<li>刚更新的内存是不会删除的，除非内存不够用，在数据从内存删除之前，系统会保证它们已经落盘</li>
<li>此时redolog处于prepare状态（prepare标签），然后告诉执行器执行完成，随时可以提交事务<ul>
<li>对其他事务来说，刚刚修改的内存是<strong>不可见</strong>的</li>
</ul>
</li>
</ul>
</li>
<li>执行器生成这个操作的binlog（逻辑记录）并写入磁盘<ul>
<li>binlog写成功事务就算成功，可以提交事务<ul>
<li>哪怕崩溃恢复，也会恢复binlog写成功的事务（此时对应的redolog处于prepare状态）</li>
</ul>
</li>
<li>binlog如果没写成功就回滚，回滚会写redolog，打上rollback标签，binlog则会直接丢弃<ul>
<li>如果binlog不丢弃，则会传播到从库</li>
</ul>
</li>
</ul>
</li>
<li>执行器调用InnoDB的提交事务接口，InnoDB把刚刚写入的redolog改成commit状态，更新完成<ul>
<li>redolog打上了<strong>commit标签</strong></li>
<li>commit表示两个日志都生效了</li>
<li>commit完成后才会返回客户端</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.6/en/replication-options-binary-log.html#sysvar_sync_binlog">sync_binlog</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;%sync_binlog%&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| sync_binlog   | 1     |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p><strong>sync_binlog参数：</strong></p>
<ul>
<li>0：每次事务提交后，将Binlog Cache中的数据写入到Binlog文件，但不立即刷新到磁盘。由文件系统(file system)决定何时刷新到磁盘中</li>
<li>1：每次事务提交后，将Binlog Cache中的数据写入到Binlog文件,调用fdatasync()函数将数据刷新到磁盘中</li>
<li>N:  每N次事务提交后，将Binlog Cache中的数据写入到Binlog文件,调用fdatasync()函数将数据刷新到磁盘中</li>
</ul>
<h3 id="sync-binlog-amp-innodb-flush-log-at-trx-commit-最佳实践"><a href="#sync-binlog-amp-innodb-flush-log-at-trx-commit-最佳实践" class="headerlink" title="sync_binlog &amp; innodb_flush_log_at_trx_commit 最佳实践"></a>sync_binlog &amp; innodb_flush_log_at_trx_commit 最佳实践</h3><table>
<thead>
<tr>
<th>innodb_flush_log_at_trx_commit</th>
<th>sync_binlog</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>适合数据安全性要求非常高，而且磁盘写入能力足够支持业务。</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>适合数据安全性要求高，磁盘写入能力支持业务不足，允许备库落后或无复制。</td>
</tr>
<tr>
<td>2</td>
<td>0/N(0&lt;N&lt;100)</td>
<td>适合数据安全性要求低，允许丢失一点事务日志，允许复制延迟。</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>磁盘写能力有限，无复制或允许复制延迟较长。</td>
</tr>
</tbody></table>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><ol>
<li>目的：为了让两份日志之间的逻辑一致</li>
<li>如果不使用两阶段提交：<ul>
<li>先写 redo log 后写 binlog<ul>
<li>产生问题：假设 redo log 写成功（落盘成功），binlog 还没有写完（暂未落盘成功），MySQL 进程异常重启，<br>MySQL重启恢复可以使用redo log将数据恢复，如果使用binlog恢复临时库，因为binlog缺失数据，会导致数据与原库不一致</li>
</ul>
</li>
<li>先写 binlog 后写 redo log<ul>
<li>产生问题：假设 binlog 写成功（落盘成功），redo log 还没有写完（暂未落盘成功），MySQL 进程异常重启，MySQL重启恢复无法使用redo log将数据恢复，但是因为binlog记录了最新的更新操作，使用binlog恢复数据的时候会导致数据与原库不一致</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="binlog、redolog功能区别"><a href="#binlog、redolog功能区别" class="headerlink" title="binlog、redolog功能区别"></a>binlog、redolog功能区别</h3><ul>
<li>redolog<ul>
<li>保证crash-safe，事务的持久性</li>
<li><strong>物理格式的日志</strong>，记录的是物理数据页面的修改的信息</li>
<li>将随机写变成顺序写，提高MySQL吞吐</li>
</ul>
</li>
<li>binlog：<ul>
<li><strong>逻辑日志</strong>，没有记录数据页的更新细节，<em><strong>没有能力恢复数据页</strong></em></li>
<li><strong>归档</strong>功能，redolog是循环写，起不到归档的作用</li>
<li><em><strong>binlog复制：MySQL高可用的基础</strong></em><ul>
<li><strong>主从复制</strong></li>
<li>异构系统（如数据分析系统）会<strong>消费MySQL的binlog</strong>来更新自己的数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><ul>
<li>判断规则<ol>
<li>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交；</li>
<li>如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整：<br>a. 如果是，则提交事务<br>b. 否则，回滚事务<br>注：时刻 B 发生 crash 对应的就是 2(a) 的情况，崩溃恢复过程中事务会被提交</li>
</ol>
</li>
<li>redo log 和 binlog 关联<ul>
<li>通过共同数据字段， XID（<strong>为每个事务分配一个唯一的ID</strong>）</li>
<li>崩溃恢复的时候，会按顺序扫描 redo log<ul>
<li>如果碰到既有 prepare、又有 commit 的 redo log，就直接提交</li>
<li>如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务</li>
</ul>
</li>
</ul>
</li>
<li>binlog 完整性判断<ul>
<li>statement 格式的 binlog，最后会有 COMMIT</li>
<li>row 格式的 binlog，最后会有一个 XID event </li>
<li>在 MySQL 5.6.2 版本以后，引入了 binlog-checksum 参数，用来验证 binlog 内容的正确性<ul>
<li>binlog可能由于<strong>磁盘原因</strong>，在<strong>日志中间</strong>出错，MySQL可以通过校验checksum来发现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="异常点说明"><a href="#异常点说明" class="headerlink" title="异常点说明"></a>异常点说明</h3><ul>
<li>时刻A<ul>
<li>属于判断规则 2(b) 情况</li>
<li><strong>redolog处于prepare阶段</strong>，<strong>binlog未写成功</strong>，在崩溃恢复时，事务<strong>回滚</strong></li>
<li>由于binlog未写成功，所以无法传播给从库或异架数据库</li>
</ul>
</li>
<li>时刻B<ul>
<li>属于判断规则 2(a) 情况，事务提交</li>
<li><strong>redolog处于prepare阶段</strong>，<strong>binlog写成功</strong>，在崩溃恢复时，事务<strong>提交</strong></li>
<li>由于binlog写成功，所以可以传播给从库或异架数据库，数据保持一致<br>思考：为何MySQL这么设计？<ul>
<li>binlog 写完以后 MySQL 发生崩溃，这时候 binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。所以，在主库上也要提交这个事务。采用这个策略，主库和备库的数据就保证了一致性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《MySQL实战45讲》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/01/04/consensus-algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="tlv">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温故而知新">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/04/consensus-algorithm/" class="post-title-link" itemprop="url">分布式一致性算法介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-05 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-05T00:00:00+08:00">2020-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-11 21:27:38" itemprop="dateModified" datetime="2022-05-11T21:27:38+08:00">2022-05-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Distributed/" itemprop="url" rel="index"><span itemprop="name">Distributed</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Distributed/Zookeeper/" itemprop="url" rel="index"><span itemprop="name">Zookeeper</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Distributed/Zookeeper/paxos/" itemprop="url" rel="index"><span itemprop="name">paxos</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Distributed/Zookeeper/paxos/ZAB/" itemprop="url" rel="index"><span itemprop="name">ZAB</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Distributed/Zookeeper/paxos/ZAB/Raft/" itemprop="url" rel="index"><span itemprop="name">Raft</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>7.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="分布式共识算法"><a href="#分布式共识算法" class="headerlink" title="分布式共识算法"></a>分布式共识算法</h2><h3 id="分布式共识（Consensus）"><a href="#分布式共识（Consensus）" class="headerlink" title="分布式共识（Consensus）"></a>分布式共识（Consensus）</h3><p>多个参与者针对某一件事达成完全一致：一件事，一个结论。已达成一致的结论，不可推翻。</p>
<p>为了达成一致，每个进程都提出自己的提议（propose），最终通过分布式一致性算法，所有正确运行的进程决定（decide）相同的值。</p>
<p>如果在一个不出现故障的系统中，很容易解决分布式一致性问题。但是实际分布式系统一般是基于消息传递的异步分布式系统，进程可能会慢、被杀死或者重启，消息可能会延迟、丢失、重复、乱序等。</p>
<p>在一个可能发生上述异常的分布式系统中如何就某个值达成一致，形成一致的决议，保证不论发生以上任何异常，都不会破坏决议的一致性，这些正是一致性算法要解决的问题。</p>
<h3 id="FLP-Impossibility-理论"><a href="#FLP-Impossibility-理论" class="headerlink" title="FLP Impossibility 理论"></a>FLP Impossibility 理论</h3><p>FLP定理是分布式理论中最重要的理论之一，它指出<strong>在最小化异步网络通信场景下，即使只有一个节点失败，也没有一种确定性的共识算法能够使得在其他节点之间保持数据一致。</strong>不可能定理是基于异步系统模型而做的证明，这是一个非常受限的模型，它假定共识算法不能使用任何时钟或超时机制来检测崩溃节点，并且消息仅会被传送一次。</p>
<p>一个<strong>正确</strong>的分布式算法需要满足两条性质：</p>
<ul>
<li>Safety：具备Safety性质的算法保证坏的事情绝对不会发生，例如对于满足Safety性质的分布式选主(Leader election)算法，绝对不会出现一个以上进程被选为Leader的情况。</li>
<li>Liveness：具备Liveness性质的算法保证好的事情终将发生，即算法在有限的时间内可以结束</li>
</ul>
<p>综上，一个<strong>正确</strong>的分布式算法可以在<strong>指定的分布式系统模型</strong>中保证<strong>Safety</strong>和<strong>Liveness</strong>属性</p>
<p>而FLP不可能原理则是在说，异步网络中liveness和safety是一对冤家. total correct意味着要同时满足safety和liveness，但只要有一个faulty process这就是不可能的</p>
<p>分布式系统的共识有以下三个标准，并且缺一不可：</p>
<ul>
<li>Termination（终止性）非失败进程最终需要决定一个值</li>
<li>Agreement（一致性）所有的进程必须决定的值必须是同一个值</li>
<li>Validity（有效性）这个被决定的值必须是被某些进程提出的</li>
</ul>
<p>我们所知的一致性算法如 Paxos 或 Raft 都不是真正意义上的一致性算法，因为它们无法同时满足上面的三个条件</p>
<h3 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h3><p>CAP理论是分布式系统（特别是分布式存储领域中被讨论的最多的理论）</p>
<ul>
<li>C代表一致性 (Consistency)<ul>
<li>一个写操作返回成功，那么之后的读请求都必须读到这个新数据；</li>
<li>如果返回失败，那么所有读操作都不能读到这个数据。所有节点访问同一份最新的数据</li>
</ul>
</li>
<li>A代表可用性 (Availability)<ul>
<li>对数据更新具备高可用性，请求能够及时处理，不会一直等待，即使出现节点失效</li>
</ul>
</li>
<li>P代表分区容错性 (Partition tolerance)<ul>
<li>能容忍网络分区，在网络断开的情况下，被分隔的节点仍能正常对外提供服务</li>
</ul>
</li>
</ul>
<p>CAP理论告诉我们C、A、P三者不能同时满足，最多只能满足其中两个</p>
<p><img src="/images/consensus-algorithm/OIP-C.vQ1Wb2s91lSwkgNfTBfeFgHaGa" alt="See the source image"></p>
<p>理解CAP理论最简单的方式是想象两个副本处于分区两侧，即两个副本之间的网络断开，不能通信</p>
<ul>
<li>如果允许其中一个副本更新，则会导致数据不一致，即丧失了C性质。</li>
<li>如果为了保证一致性，将分区某一侧的副本设置为不可用，那么又丧失了A性质。</li>
<li>除非两个副本可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。</li>
</ul>
<p>一般来说使用网络通信的分布式系统，无法舍弃P性质，那么就只能在一致性和可用性上做一个艰难的选择，Paxos、Raft等分布式一致性算法就是在一致性和可用性之间做到了很好的平衡的见证</p>
<h3 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h3><p>BASE 理论是 eBay 架构师对大规模互联网分布式系统实践的总结，并在 ACM 上发表了 <strong><a target="_blank" rel="noopener" href="https://queue.acm.org/detail.cfm?id=1394128">Base: An Acid Alternative</a></strong> 一文，其核心思想是<strong>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性</strong>。</p>
<p>BASE 是对 CAP 中一致性和可用性权衡的结果，对分布式系统提出了三个概念：</p>
<ul>
<li>基本可用（Basically Available）</li>
<li>软（弱）状态（Soft State）</li>
<li>最终一致性（Eventually Consistent）</li>
</ul>
<p>BASE 理论表明要实现系统的横向扩展，就要对业务进行功能分区，将数据的不同功能组迁移到相互独立的数据库服务器上。由于降低了事务的耦合度，就不能单纯依赖数据库的约束来保证功能组之间的一致性，BASE 提出使用消息队列来异步执行解耦后的命令。</p>
<p>BASE 理论强调的最终一致性允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即<strong>允许多个节点的数据副本存在数据延时</strong>。但是在一定的期限内，应当保证所有副本数据一致，达到数据的最终一致。</p>
<p>总体来说 BASE 理论面向的是大型高并发、可扩展的分布式系统。BASE 提出通过牺牲强一致性来获得可用性，并允许数据短时间内的不一致。在实际场景中，不同业务对数据的一致性要求也不一样，因此衍生出因果一致性、单调读一致性等一致性模型，最终选择要根据使用场景决定。</p>
<h3 id="多副本状态机（Replicated-state-machines）"><a href="#多副本状态机（Replicated-state-machines）" class="headerlink" title="多副本状态机（Replicated state machines）"></a>多副本状态机（Replicated state machines）</h3><p>多副本状态机是指多台机器具有完全相同的状态，并且运行有完全相同的确定性状态机。</p>
<p>通过使用这样的状态机，可以解决很多分布式系统中的容错问题，因为多副本状态机通常可以容忍⌊N/2⌋进程故障，且所有正常运行的副本都完全一致，</p>
<p>所以，可以使用多副本状态机来实现需要避免单点故障的组件，如集中式的选主或是互斥算法中的协调者（coordinator），如图所示：</p>
<p><img src="/images/consensus-algorithm/leader_election.png" alt="高可用“单点”的集中式架构"></p>
<p>集中式的选主或互斥算法逻辑简单，但最大的问题是协调者的单点故障问题，通过采用多副本状态机来实现协调者实现了高可用的“单点”，回避了单点故障。Google的Chubby服务和类似的开源服务Zookeeper就是这样的例子</p>
<p>虽然有很多不同的多副本状态机实现，但其基本实现模式是类似的：状态机的每个副本上都保存有完全相同的操作日志，保证所有副本状态机按照相同的顺序执行操作，这样由于状态机是确定性的，则一定会得到相同的状态，如下图：</p>
<p><img src="/images/consensus-algorithm/RSM-20211109172154933.jpg" alt="img"></p>
<p>共识算法的作用就是在这样的场景中保证所有副本状态机上的操作日志具有完全相同的顺序，具体来讲：<strong>如果状态机的任何一个副本在本地状态机上执行了一个操作，则绝对不会有别的副本在操作序列相同位置执行一个不同的操作</strong>。</p>
<h3 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h3><h4 id="Paxos-Overview"><a href="#Paxos-Overview" class="headerlink" title="Paxos Overview"></a>Paxos Overview</h4><ul>
<li>Paxos( <a target="_blank" rel="noopener" href="http://lamport.azurewebsites.net/pubs/lamport-paxos.pdf">The Part-Time Parliament</a> )共识算法由<a target="_blank" rel="noopener" href="http://www.lamport.org/">Leslie Lamport</a>在1989年首次发布，后来由于大多数人不太能接受他的幽默风趣的介绍方法（其实用比喻的方式介绍长篇的理论，确实让人比较难理解），于是在2001年重新写一篇名叫 <a target="_blank" rel="noopener" href="http://lamport.azurewebsites.net/pubs/paxos-simple.pdf">Paxos Made Simple</a> 论文，相当于原始Paxos算法的简化版，主要讲述两阶段共识协议部分。这篇文章与原始文章在讲述Paxos算法上最大的不同就是用的都是计算机术语，看起来也轻松很多</li>
<li>Paxos算法是分布式系统中的一个共识算法家族，也是第一个有完整数学证明的共识算法</li>
<li>“世界上只有两种分布式共识算法，一种是Paxos算法，另一种是类Paxos算法”</li>
<li>现在比较流行的zab和raft算法也是基于Paxos算法设计的</li>
</ul>
<h4 id="Basic-Paxos"><a href="#Basic-Paxos" class="headerlink" title="Basic Paxos"></a>Basic Paxos</h4><ol>
<li><p>角色</p>
<ul>
<li><p><strong>提议者（Proposer）</strong>：发出提案（Proposal）。Proposal 信息包括提案编号 (Proposal ID) 和提议的值 (Value)</p>
</li>
<li><p><strong>决策者（Acceptor）</strong>：对每个 Proposal 进行投票，若 Proposal 获得多数 Acceptor 的接受，则称该 Proposal 被批准</p>
</li>
<li><p><strong>学习者（Learner）</strong>：不参与决策，从 Proposers/Acceptors 学习、记录最新达成共识的提案（Value）</p>
</li>
</ul>
</li>
<li><p>算法介绍</p>
<p><img src="/images/consensus-algorithm//image-20211110142025398.png" alt="image-20211110142025398"></p>
<p><img src="/images/consensus-algorithm//image-20211110142043783.png" alt="image-20211110142043783"></p>
<ul>
<li>Prepare:<ul>
<li>Proposer 选择一个提案编号 N，然后向 Acceptor 广播编号为 N 的 Prepare 请求；</li>
<li>如果 Acceptor 收到一个编号为 N 的 Prepare 请求，且 N 大于它已经响应的所有 Prepare 请求的编号，那么它就会保证不再响应任何编号小于 N 的提案，同时将它已经通过的最大编号的提案（如果存在的话）回复给 Proposer。</li>
</ul>
</li>
<li>Accept:<ul>
<li>如果 Proposer 收到来自半数以上 Acceptor 的响应，那么它就会发送包含 (N, value) 的 Accept 请求，这里的 value 是收到的响应中编号最大的提案值，如果所有的响应都不包含提案，那么它是客户端发送的值；</li>
<li>如果 Acceptor 收到一个针对编号 N 的提案的 Accept 请求，只要它还未对编号大于 N 的 Prepare 请求作出响应，它就可以通过这个提案</li>
</ul>
</li>
</ul>
</li>
<li><p>案例说明</p>
<ol>
<li><p>单个Proposer发起提议</p>
<img src="https://github.com/vision9527/paxos/raw/main/images/single_proposer.png" alt="single_proposer" style="zoom:40%;" /></li>
<li><p>多个Proposer发起提议</p>
<img src="/images/consensus-algorithm/many_proposer.png" alt="many_proposer" style="zoom:40%;" /></li>
<li><p>活锁等待情况（两个或者多个Proposer在Prepare阶段发生互相抢占的情形）</p>
<img src="/images/consensus-algorithm/live_lock-20211112132559089.png" alt="live_lock" style="zoom:40%;"/></li>
</ol>
</li>
</ol>
<h3 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi Paxos"></a>Multi Paxos</h3><p>为了不发生活锁等待，一个简单的方式是让服务器等待一会，如果发生接受失败的情况，必须返回重新开始。在重新开始之前等待一会，让提议能有机会完成。可以让集群下服务器随机的延迟，从而避免所有服务器都处于相同的等待时间下。在Multi-Paxos下，会有些不同，它是通过（leader election）的机制。保证在同一时间下只有一个 提议者（Proposers） 在工作</p>
<ul>
<li><p>Multi-Paxos是通过选主解决了进展性问题（同时也是满足一致性的）</p>
</li>
<li><p>在Multi Paxos算法中，选主只是为了解决进展性问题，不会影响一致性，即使出现脑裂Paxos算法也是安全的，只会影响进展性</p>
</li>
<li><p>两阶段协议效率太低，可以有优化的空间。在单个Leader的情况下，如果前一次已经accept成功，接下来不再需要prepare阶段，直接进行accept</p>
</li>
<li><p>当需要决定多个值时就需要连续执行多次Paxos算法，一般执行一次Paxos算法的过程称作A Paxos Run 或者 A Paxos Instance</p>
</li>
<li><p>多个instance可以并发的进行</p>
</li>
<li><p>Multi Paxos通常是指一类共识算法，不是精确的指定某个共识算法</p>
</li>
</ul>
<h3 id="ZAB（ZooKeeper-Atomic-Broadcast）"><a href="#ZAB（ZooKeeper-Atomic-Broadcast）" class="headerlink" title="ZAB（ZooKeeper Atomic Broadcast）"></a>ZAB（<strong>ZooKeeper Atomic Broadcast</strong>）</h3><p>Zookeeper Atomic Broadcast，Zookeeper原子消息广播协议，是为Zookeeper所专门设计的一种支持崩溃恢复的原子广播协议。<strong>ZAB协议并不像Paxos算法那样是一种通用的分布式一致性算法，而是专为Zookeeper所设计的</strong></p>
<ol>
<li><p>集群角色</p>
<ul>
<li><strong>Leader</strong>：一个ZooKeeper集群同一时间只会有一个实际工作的Leader，它会发起并维护与各Follwer及Observer间的心跳。所有的写操作必须要通过Leader完成再由Leader将写操作广播给其它服务器。</li>
<li><strong>Follower</strong>： 一个ZooKeeper集群可能同时存在多个Follower，它会响应Leader的心跳。Follower可直接处理并返回客户端的读请求，同时会将写请求转发给Leader处理，并且负责在Leader处理写请求时对请求进行投票。</li>
<li><strong>Observer</strong>： 角色与Follower类似，但是无投票权</li>
</ul>
</li>
<li><p>服务器状态</p>
<ul>
<li><p><strong>Looking</strong>：该状态表示集群中不存在群首节点，进入群首选举过程。</p>
</li>
<li><p><strong>Leading</strong>：群首状态，表示该服务器是群首节点。</p>
</li>
<li><p><strong>Following</strong>：跟随者状态，表示该服务器是群首的Follow节点。</p>
<p><strong>注意</strong>：服务器默认是Looking状态</p>
</li>
</ul>
</li>
<li><p>节点的持久数据状态</p>
<ul>
<li><strong>history</strong>: 当前节点接收到的事务提议的log</li>
<li><strong>acceptedEpoch</strong>：follower节点已经接受的leader更改年号的NEWEPOCH提议</li>
<li><strong>currentEpoch</strong>：当前所处的年代</li>
<li><strong>lastZxid</strong>：history中最近接收到的提议的zxid</li>
</ul>
</li>
<li><p>术语解释</p>
<ul>
<li><p><strong>quorum</strong>：集群中超过半数的节点集合</p>
</li>
<li><p><strong>epoch</strong>：相当于Raft算法选主时候的term，可以理解为任期</p>
</li>
<li><p><strong>zxid</strong>：是Zookeeper中的数据对应的事务ID，为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务，所有的提议（proposal）都在被提出的时候加上了zxid，zxid是一个64位的数字，高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch（原来的epoch+1)，低32位用于递增计数</p>
<img src="/images/consensus-algorithm/image-20210828204920161-20210828204921.png" alt="image-20210828204920161" style="zoom:40%;" /></li>
</ul>
</li>
<li><p>ZAB协议的四阶段</p>
<ol>
<li><p>Phase 0: Leader election（选举阶段）</p>
<p>节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。只有到达 Phase 3 准 leader 才会成为真正的 leader。这一阶段的目的是就是为了选出一个准 leader，然后进入下一个阶段</p>
</li>
<li><p>Phase 1: Discovery（发现阶段）</p>
<p>这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。这个一阶段的主要目的是发现当前大多数节点接收的最新提议，并且准 leader 生成新的 epoch，让 followers 接受，更新它们的 acceptedEpoch</p>
<p>一个 follower 只会连接一个 leader，如果有一个节点 f 认为另一个 follower p 是 leader，f 在尝试连接 p 时会被拒绝，f 被拒绝之后，就会进入 Phase 0</p>
<p><img src="/images/consensus-algorithm/15473897584862.png" alt="img"></p>
</li>
<li><p>Phase 2: Synchronization（同步阶段）</p>
<p>同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。只有当 quorum 都同步完成，准 leader 才会成为真正的 leader。follower 只会接收 zxid 比自己的 lastZxid 大的提议</p>
<p><img src="/images/consensus-algorithm/15473897747901.png" alt="img"></p>
</li>
<li><p>Phase 3: Broadcast（广播阶段）</p>
<p>到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步</p>
<p>值得注意的是，ZAB 提交事务并不像 2PC 一样需要全部 follower 都 ACK，只需要得到 quorum （超过半数的节点）的 ACK 就可以了</p>
<p><img src="/images/consensus-algorithm/15473897855814.png" alt="img"></p>
</li>
</ol>
</li>
<li><p>Java协议实现</p>
<p>协议的 Java 版本实现跟上面的定义有些不同，选举阶段使用的是 Fast Leader Election（FLE），它包含了 Phase 1 的发现职责。因为 FLE 会选举拥有最新提议历史的节点作为 leader，这样就省去了发现最新提议的步骤。实际的实现将 Phase 1 和 Phase 2 合并为 Recovery Phase（恢复阶段）。所以，ZAB 的实现只有三个阶段：</p>
<ul>
<li>Fast Leader Election</li>
<li>Recovery Phase</li>
<li>Broadcast Phase</li>
</ul>
<ol>
<li><p><strong>Fast Leader Election（FLE）</strong></p>
<p>FLE 会选举拥有最新提议历史（lastZxid最大）的节点作为 leader，这样就省去了发现最新提议的步骤。这是基于拥有最新提议的节点也有最新提交记录的前提</p>
<p>成为Leader条件：</p>
<ul>
<li>选epoch最大的</li>
<li>如果epoch相等，zxid最大的</li>
<li>如果epoch和zxid都相等，选server id最大（zoo.cfg中的myid）</li>
</ul>
<p>节点在选举开始都默认投票给自己，当接收其他节点的选票时，会根据上面的条件更改自己的选票并重新发送选票给其他节点，当有一个节点的得票超过半数，该节点会设置自己的状态为 leading，其他节点会设置自己的状态为 following</p>
<p><img src="/images/consensus-algorithm/15473897991049.png" alt="img"></p>
</li>
<li><p><strong>Recovery Phase（恢复阶段）</strong></p>
<ul>
<li>peerLastZxid：这是 Follower 的最后处理 ZXID</li>
<li>minCommittedLog：Leader 服务器的提议缓存队列中 （LinkedList<Proposal>）最小的 ZXID</li>
<li>maxCommittedLog：Leader 服务器的提议缓存队列中 （LinkedList<Proposal>）最大的ZXID</li>
</ul>
<p>根据这三个参数，就可以确定四种同步方式，分别为：</p>
<ul>
<li>直接差异化同步（DIFF）<ul>
<li>场景：当 minCommittedLog &lt; peerLastZxid &lt; maxCommittedLog 时</li>
</ul>
</li>
<li>先回滚在差异化同步（TRUNC+DIFF）<ul>
<li>场景：假如集群有 A、B、C 三台机器，此时 A 是 Leader 但是 A 挂了，在挂之前 A 生成了一个提议假设是：03，然后集群又重新选举 B 为新的 Leader，此时生成的的提议缓存队列为：01~02，B 和 C 进行同步之后，生成新的纪元，ZXID 从 10 开始计数，集群进入广播模式处理了部分请求，假设现在 ZXID 执行到 15 这个值，此时 A 恢复了加入集群，这时候就比较 A 最后提交的 ZXID：peerLastZxid 与 minCommittedLog、maxCommittedLog 的关系。此时虽然符合直接差异化同步：minCommittedLog &lt; peerLastZxid &lt; maxCommittedLog 这样的关系，但是提议缓存队列中却没有这个 ZXID ，这时候就需要先回滚，在进行同步。</li>
</ul>
</li>
<li>仅回滚同步（TRUNC）<ul>
<li>场景：这里和先回滚在差异化同步类似，直接回滚就可以。</li>
</ul>
</li>
<li>全量同步（SNAP）<ul>
<li>场景：peerLastZxid &lt; minCommittedLog，当远远落后 Leader 的数据时，直接全量同步</li>
</ul>
</li>
</ul>
<p><img src="/images/consensus-algorithm/15473898081005.png" alt="img"></p>
</li>
<li><p><strong>Broadcast Phase</strong></p>
<p>ZooKeeper 的消息广播过程类似于两阶段提交，针对客户端的读写事务请求，Leader 会生成对应的事务提案，并为其分配 ZXID，随后将这条提案广播给集群中的其它节点。Follower 节点接收到该事务提案后，会先将其以事务日志的形式写入本地磁盘中，写入成功后会给 Leader 反馈一条 Ack 响应。当 Leader 收到超过半数 Follower 节点的 Ack 响应后，会回复客户端写操作成功，并向集群发送 Commit 消息，将该事务提交。Follower 服务器接收到 Commit 消息后，会完成事务的提交，将数据应用到数据副本中。</p>
<p>在消息广播过程中，Leader 服务器会为每个 Follower 维护一个消息队列，然后将需要广播的提案依次放入队列中，并根据『先入先出』的规则逐一发送消息。因为只要超过半数节点响应就可以认为写操作成功，所以少数的慢节点不会影响整个集群的性能</p>
</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/01/04/zk-server2client/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="tlv">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温故而知新">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/04/zk-server2client/" class="post-title-link" itemprop="url">Zookeeper -- 服务端与客户端网络通信源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-05 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-05T00:00:00+08:00">2020-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-11 21:27:38" itemprop="dateModified" datetime="2022-05-11T21:27:38+08:00">2022-05-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Distributed/" itemprop="url" rel="index"><span itemprop="name">Distributed</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Distributed/Zookeeper/" itemprop="url" rel="index"><span itemprop="name">Zookeeper</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>32k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>29 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Zookeeper 中服务端的通信又可分为服务端与服务端之间的通信和服务端和客户端之间的通信，本章节着重解析服务端和客户端之间的通信，及源码分析。</p>
<h2 id="服务端架构图"><a href="#服务端架构图" class="headerlink" title="服务端架构图"></a>服务端架构图</h2><p><img src="/images/zk-server2client/image-zk-framework.png" alt="image-zk-framework"></p>
<h2 id="核心类介绍"><a href="#核心类介绍" class="headerlink" title="核心类介绍"></a>核心类介绍</h2><p>zk服务端分为单机模式、集群模式，本章因为着重分析服务端与客户端通信，所以使用单机模式作为源码解析，以避开集群模式相关代码的干扰。</p>
<ul>
<li>ZooKeeperServerMain ：ZkServer 核心启动类</li>
<li>ServerCnxnFactory ：服务端连接管理器工厂（工厂模式）</li>
<li>NettyServerCnxnFactory ：服务端连接管理器工厂 Netty 实现（ServerCnxnFactory 实现类）</li>
<li>NettyServerCnxn ：单条连接的服务端连接管理器 Netty 实现</li>
<li>RequestProcessor ：请求处理器接口，实现该接口类可用作 Request Processor Pipeline 中的节点</li>
</ul>
<h2 id="服务端启动流程"><a href="#服务端启动流程" class="headerlink" title="服务端启动流程"></a>服务端启动流程</h2><ol>
<li>配置文件解析</li>
<li>初始化数据管理器</li>
<li>初始化网络I/O管理器</li>
<li>数据恢复</li>
<li>对外服务</li>
</ol>
<p><img src="/images/zk-server2client/5871751-92c0da6dc6ea8287.png" alt="启动流程图"></p>
<h2 id="单机模式启动流程概述"><a href="#单机模式启动流程概述" class="headerlink" title="单机模式启动流程概述"></a>单机模式启动流程概述</h2><ol>
<li>配置文件解析</li>
<li>创建并启动历史文件清理器</li>
<li>初始化数据管理器</li>
<li>注册shutdownHandler</li>
<li>启动Admin server</li>
<li>创建并启动网络IO管理器</li>
<li>启动ZooKeeperServer</li>
<li>创建并启动secureCnxnFactory</li>
<li>创建并启动ContainerManager</li>
</ol>
<h2 id="单机启动源码解析"><a href="#单机启动源码解析" class="headerlink" title="单机启动源码解析"></a>单机启动源码解析</h2><ol>
<li><p>代码入口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.server.quorum.QuorumPeerMain#main</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">QuorumPeerMain</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QuorumPeerMain</span>();</span><br><span class="line">        <span class="comment">// 服务端启动入口</span></span><br><span class="line">  			 <span class="keyword">try</span> &#123;</span><br><span class="line">    			<span class="comment">// 根据命令行参数初始化并运行 Zookeeper 服务端</span></span><br><span class="line">    			main.initializeAndRun(args);</span><br><span class="line">    		&#125; </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件解析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.server.quorum.QuorumPeerMain#initializeAndRun</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initializeAndRun</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ConfigException, IOException, AdminServerException &#123;</span><br><span class="line">        <span class="comment">// 1.解析配置文件</span></span><br><span class="line">        <span class="type">QuorumPeerConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QuorumPeerConfig</span>();</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</span><br><span class="line">            config.parse(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start and schedule the the purge task</span></span><br><span class="line">        <span class="comment">// 2.创建并启动历史文件清理器(对事务日志和快照数据文件进行定时清理)</span></span><br><span class="line">        <span class="type">DatadirCleanupManager</span> <span class="variable">purgeMgr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatadirCleanupManager</span>(</span><br><span class="line">            config.getDataDir(),</span><br><span class="line">            config.getDataLogDir(),</span><br><span class="line">            config.getSnapRetainCount(),</span><br><span class="line">            config.getPurgeInterval());</span><br><span class="line">        purgeMgr.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">1</span> &amp;&amp; config.isDistributed()) &#123;</span><br><span class="line">            <span class="comment">// 集群启动</span></span><br><span class="line">            runFromConfig(config);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;Either no config or no quorum defined in config, running in standalone mode&quot;</span>);</span><br><span class="line">            <span class="comment">// there is only server in the quorum -- run as standalone</span></span><br><span class="line">            <span class="comment">// 单机启动</span></span><br><span class="line">            ZooKeeperServerMain.main(args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>启动流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.server.ZooKeeperServerMain#runFromConfig</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runFromConfig</span><span class="params">(ServerConfig config)</span> <span class="keyword">throws</span> IOException, AdminServerException &#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;Starting server&quot;</span>);</span><br><span class="line">        <span class="type">FileTxnSnapLog</span> <span class="variable">txnLog</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                metricsProvider = MetricsProviderBootstrap.startMetricsProvider(</span><br><span class="line">                    config.getMetricsProviderClassName(),</span><br><span class="line">                    config.getMetricsProviderConfiguration());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MetricsProviderLifeCycleException error) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Cannot boot MetricsProvider &quot;</span> + config.getMetricsProviderClassName(), error);</span><br><span class="line">            &#125;</span><br><span class="line">            ServerMetrics.metricsProviderInitialized(metricsProvider);</span><br><span class="line">            ProviderRegistry.initialize();</span><br><span class="line">            <span class="comment">// Note that this thread isn&#x27;t going to be doing anything else,</span></span><br><span class="line">            <span class="comment">// so rather than spawning another thread, we will just call</span></span><br><span class="line">            <span class="comment">// run() in this thread.</span></span><br><span class="line">            <span class="comment">// create a file logger url from the command line args</span></span><br><span class="line">            <span class="comment">// 3.创建ZooKeeper数据管理器</span></span><br><span class="line">            txnLog = <span class="keyword">new</span> <span class="title class_">FileTxnSnapLog</span>(config.dataLogDir, config.dataDir);</span><br><span class="line">            <span class="type">JvmPauseMonitor</span> <span class="variable">jvmPauseMonitor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (config.jvmPauseMonitorToRun) &#123;</span><br><span class="line">                jvmPauseMonitor = <span class="keyword">new</span> <span class="title class_">JvmPauseMonitor</span>(config);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建 Zookeeper 服务端实例</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ZooKeeperServer</span> <span class="variable">zkServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZooKeeperServer</span>(jvmPauseMonitor, txnLog, config.tickTime, config.minSessionTimeout, config.maxSessionTimeout, config.listenBacklog, <span class="literal">null</span>, config.initialConfig);</span><br><span class="line">            <span class="comment">// 将 Zookeeper 服务端实例与本地事务文件存储进行绑定</span></span><br><span class="line">            txnLog.setServerStats(zkServer.serverStats());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Registers shutdown handler which will be used to know the</span></span><br><span class="line">            <span class="comment">// server error or shutdown state changes.</span></span><br><span class="line">            <span class="comment">// 4.注册shutdownHandler,在ZooKeeperServer的状态变化时调用shutdownHandler的handle()</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">shutdownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">            zkServer.registerServerShutdownHandler(<span class="keyword">new</span> <span class="title class_">ZooKeeperServerShutdownHandler</span>(shutdownLatch));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start Admin server</span></span><br><span class="line">            <span class="comment">// 5.启动Admin server</span></span><br><span class="line">            adminServer = AdminServerFactory.createAdminServer();</span><br><span class="line">            adminServer.setZooKeeperServer(zkServer);</span><br><span class="line">            adminServer.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6.创建并启动网络IO管理器</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">needStartZKServer</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (config.getClientPortAddress() != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 通过静态方法 createFactory 创建 ServerCnxnFactory 实例</span></span><br><span class="line">                cnxnFactory = ServerCnxnFactory.createFactory();</span><br><span class="line">                <span class="comment">// 根据配置文件中的 ClientPostAddress 配置其客户端端口</span></span><br><span class="line">                cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), <span class="literal">false</span>);</span><br><span class="line">                <span class="comment">// 使用 ServerCnxnFactory 启动 zookeeperServer</span></span><br><span class="line">                cnxnFactory.startup(zkServer);</span><br><span class="line">                <span class="comment">// zkServer has been started. So we don&#x27;t need to start it again in secureCnxnFactory.</span></span><br><span class="line">                <span class="comment">// 因为在此处 zkServer 已经启动，所以我们不需要在 secureCnxnFactory 中再次启动它</span></span><br><span class="line">                needStartZKServer = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 8.创建并启动secureCnxnFactory</span></span><br><span class="line">            <span class="keyword">if</span> (config.getSecureClientPortAddress() != <span class="literal">null</span>) &#123;</span><br><span class="line">                secureCnxnFactory = ServerCnxnFactory.createFactory();</span><br><span class="line">                secureCnxnFactory.configure(config.getSecureClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), <span class="literal">true</span>);</span><br><span class="line">                secureCnxnFactory.startup(zkServer, needStartZKServer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 9.创建并启动ContainerManager</span></span><br><span class="line">            containerManager = <span class="keyword">new</span> <span class="title class_">ContainerManager</span>(</span><br><span class="line">                zkServer.getZKDatabase(),</span><br><span class="line">                zkServer.firstProcessor,</span><br><span class="line">                Integer.getInteger(<span class="string">&quot;znode.container.checkIntervalMs&quot;</span>, (<span class="type">int</span>) TimeUnit.MINUTES.toMillis(<span class="number">1</span>)),</span><br><span class="line">                Integer.getInteger(<span class="string">&quot;znode.container.maxPerMinute&quot;</span>, <span class="number">10000</span>),</span><br><span class="line">                Long.getLong(<span class="string">&quot;znode.container.maxNeverUsedIntervalMs&quot;</span>, <span class="number">0</span>)</span><br><span class="line">            );</span><br><span class="line">            containerManager.start();</span><br><span class="line">            ZKAuditProvider.addZKStartStopAuditLog();</span><br><span class="line"></span><br><span class="line">            serverStarted();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Watch status of ZooKeeper server. It will do a graceful shutdown</span></span><br><span class="line">            <span class="comment">// if the server is not running or hits an internal error.</span></span><br><span class="line">            <span class="comment">// 服务器正常启动时,运行到此处阻塞,只有server的state变为ERROR或SHUTDOWN时继续运行后面的代码</span></span><br><span class="line">            shutdownLatch.await();</span><br><span class="line"></span><br><span class="line">            shutdown();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cnxnFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                cnxnFactory.join();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (secureCnxnFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                secureCnxnFactory.join();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (zkServer.canShutdown()) &#123;</span><br><span class="line">                zkServer.shutdown(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// warn, but generally this is ok</span></span><br><span class="line">            LOG.warn(<span class="string">&quot;Server interrupted&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (txnLog != <span class="literal">null</span>) &#123;</span><br><span class="line">                txnLog.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (metricsProvider != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    metricsProvider.stop();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable error) &#123;</span><br><span class="line">                    LOG.warn(<span class="string">&quot;Error while stopping metrics&quot;</span>, error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ServerCnxnFactory（有两个实现模式NIOServerCnxnFactory、NettyServerCnxnFactory）以NettyServerCnxnFactory代码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.server.ServerCnxnFactory#createFactory()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ServerCnxnFactory <span class="title function_">createFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 从配置文件中获取将要创建的 ServerCnxnFactory 类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serverCnxnFactoryName</span> <span class="operator">=</span> System.getProperty(ZOOKEEPER_SERVER_CNXN_FACTORY);</span><br><span class="line">        <span class="keyword">if</span> (serverCnxnFactoryName == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果系统配置文件中未设置该属性则默认使用 JDK 的 NIO 实现版本 NIOServerCnxnFactory</span></span><br><span class="line">            serverCnxnFactoryName = NIOServerCnxnFactory.class.getName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过反射调用构造方法实例化 ServerCnxnFactory 对象</span></span><br><span class="line">            <span class="type">ServerCnxnFactory</span> <span class="variable">serverCnxnFactory</span> <span class="operator">=</span> (ServerCnxnFactory) Class.forName(serverCnxnFactoryName)</span><br><span class="line">                                                                           .getDeclaredConstructor()</span><br><span class="line">                                                                           .newInstance();</span><br><span class="line">            LOG.info(<span class="string">&quot;Using &#123;&#125; as server connection factory&quot;</span>, serverCnxnFactoryName);</span><br><span class="line">            <span class="keyword">return</span> serverCnxnFactory;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="type">IOException</span> <span class="variable">ioe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Couldn&#x27;t instantiate &quot;</span> + serverCnxnFactoryName, e);</span><br><span class="line">            <span class="keyword">throw</span> ioe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.zookeeper.server.ServerCnxnFactory#startup(org.apache.zookeeper.server.ZooKeeperServer)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startup</span><span class="params">(ZooKeeperServer zkServer)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 启动 zkServer</span></span><br><span class="line">        startup(zkServer, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.zookeeper.server.NettyServerCnxnFactory#startup</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startup</span><span class="params">(ZooKeeperServer zks, <span class="type">boolean</span> startServer)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 绑定 Netty 监听端口</span></span><br><span class="line">        start();</span><br><span class="line">        <span class="comment">// 完成 zkServer 和 ServerCnxnFactory 的双向绑定</span></span><br><span class="line">        setZooKeeperServer(zks);</span><br><span class="line">        <span class="keyword">if</span> (startServer) &#123;</span><br><span class="line">            <span class="comment">// 启动 zkServer</span></span><br><span class="line">            zks.startdata();</span><br><span class="line">            zks.startup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.zookeeper.server.NettyServerCnxnFactory#start</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (listenBacklog != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置半连队列大小</span></span><br><span class="line">            bootstrap.option(ChannelOption.SO_BACKLOG, listenBacklog);</span><br><span class="line">        &#125;</span><br><span class="line">        LOG.info(<span class="string">&quot;binding to port &#123;&#125;&quot;</span>, localAddress);</span><br><span class="line">        <span class="comment">// 绑定端口</span></span><br><span class="line">        parentChannel = bootstrap.bind(localAddress).syncUninterruptibly().channel();</span><br><span class="line">        <span class="comment">// Port changes after bind() if the original port was 0, update</span></span><br><span class="line">        <span class="comment">// localAddress to get the real port.</span></span><br><span class="line">        localAddress = (InetSocketAddress) parentChannel.localAddress();</span><br><span class="line">        LOG.info(<span class="string">&quot;bound to port &#123;&#125;&quot;</span>, getLocalPort());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.zookeeper.server.ServerCnxnFactory#setZooKeeperServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setZooKeeperServer</span><span class="params">(ZooKeeperServer zks)</span> &#123;</span><br><span class="line">        <span class="comment">// zkServer 和 ServerCnxnFactory 的双向绑定</span></span><br><span class="line">        <span class="built_in">this</span>.zkServer = zks;</span><br><span class="line">        <span class="keyword">if</span> (zks != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (secure) &#123;</span><br><span class="line">                zks.setSecureServerCnxnFactory(<span class="built_in">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                zks.setServerCnxnFactory(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>配置 Netty</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">NettyServerCnxnFactory() &#123;</span><br><span class="line">        x509Util = <span class="keyword">new</span> <span class="title class_">ClientX509Util</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">usePortUnification</span> <span class="operator">=</span> Boolean.getBoolean(PORT_UNIFICATION_KEY);</span><br><span class="line">        LOG.info(<span class="string">&quot;&#123;&#125;=&#123;&#125;&quot;</span>, PORT_UNIFICATION_KEY, usePortUnification);</span><br><span class="line">        <span class="keyword">if</span> (usePortUnification) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                QuorumPeerConfig.configureSSLAuth();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (QuorumPeerConfig.ConfigException e) &#123;</span><br><span class="line">                LOG.error(<span class="string">&quot;unable to set up SslAuthProvider, turning off client port unification&quot;</span>, e);</span><br><span class="line">                usePortUnification = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.shouldUsePortUnification = usePortUnification;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.advancedFlowControlEnabled = Boolean.getBoolean(NETTY_ADVANCED_FLOW_CONTROL);</span><br><span class="line">        LOG.info(<span class="string">&quot;&#123;&#125; = &#123;&#125;&quot;</span>, NETTY_ADVANCED_FLOW_CONTROL, <span class="built_in">this</span>.advancedFlowControlEnabled);</span><br><span class="line"></span><br><span class="line">        setOutstandingHandshakeLimit(Integer.getInteger(OUTSTANDING_HANDSHAKE_LIMIT, -<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// bossGroup处理客户端的连接请求，workerGroup负责每个连接IO事件的处理，典型的reactor模式</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> NettyUtils.newNioOrEpollEventLoopGroup(NettyUtils.getClientReachableLocalInetAddressCount());</span><br><span class="line">        <span class="comment">// 创建 workerGroup 且优先选择使用更高性能的 EpollEventLoopGroup</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> NettyUtils.newNioOrEpollEventLoopGroup();</span><br><span class="line">        <span class="comment">// 创建ServerBootstrap 配置 handler</span></span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>().group(bossGroup, workerGroup)</span><br><span class="line">                                                         .channel(NettyUtils.nioOrEpollServerSocketChannel())</span><br><span class="line">                                                         <span class="comment">// parent channel options</span></span><br><span class="line">                                                         .option(ChannelOption.SO_REUSEADDR, <span class="literal">true</span>)</span><br><span class="line">                                                         <span class="comment">// child channels options</span></span><br><span class="line">                                                         .childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                                                         .childOption(ChannelOption.SO_LINGER, -<span class="number">1</span>)</span><br><span class="line">                                                         .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                                                             <span class="meta">@Override</span></span><br><span class="line">                                                             <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                                                 <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                                                                 <span class="keyword">if</span> (advancedFlowControlEnabled) &#123;</span><br><span class="line">                                                                     pipeline.addLast(readIssuedTrackingHandler);</span><br><span class="line">                                                                 &#125;</span><br><span class="line">                                                                 <span class="keyword">if</span> (secure) &#123;</span><br><span class="line">                                                                     initSSL(pipeline, <span class="literal">false</span>);</span><br><span class="line">                                                                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldUsePortUnification) &#123;</span><br><span class="line">                                                                     initSSL(pipeline, <span class="literal">true</span>);</span><br><span class="line">                                                                 &#125;</span><br><span class="line">                                                                 <span class="comment">// 向 pipeline 添加 channelHandler 处理器</span></span><br><span class="line">                                                                 pipeline.addLast(<span class="string">&quot;servercnxnfactory&quot;</span>, channelHandler);</span><br><span class="line">                                                             &#125;</span><br><span class="line">                                                         &#125;);</span><br><span class="line">        <span class="built_in">this</span>.bootstrap = configureBootstrapAllocator(bootstrap);</span><br><span class="line">        <span class="built_in">this</span>.bootstrap.validate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ZooKeeperServer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.server.ZooKeeperServer#startup</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">startup</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 启动zkServer 并设置为 RUNNING 状态</span></span><br><span class="line">        startupWithServerState(State.RUNNING);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.zookeeper.server.ZooKeeperServer#startupWithServerState</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startupWithServerState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="comment">// session 管理</span></span><br><span class="line">        <span class="keyword">if</span> (sessionTracker == <span class="literal">null</span>) &#123;</span><br><span class="line">            createSessionTracker();</span><br><span class="line">        &#125;</span><br><span class="line">        startSessionTracker();</span><br><span class="line">        <span class="comment">// 请求前置处理器，是一个生产消费队列，对每个请求状态码进行判断，分别进行请求前置处理</span></span><br><span class="line">        setupRequestProcessors();</span><br><span class="line"></span><br><span class="line">        startRequestThrottler();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册jmx bean</span></span><br><span class="line">        registerJMX();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// jvm停止监控，默认不开启</span></span><br><span class="line">        startJvmPauseMonitor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过zxdb和zkserver填写相关指标</span></span><br><span class="line">        registerMetrics();</span><br><span class="line"></span><br><span class="line">        setState(state);</span><br><span class="line"></span><br><span class="line">        requestPathMetricsCollector.start();</span><br><span class="line"></span><br><span class="line">        localSessionEnabled = sessionTracker.isLocalSessionsEnabled();</span><br><span class="line"></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>CnxnChannelHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.server.NettyServerCnxnFactory.CnxnChannelHandler</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CnxnChannelHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelDuplexHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当服务端接受客户端的socket连接之后，channelActive会被调用</span></span><br><span class="line">        <span class="comment">// 正常情况下通过channelActive服务端session层的连接表示对象会被建立起来</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                LOG.trace(<span class="string">&quot;Channel active &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">            <span class="comment">// 连接数有没有达到服务端设置的连接最大数，如果达到了，直接关闭底层socket，拒绝新的连接请求</span></span><br><span class="line">            <span class="keyword">if</span> (limitTotalNumberOfCnxns()) &#123;</span><br><span class="line">                ServerMetrics.getMetrics().CONNECTION_REJECTED.add(<span class="number">1</span>);</span><br><span class="line">                channel.close();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">addr</span> <span class="operator">=</span> ((InetSocketAddress) channel.remoteAddress()).getAddress();</span><br><span class="line">            <span class="comment">// 单个客户端的连接数是不是超过了用户设置的最大可建立连接数，如果达到了拒绝客户端的连接请求</span></span><br><span class="line">            <span class="keyword">if</span> (maxClientCnxns &gt; <span class="number">0</span> &amp;&amp; getClientCnxnCount(addr) &gt;= maxClientCnxns) &#123;</span><br><span class="line">                ServerMetrics.getMetrics().CONNECTION_REJECTED.add(<span class="number">1</span>);</span><br><span class="line">                LOG.warn(<span class="string">&quot;Too many connections from &#123;&#125; - max is &#123;&#125;&quot;</span>, addr, maxClientCnxns);</span><br><span class="line">                channel.close();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建session会话层的连接表示对象NettyServerCnxn</span></span><br><span class="line">            <span class="type">NettyServerCnxn</span> <span class="variable">cnxn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NettyServerCnxn</span>(channel, zkServer, NettyServerCnxnFactory.<span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">// 将 NettyServerCnxn 保存至 Channel 属性中（接收请求时会用到）</span></span><br><span class="line">            ctx.channel().attr(CONNECTION_ATTRIBUTE).set(cnxn);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check the zkServer assigned to the cnxn is still running,</span></span><br><span class="line">            <span class="comment">// close it before starting the heavy TLS handshake</span></span><br><span class="line">            <span class="keyword">if</span> (!cnxn.isZKServerRunning()) &#123;</span><br><span class="line">                LOG.warn(<span class="string">&quot;Zookeeper server is not running, close the connection before starting the TLS handshake&quot;</span>);</span><br><span class="line">                ServerMetrics.getMetrics().CNXN_CLOSED_WITHOUT_ZK_SERVER_RUNNING.add(<span class="number">1</span>);</span><br><span class="line">                channel.close();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (handshakeThrottlingEnabled) &#123;</span><br><span class="line">                <span class="comment">// Favor to check and throttling even in dual mode which</span></span><br><span class="line">                <span class="comment">// accepts both secure and insecure connections, since</span></span><br><span class="line">                <span class="comment">// it&#x27;s more efficient than throttling when we know it&#x27;s</span></span><br><span class="line">                <span class="comment">// a secure connection in DualModeSslHandler.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// From benchmark, this reduced around 15% reconnect time.</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">outstandingHandshakesNum</span> <span class="operator">=</span> outstandingHandshake.addAndGet(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (outstandingHandshakesNum &gt; outstandingHandshakeLimit) &#123;</span><br><span class="line">                    outstandingHandshake.addAndGet(-<span class="number">1</span>);</span><br><span class="line">                    channel.close();</span><br><span class="line">                    ServerMetrics.getMetrics().TLS_HANDSHAKE_EXCEEDED.add(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cnxn.setHandshakeState(HandshakeState.STARTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (secure) &#123;</span><br><span class="line">                <span class="type">SslHandler</span> <span class="variable">sslHandler</span> <span class="operator">=</span> ctx.pipeline().get(SslHandler.class);</span><br><span class="line">                Future&lt;Channel&gt; handshakeFuture = sslHandler.handshakeFuture();</span><br><span class="line">                handshakeFuture.addListener(<span class="keyword">new</span> <span class="title class_">CertificateVerifier</span>(sslHandler, cnxn));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!shouldUsePortUnification) &#123;</span><br><span class="line">                <span class="comment">// 将 Channel 和 NettyServerCnxn 分别添加到集合中保存</span></span><br><span class="line">                allChannels.add(ctx.channel());</span><br><span class="line">                addCnxn(cnxn);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ctx.channel().pipeline().get(SslHandler.class) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">SocketAddress</span> <span class="variable">remoteAddress</span> <span class="operator">=</span> cnxn.getChannel().remoteAddress();</span><br><span class="line">                <span class="keyword">if</span> (remoteAddress != <span class="literal">null</span></span><br><span class="line">                        &amp;&amp; !((InetSocketAddress) remoteAddress).getAddress().isLoopbackAddress()) &#123;</span><br><span class="line">                    LOG.trace(<span class="string">&quot;NettyChannelHandler channelActive: remote=&#123;&#125; local=&#123;&#125;&quot;</span>, remoteAddress, cnxn.getChannel().localAddress());</span><br><span class="line">                    zkServer.serverStats().incrementNonMTLSRemoteConnCount();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    zkServer.serverStats().incrementNonMTLSLocalConnCount();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接关闭时的处理逻辑</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                LOG.trace(<span class="string">&quot;Channel inactive &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 Channel 从 allChannels 集合中移除</span></span><br><span class="line">            allChannels.remove(ctx.channel());</span><br><span class="line">            <span class="type">NettyServerCnxn</span> <span class="variable">cnxn</span> <span class="operator">=</span> ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (cnxn != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                    LOG.trace(<span class="string">&quot;Channel inactive caused close &#123;&#125;&quot;</span>, cnxn);</span><br><span class="line">                &#125;</span><br><span class="line">                updateHandshakeCountIfStarted(cnxn);</span><br><span class="line">                <span class="comment">// 关闭 NettyServerCnxn</span></span><br><span class="line">                cnxn.close(ServerCnxn.DisconnectReason.CHANNEL_DISCONNECTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异常处理方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;Exception caught&quot;</span>, cause);</span><br><span class="line">            <span class="type">NettyServerCnxn</span> <span class="variable">cnxn</span> <span class="operator">=</span> ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (cnxn != <span class="literal">null</span>) &#123;</span><br><span class="line">                LOG.debug(<span class="string">&quot;Closing &#123;&#125;&quot;</span>, cnxn);</span><br><span class="line">                updateHandshakeCountIfStarted(cnxn);</span><br><span class="line">                cnxn.close(ServerCnxn.DisconnectReason.CHANNEL_CLOSED_EXCEPTION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理用自定义的channel事件：主要是处理channel读和不读的事件</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (evt == NettyServerCnxn.ReadEvent.ENABLE) &#123;</span><br><span class="line">                    LOG.debug(<span class="string">&quot;Received ReadEvent.ENABLE&quot;</span>);</span><br><span class="line">                    <span class="type">NettyServerCnxn</span> <span class="variable">cnxn</span> <span class="operator">=</span> ctx.channel().attr(CONNECTION_ATTRIBUTE).get();</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Not sure if cnxn can be null here. It becomes null if channelInactive()</span></span><br><span class="line">                    <span class="comment">// or exceptionCaught() trigger, but it&#x27;s unclear to me if userEventTriggered() can run</span></span><br><span class="line">                    <span class="comment">// after either of those. Check for null just to be safe ...</span></span><br><span class="line">                    <span class="keyword">if</span> (cnxn != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (cnxn.getQueuedReadableBytes() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            cnxn.processQueuedBuffer();</span><br><span class="line">                            <span class="keyword">if</span> (advancedFlowControlEnabled &amp;&amp; cnxn.getQueuedReadableBytes() == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">// trigger a read if we have consumed all</span></span><br><span class="line">                                <span class="comment">// backlog</span></span><br><span class="line">                                ctx.read();</span><br><span class="line">                                LOG.debug(<span class="string">&quot;Issued a read after queuedBuffer drained&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!advancedFlowControlEnabled) &#123;</span><br><span class="line">                        ctx.channel().config().setAutoRead(<span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (evt == NettyServerCnxn.ReadEvent.DISABLE) &#123;</span><br><span class="line">                    LOG.debug(<span class="string">&quot;Received ReadEvent.DISABLE&quot;</span>);</span><br><span class="line">                    ctx.channel().config().setAutoRead(<span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ReferenceCountUtil.release(evt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务端读取客户端发送来的请求数据</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                    LOG.trace(<span class="string">&quot;message received called &#123;&#125;&quot;</span>, msg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    LOG.debug(<span class="string">&quot;New message &#123;&#125; from &#123;&#125;&quot;</span>, msg, ctx.channel());</span><br><span class="line">                    <span class="comment">// channelActive时候 将NettyServerCnxn注册到的Channel 属性中</span></span><br><span class="line">                    <span class="type">NettyServerCnxn</span> <span class="variable">cnxn</span> <span class="operator">=</span> ctx.channel().attr(CONNECTION_ATTRIBUTE).get();</span><br><span class="line">                    <span class="keyword">if</span> (cnxn == <span class="literal">null</span>) &#123;</span><br><span class="line">                        LOG.error(<span class="string">&quot;channelRead() on a closed or closing NettyServerCnxn&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果 NettyServerCnxn 未被关闭或未被正在关闭则调用 processMessage 处理请求</span></span><br><span class="line">                        cnxn.processMessage((ByteBuf) msg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    LOG.error(<span class="string">&quot;Unexpected exception in receive&quot;</span>, ex);</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放 Buffer</span></span><br><span class="line">                ReferenceCountUtil.release(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (advancedFlowControlEnabled) &#123;</span><br><span class="line">                <span class="type">NettyServerCnxn</span> <span class="variable">cnxn</span> <span class="operator">=</span> ctx.channel().attr(CONNECTION_ATTRIBUTE).get();</span><br><span class="line">                <span class="keyword">if</span> (cnxn != <span class="literal">null</span> &amp;&amp; cnxn.getQueuedReadableBytes() == <span class="number">0</span> &amp;&amp; cnxn.readIssuedAfterReadComplete == <span class="number">0</span>) &#123;</span><br><span class="line">                    ctx.read();</span><br><span class="line">                    LOG.debug(<span class="string">&quot;Issued a read since we do not have anything to consume after channelReadComplete&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ctx.fireChannelReadComplete();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use a single listener instance to reduce GC</span></span><br><span class="line">        <span class="comment">// Note: this listener is only added when LOG.isTraceEnabled() is true,</span></span><br><span class="line">        <span class="comment">// so it should not do any work other than trace logging.</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> GenericFutureListener&lt;Future&lt;Void&gt;&gt; onWriteCompletedTracer = (f) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                LOG.trace(<span class="string">&quot;write success: &#123;&#125;&quot;</span>, f.isSuccess());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                promise.addListener(onWriteCompletedTracer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">super</span>.write(ctx, msg, promise);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>接收并处理请求 NettyServerCnxn</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.server.NettyServerCnxn#processMessage</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">processMessage</span><span class="params">(ByteBuf buf)</span> &#123;</span><br><span class="line">        checkIsInEventLoop(<span class="string">&quot;processMessage&quot;</span>);</span><br><span class="line">        LOG.debug(<span class="string">&quot;0x&#123;&#125; queuedBuffer: &#123;&#125;&quot;</span>, Long.toHexString(sessionId), queuedBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">            LOG.trace(<span class="string">&quot;0x&#123;&#125; buf &#123;&#125;&quot;</span>, Long.toHexString(sessionId), ByteBufUtil.hexDump(buf));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (throttled.get()) &#123;</span><br><span class="line">            LOG.debug(<span class="string">&quot;Received message while throttled&quot;</span>);</span><br><span class="line">            <span class="comment">// we are throttled, so we need to queue</span></span><br><span class="line">            <span class="comment">// 如果当前为限流状态则直接进行排队</span></span><br><span class="line">            <span class="keyword">if</span> (queuedBuffer == <span class="literal">null</span>) &#123;</span><br><span class="line">                LOG.debug(<span class="string">&quot;allocating queue&quot;</span>);</span><br><span class="line">                queuedBuffer = channel.alloc().compositeBuffer();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加至 queuedBuffer 中排队</span></span><br><span class="line">            appendToQueuedBuffer(buf.retainedDuplicate());</span><br><span class="line">            <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                LOG.trace(<span class="string">&quot;0x&#123;&#125; queuedBuffer &#123;&#125;&quot;</span>, Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG.debug(<span class="string">&quot;not throttled&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (queuedBuffer != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 排队队列不为空 直接加入对接排队</span></span><br><span class="line">                appendToQueuedBuffer(buf.retainedDuplicate());</span><br><span class="line">                <span class="comment">// 该方法中包含对于 Channel 正在关闭时的处理逻辑，但对于响应的处理实质还是调用 receiveMessage 方法</span></span><br><span class="line">                processQueuedBuffer();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 调用 receiveMessage 处理响应</span></span><br><span class="line">                receiveMessage(buf);</span><br><span class="line">                <span class="comment">// Have to check !closingChannel, because an error in</span></span><br><span class="line">                <span class="comment">// receiveMessage() could have led to close() being called.</span></span><br><span class="line">                <span class="comment">// 必须再次检查通道是否正在关闭，因为在 receiveMessage 方法中可能出现错误而导致 close() 被调用  </span></span><br><span class="line">                <span class="keyword">if</span> (!closingChannel &amp;&amp; buf.isReadable()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                        LOG.trace(<span class="string">&quot;Before copy &#123;&#125;&quot;</span>, buf);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (queuedBuffer == <span class="literal">null</span>) &#123;</span><br><span class="line">                        queuedBuffer = channel.alloc().compositeBuffer();</span><br><span class="line">                    &#125;</span><br><span class="line">                    appendToQueuedBuffer(buf.retainedSlice(buf.readerIndex(), buf.readableBytes()));</span><br><span class="line">                    <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                        LOG.trace(<span class="string">&quot;Copy is &#123;&#125;&quot;</span>, queuedBuffer);</span><br><span class="line">                        LOG.trace(<span class="string">&quot;0x&#123;&#125; queuedBuffer &#123;&#125;&quot;</span>, Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> <strong>Netty.CompositeByteBuf</strong> ：复合缓冲区是多个ByteBuf组合的视图，复合缓冲区就像一个列表，我们可以动态的添加和删除其中的 ByteBuf，可以组合多个 Buffer 对象合并成一个逻辑上的对象，避免通过传统内存拷贝的方式将几个 Buffer 合并成一个大的 Buffer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.server.NettyServerCnxn#receiveMessage</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(ByteBuf message)</span> &#123;</span><br><span class="line">        checkIsInEventLoop(<span class="string">&quot;receiveMessage&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 当writerIndex大于readerIndex(表示ByteBuf中还有可读内容)</span></span><br><span class="line">            <span class="comment">// 且throttled为false时执行while循环体</span></span><br><span class="line">            <span class="keyword">while</span> (message.isReadable() &amp;&amp; !throttled.get()) &#123;</span><br><span class="line">                <span class="comment">// bb不为null，表示已经准备好读取message</span></span><br><span class="line">                <span class="keyword">if</span> (bb != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 其中主要的部分是判断bb的剩余空间是否大于message中的内容，</span></span><br><span class="line">                    <span class="comment">// 就是判断bb是否还有足够空间存储message内容，</span></span><br><span class="line">                    <span class="comment">// 然后设置bb的limit，之后将message内容读入bb缓冲中，</span></span><br><span class="line">                    <span class="comment">// 之后再次确定时候已经读完message内容，统计接收信息，</span></span><br><span class="line">                    <span class="comment">// 再根据是否已经初始化来处理包或者是连接请求，其中的请求内容都存储在bb中</span></span><br><span class="line">                    <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                        LOG.trace(<span class="string">&quot;message readable &#123;&#125; bb len &#123;&#125; &#123;&#125;&quot;</span>, message.readableBytes(), bb.remaining(), bb);</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">dat</span> <span class="operator">=</span> bb.duplicate();</span><br><span class="line">                        dat.flip();</span><br><span class="line">                        LOG.trace(<span class="string">&quot;0x&#123;&#125; bb &#123;&#125;&quot;</span>, Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// bb剩余空间大于message中可读字节大小</span></span><br><span class="line">                    <span class="keyword">if</span> (bb.remaining() &gt; message.readableBytes()) &#123;</span><br><span class="line">                        <span class="comment">// 确定新的limit</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">newLimit</span> <span class="operator">=</span> bb.position() + message.readableBytes();</span><br><span class="line">                        bb.limit(newLimit);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将message写入bb中</span></span><br><span class="line">                    message.readBytes(bb);</span><br><span class="line">                    <span class="comment">// 重置bb的limit</span></span><br><span class="line">                    bb.limit(bb.capacity());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                        LOG.trace(<span class="string">&quot;after readBytes message readable &#123;&#125; bb len &#123;&#125; &#123;&#125;&quot;</span>, message.readableBytes(), bb.remaining(), bb);</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">dat</span> <span class="operator">=</span> bb.duplicate();</span><br><span class="line">                        dat.flip();</span><br><span class="line">                        LOG.trace(<span class="string">&quot;after readbytes 0x&#123;&#125; bb &#123;&#125;&quot;</span>,</span><br><span class="line">                                  Long.toHexString(sessionId),</span><br><span class="line">                                  ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 已经读完message，表示内容已经全部接收</span></span><br><span class="line">                    <span class="keyword">if</span> (bb.remaining() == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 翻转，可读</span></span><br><span class="line">                        bb.flip();</span><br><span class="line">                        <span class="comment">// 统计接收信息</span></span><br><span class="line">                        packetReceived(<span class="number">4</span> + bb.remaining());</span><br><span class="line"></span><br><span class="line">                        <span class="type">ZooKeeperServer</span> <span class="variable">zks</span> <span class="operator">=</span> <span class="built_in">this</span>.zkServer;</span><br><span class="line">                        <span class="comment">// Zookeeper服务器为空 抛出异常</span></span><br><span class="line">                        <span class="keyword">if</span> (zks == <span class="literal">null</span> || !zks.isRunning()) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;ZK down&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 未被初始化</span></span><br><span class="line">                        <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">                            <span class="comment">// <span class="doctag">TODO:</span> if zks.processPacket() is changed to take a ByteBuffer[],</span></span><br><span class="line">                            <span class="comment">// we could implement zero-copy queueing.</span></span><br><span class="line">                            <span class="comment">// 处理bb中包含的包信息</span></span><br><span class="line">                            zks.processPacket(<span class="built_in">this</span>, bb);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 已经初始化</span></span><br><span class="line">                            LOG.debug(<span class="string">&quot;got conn req request from &#123;&#125;&quot;</span>, getRemoteSocketAddress());</span><br><span class="line">                            <span class="comment">// 处理连接请求</span></span><br><span class="line">                            zks.processConnectRequest(<span class="built_in">this</span>, bb);</span><br><span class="line">                            initialized = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        bb = <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                        LOG.trace(<span class="string">&quot;message readable &#123;&#125; bblenrem &#123;&#125;&quot;</span>, message.readableBytes(), bbLen.remaining());</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">dat</span> <span class="operator">=</span> bbLen.duplicate();</span><br><span class="line">                        dat.flip();</span><br><span class="line">                        LOG.trace(<span class="string">&quot;0x&#123;&#125; bbLen &#123;&#125;&quot;</span>, Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (message.readableBytes() &lt; bbLen.remaining()) &#123;</span><br><span class="line">                        bbLen.limit(bbLen.position() + message.readableBytes());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 4 byte 的 ByteBuffer 用于读取数据包中前 4 byte 所记录的数据包中实际数据长度</span></span><br><span class="line">                    message.readBytes(bbLen);</span><br><span class="line">                    bbLen.limit(bbLen.capacity());</span><br><span class="line">                    <span class="keyword">if</span> (bbLen.remaining() == <span class="number">0</span>) &#123;</span><br><span class="line">                        bbLen.flip();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                            LOG.trace(<span class="string">&quot;0x&#123;&#125; bbLen &#123;&#125;&quot;</span>, Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(bbLen)));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 读取前 4 byte 所代表的的 Int 数值</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> bbLen.getInt();</span><br><span class="line">                        <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">                            LOG.trace(<span class="string">&quot;0x&#123;&#125; bbLen len is &#123;&#125;&quot;</span>, Long.toHexString(sessionId), len);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        bbLen.clear();</span><br><span class="line">                        <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (checkFourLetterWord(channel, message, len)) &#123;</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (len &lt; <span class="number">0</span> || len &gt; BinaryInputArchive.maxBuffer) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Len error &quot;</span> + len);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="type">ZooKeeperServer</span> <span class="variable">zks</span> <span class="operator">=</span> <span class="built_in">this</span>.zkServer;</span><br><span class="line">                        <span class="keyword">if</span> (zks == <span class="literal">null</span> || !zks.isRunning()) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;ZK down&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// checkRequestSize will throw IOException if request is rejected</span></span><br><span class="line">                        zks.checkRequestSizeWhenReceivingMessage(len);</span><br><span class="line">                        <span class="comment">// 将 bb 赋值为数据包中前 4 byte Int 值长度的 ByteBuffer</span></span><br><span class="line">                        bb = ByteBuffer.allocate(len);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;Closing connection to &#123;&#125;&quot;</span>, getRemoteSocketAddress(), e);</span><br><span class="line">            close(DisconnectReason.IO_EXCEPTION);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientCnxnLimitException e) &#123;</span><br><span class="line">            <span class="comment">// Common case exception, print at debug level</span></span><br><span class="line">            ServerMetrics.getMetrics().CONNECTION_REJECTED.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            LOG.debug(<span class="string">&quot;Closing connection to &#123;&#125;&quot;</span>, getRemoteSocketAddress(), e);</span><br><span class="line">            close(DisconnectReason.CLIENT_RATE_LIMIT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>receiveMessage</strong>逻辑梳理</p>
<ol>
<li>当数据包首次进入该方法时 bb 为空，所以直接进入第二个语句块；</li>
<li>在第二个语句块中会从数据包中读入长度为 4 byte 的 ByteBuffer（ bblen = ByteBuffer.allocate(4) ），然后将其转换为一个 Int 整型值 len ；</li>
<li>根据整型值 len 申请长度为 len 的 ByteBuffer 赋值给 bb ，然后结束此轮循环；</li>
<li>进入第二轮循环时 bb 已经是长度为 len 的 ByteBuffer（ len 为数据包中有效数据的长度 ），所以进入第一个语句块；</li>
<li>在第一个语句块中会直接从传入的数据包中读长度为 len 的数据并写入到 bb 中（一次性完整的将全部有效数据读入）；</li>
<li>最后将获取到的有效数据传入 processPacket 方法中进行处理；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.server.ZooKeeperServer#processPacket</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processPacket</span><span class="params">(ServerCnxn cnxn, ByteBuffer incomingBuffer)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="comment">// We have the request, now process and setup for next</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteBufferInputStream</span>(incomingBuffer);</span><br><span class="line">    <span class="type">BinaryInputArchive</span> <span class="variable">bia</span> <span class="operator">=</span> BinaryInputArchive.getArchive(bais);</span><br><span class="line">    <span class="comment">// 解析请求头至临时变量 h</span></span><br><span class="line">    <span class="type">RequestHeader</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestHeader</span>();</span><br><span class="line">    h.deserialize(bia, <span class="string">&quot;header&quot;</span>);</span><br><span class="line">    <span class="comment">// 从原缓冲区的当前位置开始创建一个新的字节缓冲区</span></span><br><span class="line">	incomingBuffer = incomingBuffer.slice();</span><br><span class="line">	<span class="keyword">if</span> (h.getType() == OpCode.auth) &#123;</span><br><span class="line">		<span class="type">AuthPacket</span> <span class="variable">authPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthPacket</span>();</span><br><span class="line">        ByteBufferInputStream.byteBuffer2Record(incomingBuffer, authPacket);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 省略认证等代码...</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// 将数据包中的有效数据组装为 Request 请求</span></span><br><span class="line">            <span class="type">Request</span> <span class="variable">si</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>(cnxn, cnxn.getSessionId(), h.getXid(), h.getType(), incomingBuffer, cnxn.getAuthInfo());</span><br><span class="line">            si.setOwner(ServerCnxn.me);</span><br><span class="line">            <span class="comment">// 将组装好的 Request 请求通过 submitRequest 方法发送给上层逻辑处理</span></span><br><span class="line">            submitRequest(si);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnxn.incrOutstandingRequests(h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submitRequest</span><span class="params">(Request si)</span> &#123;</span><br><span class="line">        enqueueRequest(si);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueueRequest</span><span class="params">(Request si)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestThrottler == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Since all requests are passed to the request</span></span><br><span class="line">                    <span class="comment">// processor it should wait for setting up the request</span></span><br><span class="line">                    <span class="comment">// processor chain. The state will be updated to RUNNING</span></span><br><span class="line">                    <span class="comment">// after the setup.</span></span><br><span class="line">                    <span class="keyword">while</span> (state == State.INITIAL) &#123;</span><br><span class="line">                        wait(<span class="number">1000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    LOG.warn(<span class="string">&quot;Unexpected interruption&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (requestThrottler == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Not started&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 提交请求给限流器</span></span><br><span class="line">        requestThrottler.submitRequest(si);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submitRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已停止，则删除队列</span></span><br><span class="line">        <span class="keyword">if</span> (stopping) &#123;</span><br><span class="line">            LOG.debug(<span class="string">&quot;Shutdown in progress. Request cannot be processed&quot;</span>);</span><br><span class="line">            dropRequest(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            request.requestThrottleQueueTime = Time.currentElapsedTime();</span><br><span class="line">            <span class="comment">// LinkedBlockingQueue 入队，最终由该线程去异步处理</span></span><br><span class="line">            submittedRequests.add(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的tcp数据转换，将其转换为了 Request 实例，提交到队列了。接下来这个队列将被 RequestThrottler 处理，它的作用是判定是否超出了设置的最大请求数，如果超出，则作等待处理，防止下游无法应对</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">org.apache.zookeeper.server.RequestThrottler#run</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (killed) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 阻塞式获取，即只要数据被提交，就会被立即处理</span></span><br><span class="line">                <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> submittedRequests.take();</span><br><span class="line">                <span class="keyword">if</span> (Request.requestOfDeath == request) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (request.mustDrop()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Throttling is disabled when maxRequests = 0</span></span><br><span class="line">                <span class="comment">// maxRequests等于0 不开启限流控制</span></span><br><span class="line">                <span class="keyword">if</span> (maxRequests &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!killed) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dropStaleRequests &amp;&amp; request.isStale()) &#123;</span><br><span class="line">                            <span class="comment">// Note: this will close the connection</span></span><br><span class="line">                            dropRequest(request);</span><br><span class="line">                            ServerMetrics.getMetrics().STALE_REQUESTS_DROPPED.add(<span class="number">1</span>);</span><br><span class="line">                            request = <span class="literal">null</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 只要没达到最大限制，直接通过</span></span><br><span class="line">                        <span class="keyword">if</span> (zks.getInProcess() &lt; maxRequests) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        throttleSleep(stallTime);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (killed) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// A dropped stale request will be null</span></span><br><span class="line">                <span class="keyword">if</span> (request != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (request.isStale()) &#123;</span><br><span class="line">                        ServerMetrics.getMetrics().STALE_REQUESTS.add(<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">elapsedTime</span> <span class="operator">=</span> Time.currentElapsedTime() - request.requestThrottleQueueTime;</span><br><span class="line">                    ServerMetrics.getMetrics().REQUEST_THROTTLE_QUEUE_TIME.add(elapsedTime);</span><br><span class="line">                    <span class="keyword">if</span> (shouldThrottleOp(request, elapsedTime)) &#123;</span><br><span class="line">                      request.setIsThrottled(<span class="literal">true</span>);</span><br><span class="line">                      ServerMetrics.getMetrics().THROTTLED_OPS.add(<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 验证通过后，提交给 zkServer 处理</span></span><br><span class="line">                    zks.submitRequestNow(request);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;Unexpected interruption&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dropped</span> <span class="operator">=</span> drainQueue();</span><br><span class="line">        LOG.info(<span class="string">&quot;RequestThrottler shutdown. Dropped &#123;&#125; requests&quot;</span>, dropped);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.zookeeper.server.ZooKeeperServer#submitRequestNow</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submitRequestNow</span><span class="params">(Request si)</span> &#123;</span><br><span class="line">        <span class="comment">// 确保处理器链已生成</span></span><br><span class="line">        <span class="keyword">if</span> (firstProcessor == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Since all requests are passed to the request</span></span><br><span class="line">                    <span class="comment">// processor it should wait for setting up the request</span></span><br><span class="line">                    <span class="comment">// processor chain. The state will be updated to RUNNING</span></span><br><span class="line">                    <span class="comment">// after the setup.</span></span><br><span class="line">                    <span class="comment">// 因为所有的请求都被传递给请求处理器，所以应该等待请求处理器链建立完成</span></span><br><span class="line">                    <span class="comment">// 且当请求处理器链建立完成后，状态将更新为 RUNNING</span></span><br><span class="line">                    <span class="keyword">while</span> (state == State.INITIAL) &#123;</span><br><span class="line">                        wait(<span class="number">1000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    LOG.warn(<span class="string">&quot;Unexpected interruption&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (firstProcessor == <span class="literal">null</span> || state != State.RUNNING) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Not started&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 验证 sessionId</span></span><br><span class="line">            touch(si.cnxn);</span><br><span class="line">            <span class="comment">// 验证 Request 是否有效</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">validpacket</span> <span class="operator">=</span> Request.isValid(si.type);</span><br><span class="line">            <span class="keyword">if</span> (validpacket) &#123;</span><br><span class="line">                setLocalSessionFlag(si);</span><br><span class="line">                <span class="comment">// 如果 Request 有效则将其传递给请求处理链（Request Processor Pipeline）的第一个请求处理器</span></span><br><span class="line">                firstProcessor.processRequest(si);</span><br><span class="line">                <span class="keyword">if</span> (si.cnxn != <span class="literal">null</span>) &#123;</span><br><span class="line">                    incInProcess();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOG.warn(<span class="string">&quot;Received packet at server of unknown type &#123;&#125;&quot;</span>, si.type);</span><br><span class="line">                <span class="comment">// Update request accounting/throttling limits</span></span><br><span class="line">                requestFinished(si);</span><br><span class="line">                <span class="comment">// 该请求来自未知类型的客户端</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UnimplementedRequestProcessor</span>().processRequest(si);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MissingSessionException e) &#123;</span><br><span class="line">            LOG.debug(<span class="string">&quot;Dropping request.&quot;</span>, e);</span><br><span class="line">            <span class="comment">// Update request accounting/throttling limits</span></span><br><span class="line">            requestFinished(si);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RequestProcessorException e) &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;Unable to process request&quot;</span>, e);</span><br><span class="line">            <span class="comment">// Update request accounting/throttling limits</span></span><br><span class="line">            requestFinished(si);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>发送Response</p>
<p>因为Zookeeper 中对于请求的处理是采用 Request Processor Pipeline 来完成的，所以对于处理请求后组装并发送响应的工作就是由最后一个 FinalRequestProcessor 来完成的，因此我们下面的源码分析就从 FinalRequestProcessor 的 processRequest 方法开始，该方法的入参为上一个 Request Processor 处理后的 Request 请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.server.FinalRequestProcessor#processRequest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">	<span class="comment">// 因为重点分析发送响应流程，所以省略居多分类别处理请求并生成 hdr 响应头 和 rsp 响应体代码...</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 在上面处理过 Request 请求后将生成的响应头和响应体作为入参调用 sendResponse 方法发送响应</span></span><br><span class="line">		cnxn.sendResponse(hdr, rsp, <span class="string">&quot;response&quot;</span>);</span><br><span class="line">		<span class="comment">// 如果 Request 的类型为 closeSession 则进入关闭逻辑</span></span><br><span class="line">		<span class="keyword">if</span> (request.type == OpCode.closeSession) &#123;</span><br><span class="line">			cnxn.sendCloseSession();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sendResponse</span><span class="params">(ReplyHeader h, Record r, String tag,</span></span><br><span class="line"><span class="params">                        String cacheKey, Stat stat, <span class="type">int</span> opCode)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">// cacheKey and stat are used in caching, which is not</span></span><br><span class="line">  <span class="comment">// implemented here. Implementation example can be found in NIOServerCnxn.</span></span><br><span class="line">  <span class="keyword">if</span> (closingChannel || !channel.isOpen()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 序列化数据</span></span><br><span class="line">  ByteBuffer[] bb = serialize(h, r, tag, cacheKey, stat, opCode);</span><br><span class="line">  <span class="type">int</span> <span class="variable">responseSize</span> <span class="operator">=</span> bb[<span class="number">0</span>].getInt();</span><br><span class="line">  bb[<span class="number">0</span>].rewind();</span><br><span class="line">  <span class="comment">// 发送数据</span></span><br><span class="line">  sendBuffer(bb);</span><br><span class="line">  decrOutstandingAndCheckThrottle(h);</span><br><span class="line">  <span class="keyword">return</span> responseSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendBuffer</span><span class="params">(ByteBuffer... buffers)</span> &#123;</span><br><span class="line">  <span class="comment">// 如果 ByteBuffer 为 closeConn 则调用 close() 进入关闭逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (buffers.length == <span class="number">1</span> &amp;&amp; buffers[<span class="number">0</span>] == ServerCnxnFactory.closeConn) &#123;</span><br><span class="line">    close(DisconnectReason.CLIENT_CLOSED_CONNECTION);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将 ByteBuffer 中的数据写入 Channel 并通过 flush 将其发送    </span></span><br><span class="line">  channel.writeAndFlush(Unpooled.wrappedBuffer(buffers)).addListener(onSendBufferDoneListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="源码总结"><a href="#源码总结" class="headerlink" title="源码总结"></a>源码总结</h2><h3 id="接收请求"><a href="#接收请求" class="headerlink" title="接收请求"></a>接收请求</h3><ol>
<li>服务端从 Netty Channel 的 channelRead 方法接收请求，并通过 NettyServerCnxn 的 processMessage 方法将其转发给当前 Channel 所绑定的 NettyServerCnxn ；</li>
<li>在 NettyServerCnxn 的 processMessage 方法中会进行限流（throttle）处理将请求 Buffer 拷贝到 queuedBuffer 中，然后调用 receiveMessage 方法对请求做进一步处理；</li>
<li>receiveMessage 方法的主要工作就是从传入的 ByteBuf 中读取有效的数据（数据包前 4 byte 记录有效数据的长度），并将其转化为 ByteBuffer 传给 ZooKeeperServer 的 processPacket 进行处理；</li>
<li>在 processPacket 方法中会从 ByteBuffer 中解析出请求头和请求体，并将其封装为 Request 后传给上层的 submitRequest 方法进行处理；</li>
<li>submitRequest 会等待第一个 Request Processor 初始化完成后进行请求的验证工作，然后将验证成功的请求传递给 Request Processor Pipeline 中的第一个 Request Processor 进行处理；</li>
</ol>
<h3 id="发送响应"><a href="#发送响应" class="headerlink" title="发送响应"></a>发送响应</h3><ol>
<li>响应的发送工作是由 Request Processor Pipeline 的最后一个 Request Processor 来完成的，在 FinalRequestProcessor 的 processRequest 方法中会根据请求的类型对传入的请求进行处理，并生成响应头和响应体传给 ServerCnxn 的 sendResponse 方法；</li>
<li>在 sendResponse 方法中会将入参的响应头和响应体组装为一个完整的响应，并将其转换为 ByteBuffer 通过 NettyServerCnxn 的 sendBuffer 方法传给 NettyServerCnxn ；</li>
<li>在 NettyServerCnxn 的 sendBuffer 方法中会进行 ByteBuffer 类型的判断，如果类型为 closeConn 则进入关闭逻辑，否则通过 Channel 的 writeAndFlush 方法将响应发送；</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/12/31/mysql-base/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="tlv">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温故而知新">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/31/mysql-base/" class="post-title-link" itemprop="url">MySQL -- 基础架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-01T00:00:00+08:00">2020-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-11 21:27:38" itemprop="dateModified" datetime="2022-05-11T21:27:38+08:00">2022-05-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Storage/" itemprop="url" rel="index"><span itemprop="name">Storage</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Storage/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>4.4k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><img src="/images/mysql-base/mysql-architecture-20210517110625157.png" alt="img" style="zoom:28%;" />



<ol>
<li>大体上，MySQL可以分为<strong>Server层</strong>和<strong>存储引擎层</strong></li>
<li>Server层包括<strong>连接器、查询缓存、分析器、优化器和执行器</strong>等<ul>
<li>涵盖MySQL的<strong>大多数核心服务功能</strong>，以及<strong>所有的内置函数</strong></li>
<li>所有的<strong>跨存储引擎的功能</strong>都在这一层实现，例如存储过程、触发器和视图等</li>
</ul>
</li>
<li>存储引擎层负责<strong>数据的存储和提取</strong>，架构模式为<strong>插件式</strong><ul>
<li>支持InnoDB、MyISAM和Memory等存储引擎</li>
<li>最常用为<strong>InnoDB</strong>（Since 5.5.5，默认）</li>
</ul>
</li>
</ol>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>连接器负责跟客户端<strong>建立连接、获取权限、维持和管理连接</strong>。命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$host -P$port -u$user -p</span><br></pre></td></tr></table></figure>

<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><ul>
<li>连接命令中的 mysql 是客户端工具，用来跟服务端建立连接</li>
<li>在完成经典的 TCP 握手后，连接器就要开始认证你的身份，使用 <code>-u</code>  <code>-p</code><ul>
<li>如果用户名或密码不对，你就会收到一个**”Access denied for user”**的错误，然后客户端程序结束执行</li>
<li>如果用户名密码认证通过，连接器会到<strong>权限表</strong>里面查出你拥有的权限<ul>
<li>之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限</li>
<li>因此即使用管理员账号对权限进行修改，也<strong>不会影响到已经存在连接的权限</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><ul>
<li>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态<ul>
<li>使用 <code>show processlist;</code> 其中的 Command 列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接</li>
</ul>
</li>
<li>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 <code>wait_timeout</code> 控制的，默认值是 8 小时<ul>
<li>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果要继续，就需要重连，然后再执行请求</li>
</ul>
</li>
<li>数据库<code>长连接</code> 、<code>短连接</code><ul>
<li>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接<ul>
<li>建立连接的过程通常是比较复杂的，所以建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接</li>
</ul>
</li>
<li>短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个</li>
</ul>
</li>
<li>全部使用长连接后，可能会导致 MySQL 占用内存涨得特别快<ul>
<li>原因： MySQL 在执行过程中临时使用的<strong>内存是管理在连接对象里面的</strong>。这些资源会在<strong>连接断开的时候才释放</strong>。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</li>
<li>解决方法：<ul>
<li>定期断开长连接，使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li>
<li>MySQL 5.7 或更新版本，可以在每次执行比较大的操作后，通过执行 <code>mysql_reset_connection</code> 来重新<strong>初始化连接资源</strong><ul>
<li>这个过程<strong>不需要重连和重新做权限验证</strong></li>
<li>会将连接恢复到刚刚创建完时的状态</li>
</ul>
<strong>注：mysql_reset_connection是mysql为各个编程语言提供的api，不是sql语句</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show processlist;</span><br><span class="line">+----+------+------------------+-------+---------+------+----------+------------------+</span><br><span class="line">| Id | User | Host             | db    | Command | Time | State    | Info             |</span><br><span class="line">+----+------+------------------+-------+---------+------+----------+------------------+</span><br><span class="line">|  2 | root | localhost        | NULL  | Query   |    0 | starting | show processlist |</span><br><span class="line">|  3 | root | 172.17.0.1:33260 | mysql | Sleep   |    4 |          | NULL             |</span><br><span class="line">|  4 | root | 172.17.0.1:33262 | mysql | Sleep   |    4 |          | NULL             |</span><br><span class="line">+----+------+------------------+-------+---------+------+----------+------------------+</span><br><span class="line"></span><br><span class="line"># MySQL各timeout参数</span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;%timeout%&#x27;;</span><br><span class="line">+-----------------------------+----------+</span><br><span class="line">| Variable_name               | Value    |</span><br><span class="line">+-----------------------------+----------+</span><br><span class="line">| connect_timeout             | 10       |</span><br><span class="line">| delayed_insert_timeout      | 300      |</span><br><span class="line">| have_statement_timeout      | YES      |</span><br><span class="line">| innodb_flush_log_at_timeout | 1        |</span><br><span class="line">| innodb_lock_wait_timeout    | 50       |</span><br><span class="line">| innodb_rollback_on_timeout  | OFF      |</span><br><span class="line">| interactive_timeout         | 28800    |</span><br><span class="line">| lock_wait_timeout           | 31536000 |</span><br><span class="line">| net_read_timeout            | 30       |</span><br><span class="line">| net_write_timeout           | 60       |</span><br><span class="line">| rpl_stop_slave_timeout      | 31536000 |</span><br><span class="line">| slave_net_timeout           | 60       |</span><br><span class="line">| wait_timeout                | 28800    |</span><br><span class="line">+-----------------------------+----------+</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th align="left">参数名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">connect_timeout</td>
<td>该参数控制与服务器建立连接的时候等待三次握手成功的超时时间，该参数主要是对于网络质量较差导致连接超时，建议外网访问波动较大可以提高该参数。</td>
</tr>
<tr>
<td align="left">delayed_insert_timeout</td>
<td>指INSERT语句执行的超时时间。</td>
</tr>
<tr>
<td align="left">innodb_lock_wait_timeout</td>
<td>指锁等待的超时时间，该锁不同于死锁是指正常一个事务等待另外一个事务的S锁或者X锁的超时时间。</td>
</tr>
<tr>
<td align="left">innodb_rollback_on_timeout</td>
<td>当事务超时超过该参数后即会回滚，如果设置为OFF即只回滚事务的最后一个请求。</td>
</tr>
<tr>
<td align="left">interactive_timeout<br />wait_timeout</td>
<td>mysql在关闭一个交互式/非交互式的连接之前所要等待的时间。建议不需要设置太长的时候，否则会占用实例的连接数资源。</td>
</tr>
<tr>
<td align="left">lock_wait_timeout</td>
<td>指定尝试获取元数据锁的超时时间。</td>
</tr>
<tr>
<td align="left">net_read_timeout<br />net_write_timeout</td>
<td>指服务器端等待客户端发送的网络包和发送给客户端网络包的超时时间，这两个参数是对TCP/IP链接并且是Activity状态下的线程才有效的参数。</td>
</tr>
<tr>
<td align="left">slave_net_timeout</td>
<td>备实例等待主服务器同步的超时时间，超时后中止同步并尝试重新连接。</td>
</tr>
</tbody></table>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><ul>
<li>MySQL 拿到一个查询请求后，会先到查询缓存</li>
<li>之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中<ul>
<li>key: 查询语句</li>
<li>value: 查询结果</li>
</ul>
</li>
<li>如果根据key(查询条件)命中缓存，直接返回对应的Value</li>
<li>否则就会继续后面的执行阶段，执行完成后，执行结果会被存入查询缓存中</li>
<li><strong>使用缓存弊大于利</strong><ul>
<li><strong>查询缓存的失效非常频繁</strong>，只要有对一个表的更新，这个表上所有的查询缓存都会被清空</li>
<li>查询缓存的命中率会非常低</li>
<li>查询缓存适用于读多写少的场景，比如静态配置表</li>
</ul>
</li>
<li>query_cache_type<ul>
<li>A value of 0 or <strong>OFF</strong> prevents caching or retrieval of cached results</li>
<li>A value of 1 or <strong>ON</strong> enables caching except of those statements that begin with <strong>SELECT SQL_NO_CACHE</strong></li>
<li>A value of 2 or <strong>DEMAND</strong> causes caching of only those statements that begin with <strong>SELECT SQL_CACHE</strong></li>
</ul>
</li>
<li>可以将参数 query_cache_type 设置成 DEMAND，默认的 SQL 语句都不使用查询缓存<br>对于确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> SQL_CACHE <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>；</span><br></pre></td></tr></table></figure></li>
<li><strong>MySQL 8.0 版本删除了查询缓存功能</strong></li>
</ul>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>分析器先会做<strong>词法分析</strong><ul>
<li>MySQL 需要识别出里面的字符串分别是什么，代表什么</li>
<li>通过<strong>select</strong>识别是查询语句</li>
<li>将字符串<strong>T</strong>识别成表，字符串<strong>ID</strong>识别成列</li>
</ul>
</li>
<li>分析器再做<strong>语法分析</strong><ul>
<li>根据词法分析的结果，语法分析会根据<strong>语法规则</strong>，判断SQL是否满足MySQL语法</li>
<li>如果不满足，将会收到错误<code>You have an error in your SQL syntax</code>错误</li>
</ul>
</li>
</ul>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><ul>
<li>经过<strong>分析器</strong>，MySQL已经能理解要<strong>做什么</strong>，在开始执行之前，需要经过<strong>优化器</strong>的处理，达到<strong>怎么做</strong></li>
<li>优化器会在表里存在多个索引的时候，选择使用哪个索引</li>
<li>优化器也会在多表关联的时候，决定各个表的连接顺序</li>
<li>优化器阶段完成后，语句的<strong>执行方案</strong>就已经能确定下来了，然后进入执行器阶段</li>
</ul>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><ul>
<li>MySQL通过<strong>分析器</strong>能明白<strong>做什么</strong>，再通过<strong>优化器</strong>能明白<strong>怎么做</strong>，而<strong>执行器</strong>是负责语句的<strong>具体执行</strong></li>
<li>首先会判断是否有执行权限，如果没有就会返回权限错误，<strong>SELECT command denied to user</strong><ul>
<li>如果命中查询缓存，也会在查询缓存<strong>返回</strong>结果的时候，做权限验证</li>
<li>优化器之前也会调用<strong>precheck</strong>做验证权限</li>
</ul>
</li>
<li>如果有权限，那么将打开表继续执行<ul>
<li>打开表的时候，执行器会根据表的引擎定义，去<strong>调用引擎提供的接口</strong></li>
</ul>
</li>
<li>假设表T中，ID字段没有索引，执行器的执行流程如下<ul>
<li>调用InnoDB的引擎接口，获取表的第一行，判断ID是否为10<ul>
<li>如果不是则跳过，如果是则将这行存放在结果集中</li>
</ul>
</li>
<li>调用引擎接口获取下一行，重复上面的判断逻辑，直到获取到表的最后一行</li>
<li>执行器将上面遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端</li>
</ul>
</li>
<li>rows_examined<ul>
<li>数据库的慢查询日志会有<code>rows_examined</code>字段</li>
<li>在执行器每次调用引擎获取数据行的时候<strong>累加</strong>的（+1）</li>
<li>有些场景，执行器调用一次，但在引擎内部则是扫描了很多行<ul>
<li>例如在InnoDB中，<strong>一页有很多行数据</strong></li>
</ul>
</li>
<li>因此，<strong>引擎扫描行数（引擎内部真正扫描的次数）跟rows_examined并不完全相同</strong></li>
</ul>
</li>
</ul>
<h3 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果表 T 中没有字段 k，而你执行了这个语句 select * from T where k=1, </span><br><span class="line">那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。</span><br><span class="line">你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？</span><br></pre></td></tr></table></figure>
<p><strong>分析器</strong></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《MySQL实战45讲》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/12/31/zk-source-build/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="tlv">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温故而知新">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/31/zk-source-build/" class="post-title-link" itemprop="url">Zookeeper -- 客户端源码解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-01T00:00:00+08:00">2020-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-11 21:27:38" itemprop="dateModified" datetime="2022-05-11T21:27:38+08:00">2022-05-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Distributed/" itemprop="url" rel="index"><span itemprop="name">Distributed</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Distributed/Zookeeper/" itemprop="url" rel="index"><span itemprop="name">Zookeeper</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>37k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>34 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="客户端结构解析"><a href="#客户端结构解析" class="headerlink" title="客户端结构解析"></a>客户端结构解析</h2><h3 id="客户端结构图"><a href="#客户端结构图" class="headerlink" title="客户端结构图"></a>客户端结构图</h3><img src="/images/zk-source-build/20161104212932485.jpeg" alt="Zookeeper Client" style="zoom:80%;" />



<h3 id="客户端核心类"><a href="#客户端核心类" class="headerlink" title="客户端核心类"></a>客户端核心类</h3><p>zk客户端的核心组件如下：</p>
<ul>
<li>ZooKeeper实例 ：客户端入口</li>
<li>ClientWatcherManager ：客户端Watcher管理器</li>
<li>HostProvider：客户端地址列表管理器</li>
<li>ClientCnxn：客户端核心线程。包含两个线程，即SendThread和EventThread。前者是一个I/O线程，主要负责ZooKeeper客户端和服务端之间的网络I/O通信，后者是一个事件线程，主要负责对服务端事件进行处理。</li>
<li>ClientCnxnSocket：底层Socket通信层，有两个实现ClientCnxnSocketNetty、ClientCnxnSocketNIO</li>
</ul>
<p><img src="/images/zk-source-build/ef78b098db54fbec2d979e0e7edc23fe276181.png" alt="img"></p>
<h2 id="客户端启动流程"><a href="#客户端启动流程" class="headerlink" title="客户端启动流程"></a>客户端启动流程</h2><p>Zookeeper客户端初始化与启动环节，就是Zookeeper对象的实例化过程</p>
<ul>
<li>初始化 ZooKeeper 对象<ul>
<li>通过调用 ZooKeeper 的构造方法来实例化一个 ZooKeeper 对象，在初始化过程中， 会创建一个客户端的 Watcher 管理器： ClientWatchManager</li>
</ul>
</li>
<li>设置默认Watcher<ul>
<li>若在Zookeeper构造方法中传入Watcher对象时，那么Zookeeper就会将该Watcher对象保存在ZKWatcherManager的defaultWatcher中，并作为整个客户端会话期间的默认Watcher</li>
</ul>
</li>
<li>设置Zookeeper服务器地址列表<ul>
<li>对于构造方法中传入的服务器地址，客户端会将其存放在服务器地址列表管理器HostProvider 中</li>
<li>默认使用StaticHostProvider解析服务端地址<ul>
<li>Chroot：每个客户端可以设置自己的命名空间，若客户端设置了Chroot，客户端对服务器的任何操作都将被限制在自己的命名空间下，如设置Choot为/app/X，那么该客户端的所有节点路径都是以/app/X为根节点</li>
<li>StaticHostProvider将InetSocketAddress列表进行shuffle，形成一个环形循环队列，然后再依次取出服务器地址</li>
</ul>
</li>
</ul>
</li>
<li>创建ClientCnxn<ul>
<li>ZooKeeper 客户端首先会创建一个网络连接器 ClientCnxn, 用来管理客户端与服务器的网络交互。</li>
<li>初始化客户端两个核心队列 outgoingQueue 和 pendingQueue, 分别作为客户端的请求 发送队列和服务端响应的等待队列。ClientCnxn 连接器的底层 I/O 处理器是 ClientCnxnSocket,因此在这一步中，客户端还会同时创建 ClientCnxnSocket 处理器</li>
</ul>
</li>
</ul>
<p>启动流程图如下：</p>
<p><img src="/images/zk-source-build/b3110ff83e94e0680dc5a266ffa6f603193666.png" alt="img"></p>
<h2 id="会话创建阶段"><a href="#会话创建阶段" class="headerlink" title="会话创建阶段"></a>会话创建阶段</h2><ul>
<li>启动 SendThread 、EventThread</li>
<li>获取一个服务器地址<ul>
<li>serverAddress = hostProvider.next(1000);</li>
</ul>
</li>
<li>创建TCP连接<ul>
<li>org.apache.zookeeper.ClientCnxnSocket#connect</li>
</ul>
</li>
<li>构造ConnectRequest请求：以ClientCnxnSocketNetty为例，operationComplete中执行sendThread.primeConnection()，构造出一个ConnectRequest请求，该请求代表了客户端试图与服务端创建一个会话。同时，ZooKeeper客户端还会进一步将该请求包装成网络I/O层的Packet对象，放入请求发送队列outgoingQueue中去</li>
<li>发送请求：ClientCnxnSocket负责从outgoingQueue中取出一个待发送的Packet对象，将其序列化成ByteBuffer向服务端进行发送</li>
</ul>
<h3 id="客户端网络协议"><a href="#客户端网络协议" class="headerlink" title="客户端网络协议"></a>客户端网络协议</h3><h4 id="TCP自定义协议栈"><a href="#TCP自定义协议栈" class="headerlink" title="TCP自定义协议栈"></a>TCP自定义协议栈</h4><p>基于TCP/IP协议，Zookeeper实现了自己的通信协议来玩按成客户端与服务端、服务端与服务端之间的网络通信，对于请求，主要包含请求头和请求体，对于响应，主要包含响应头和响应体</p>
<table>
<thead>
<tr>
<th>len</th>
<th>请求头</th>
<th>请求体</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th>len</th>
<th>响应头</th>
<th>响应体</th>
</tr>
</thead>
</table>
<ul>
<li><p>请求协议</p>
<p><img src="/images/zk-source-build//image-20210926101915851.png" alt="image-20210926101915851"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RequestHeader</span> &#123;</span><br><span class="line">	<span class="type">int</span> xid;</span><br><span class="line">  <span class="type">int</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RequestHeader包含 <strong>xid</strong>、<strong>type</strong></p>
<ul>
<li> xid ：代表请求的顺序号，用于保证请求的顺序发送和接收</li>
<li>而 type 代表请求的类型</li>
</ul>
</li>
<li><p>响应协议</p>
<p><img src="/images/zk-source-build//image-20210926104109116.png" alt="image-20210926104109116"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReplyHeader</span> &#123;</span><br><span class="line">	<span class="type">int</span> xid;</span><br><span class="line">  <span class="type">long</span> zxid;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReplyHeader 主要包括 <strong>xid</strong> 和 <strong>zxid</strong> 以及 <strong>err</strong> </p>
<ul>
<li>xid：与请求头中的xid一致</li>
<li>zxid：表示分布事务 id ，为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数</li>
<li>err：是一个错误码，表示当请求处理过程出现异常情况时，就会在错误码中标识出来，常见的包括处理成功（Code.OK）、节点不存在（Code.NONODE）、没有权限（Code.NOAUTH）</li>
</ul>
</li>
</ul>
<h4 id="Packet协议"><a href="#Packet协议" class="headerlink" title="Packet协议"></a>Packet协议</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Packet</span> &#123;</span><br><span class="line">	RequestHeader requestHeader;	<span class="comment">// 请求头信息</span></span><br><span class="line">	ReplyHeader replyHeader;		<span class="comment">// 响应头信息</span></span><br><span class="line"></span><br><span class="line">	Record request;		<span class="comment">// 请求数据</span></span><br><span class="line">	Record response;	<span class="comment">// 响应数据</span></span><br><span class="line"></span><br><span class="line">	AsyncCallback cb;	<span class="comment">// 异步回调</span></span><br><span class="line">  Object ctx;			<span class="comment">// 异步回调所需使用的 context</span></span><br><span class="line"></span><br><span class="line">	String clientPath;	<span class="comment">// 客户端路径视图</span></span><br><span class="line">  String serverPath;	<span class="comment">// 服务器的路径视图</span></span><br><span class="line">	<span class="type">boolean</span> finished;	<span class="comment">// 是否已经处理完成</span></span><br><span class="line">    </span><br><span class="line">  ByteBuffer bb;		</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> readOnly;</span><br><span class="line">  WatchRegistration watchRegistration;</span><br><span class="line">  WatchDeregistration watchDeregistration;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 省略方法逻辑..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="核心源码解析"><a href="#核心源码解析" class="headerlink" title="核心源码解析"></a>核心源码解析</h2><ol>
<li><p>建立网络连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ZooKeeper#ZooKeeper(java.lang.String, int, org.apache.zookeeper.Watcher, boolean, org.apache.zookeeper.client.HostProvider, org.apache.zookeeper.client.ZKClientConfig)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ZooKeeper</span><span class="params">(</span></span><br><span class="line"><span class="params">        String connectString,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> sessionTimeout,</span></span><br><span class="line"><span class="params">        Watcher watcher,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> canBeReadOnly,</span></span><br><span class="line"><span class="params">        HostProvider hostProvider,</span></span><br><span class="line"><span class="params">        ZKClientConfig clientConfig</span></span><br><span class="line"><span class="params">    )</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        LOG.info(</span><br><span class="line">            <span class="string">&quot;Initiating client connection, connectString=&#123;&#125; sessionTimeout=&#123;&#125; watcher=&#123;&#125;&quot;</span>,</span><br><span class="line">            connectString,</span><br><span class="line">            sessionTimeout,</span><br><span class="line">            watcher);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.clientConfig = clientConfig != <span class="literal">null</span> ? clientConfig : <span class="keyword">new</span> <span class="title class_">ZKClientConfig</span>();</span><br><span class="line">        <span class="built_in">this</span>.hostProvider = hostProvider;</span><br><span class="line">        <span class="type">ConnectStringParser</span> <span class="variable">connectStringParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectStringParser</span>(connectString);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接管理器</span></span><br><span class="line">        cnxn = createConnection(</span><br><span class="line">            connectStringParser.getChrootPath(),</span><br><span class="line">            hostProvider,</span><br><span class="line">            sessionTimeout,</span><br><span class="line">            <span class="built_in">this</span>.clientConfig,</span><br><span class="line">            watcher,</span><br><span class="line">            getClientCnxnSocket(),</span><br><span class="line">            canBeReadOnly);</span><br><span class="line">        cnxn.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先建立一个 Zookeeper 客户端时需要创建一个 Zookeeper 对象，且在这个 Zookeeper 对象创建的过程中会创建一个客户端连接管理器（ClientCnxn），接着在创建 ClientCnxn 的过程中又需要创建一个 ClientCnxnSocket 用于实现客户端间的通信，跟进这个 getClientCnxnSocket 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ZooKeeper#getClientCnxnSocket</span></span><br><span class="line"><span class="keyword">private</span> ClientCnxnSocket <span class="title function_">getClientCnxnSocket</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 从配置文件中获取 ClientCnxnSocket 配置信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">clientCnxnSocketName</span> <span class="operator">=</span> getClientConfig().getProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);</span><br><span class="line">        <span class="comment">// 如果配置文件中没有提供 ClientCnxnSocket 配置信息 或者 配置信息为ClientCnxnSocketNIO 则默认使用 NIO</span></span><br><span class="line">        <span class="keyword">if</span> (clientCnxnSocketName == <span class="literal">null</span> || clientCnxnSocketName.equals(ClientCnxnSocketNIO.class.getSimpleName())) &#123;</span><br><span class="line">            clientCnxnSocketName = ClientCnxnSocketNIO.class.getName();</span><br><span class="line">        <span class="comment">// 如果配置信息为ClientCnxnSocketNetty 则使用 Netty</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clientCnxnSocketName.equals(ClientCnxnSocketNetty.class.getSimpleName())) &#123;</span><br><span class="line">            clientCnxnSocketName = ClientCnxnSocketNetty.class.getName();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过反射获取 ClientCnxnSocket 的构造方法</span></span><br><span class="line">            Constructor&lt;?&gt; clientCxnConstructor = Class.forName(clientCnxnSocketName)</span><br><span class="line">                                                       .getDeclaredConstructor(ZKClientConfig.class);</span><br><span class="line">            <span class="comment">// 通过以客户端配置为入参调用构造方法来创建一个 ClientCnxnSocket 实例</span></span><br><span class="line">            <span class="type">ClientCnxnSocket</span> <span class="variable">clientCxnSocket</span> <span class="operator">=</span> (ClientCnxnSocket) clientCxnConstructor.newInstance(getClientConfig());</span><br><span class="line">            <span class="keyword">return</span> clientCxnSocket;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Couldn&#x27;t instantiate &quot;</span> + clientCnxnSocketName, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>getClientCnxnSocket 方法中会选择 ClientCnxnSocket 的实现方式，目前的 Zookeeper 中存在两个实现版本，一个是使用 Java JDK 中的 NIO 实现的 ClientCnxnSocketNIO ，另一个是使用 Netty 实现的 ClientCnxnSocketNetty ，而选择的方式优先根据配置文件中的配置进行选择，如果没有进行配置则默认选择 ClientCnxnSocketNIO 实现版本，之后再通过反射的方式创建其实例对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxnSocketNetty#ClientCnxnSocketNetty</span></span><br><span class="line">ClientCnxnSocketNetty(ZKClientConfig clientConfig) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.clientConfig = clientConfig;</span><br><span class="line">        <span class="comment">// Client only has 1 outgoing socket, so the event loop group only needs</span></span><br><span class="line">        <span class="comment">// a single thread.</span></span><br><span class="line">  			<span class="comment">// 创建一个 eventLoopGroup 用于后面对异步请求的处理</span></span><br><span class="line">        <span class="comment">// 且因为客户端只有一个 outgoing Socket 因此只需要一个线程即可</span></span><br><span class="line">        eventLoopGroup = NettyUtils.newNioOrEpollEventLoopGroup(<span class="number">1</span> <span class="comment">/* nThreads */</span>);</span><br><span class="line">        initProperties();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.common.NettyUtils#newNioOrEpollEventLoopGroup(int)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> EventLoopGroup <span class="title function_">newNioOrEpollEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 Epoll 可用（ Linux ）则优先使用 EpollEventLoopGroup 否则使用 NioEventLoopGroup</span></span><br><span class="line">        <span class="keyword">if</span> (Epoll.isAvailable()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EpollEventLoopGroup</span>(nThreads);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(nThreads);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以 Netty 实现为准，所以选择 ClientCnxnSocketNetty 实现版本，在 ClientCnxnSocketNetty 的构造方法中会选择具体的 EventLoopGroup 的实现，如果是在 Linux 优先选择使用性能更高的 EpollEventLoopGroup 实现，且这里配置的线程数目为一，因此这是典型的单线程Reactor实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ZooKeeper#createConnection</span></span><br><span class="line">ClientCnxn <span class="title function_">createConnection</span><span class="params">(</span></span><br><span class="line"><span class="params">        String chrootPath,</span></span><br><span class="line"><span class="params">        HostProvider hostProvider,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> sessionTimeout,</span></span><br><span class="line"><span class="params">        ZKClientConfig clientConfig,</span></span><br><span class="line"><span class="params">        Watcher defaultWatcher,</span></span><br><span class="line"><span class="params">        ClientCnxnSocket clientCnxnSocket,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> canBeReadOnly</span></span><br><span class="line"><span class="params">    )</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientCnxn</span>(</span><br><span class="line">            chrootPath,</span><br><span class="line">            hostProvider,</span><br><span class="line">            sessionTimeout,</span><br><span class="line">            clientConfig,</span><br><span class="line">            defaultWatcher,</span><br><span class="line">            clientCnxnSocket,</span><br><span class="line">            canBeReadOnly);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxn#ClientCnxn(java.lang.String, org.apache.zookeeper.client.HostProvider, int, org.apache.zookeeper.client.ZKClientConfig, org.apache.zookeeper.Watcher, org.apache.zookeeper.ClientCnxnSocket, long, byte[], boolean)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ClientCnxn</span><span class="params">(</span></span><br><span class="line"><span class="params">        String chrootPath,</span></span><br><span class="line"><span class="params">        HostProvider hostProvider,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> sessionTimeout,</span></span><br><span class="line"><span class="params">        ZKClientConfig clientConfig,</span></span><br><span class="line"><span class="params">        Watcher defaultWatcher,</span></span><br><span class="line"><span class="params">        ClientCnxnSocket clientCnxnSocket,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> sessionId,</span></span><br><span class="line"><span class="params">        <span class="type">byte</span>[] sessionPasswd,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> canBeReadOnly</span></span><br><span class="line"><span class="params">    )</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.chrootPath = chrootPath;</span><br><span class="line">        <span class="built_in">this</span>.hostProvider = hostProvider;</span><br><span class="line">        <span class="built_in">this</span>.sessionTimeout = sessionTimeout;</span><br><span class="line">        <span class="built_in">this</span>.clientConfig = clientConfig;</span><br><span class="line">        <span class="built_in">this</span>.sessionId = sessionId;</span><br><span class="line">        <span class="built_in">this</span>.sessionPasswd = sessionPasswd;</span><br><span class="line">        <span class="built_in">this</span>.readOnly = canBeReadOnly;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.watchManager = <span class="keyword">new</span> <span class="title class_">ZKWatchManager</span>(</span><br><span class="line">                clientConfig.getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET),</span><br><span class="line">                defaultWatcher);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.connectTimeout = sessionTimeout / hostProvider.size();</span><br><span class="line">        <span class="built_in">this</span>.readTimeout = sessionTimeout * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化SendThread，管理客户端和服务端之间的网络I/O，依赖于clientCnxnSocket，守护线程</span></span><br><span class="line">        <span class="built_in">this</span>.sendThread = <span class="keyword">new</span> <span class="title class_">SendThread</span>(clientCnxnSocket);</span><br><span class="line">        <span class="comment">// 初始化EventThread，用于事件处理，会被设置为守护线程</span></span><br><span class="line">        <span class="built_in">this</span>.eventThread = <span class="keyword">new</span> <span class="title class_">EventThread</span>();</span><br><span class="line">        <span class="comment">// 初始化超时机制</span></span><br><span class="line">        initRequestTimeout();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>经过getClientCnxnSocket，继续看Zookeeper 构造方法中的createConnection方法，本质上是创建了一个ClientCnxn对象，并在 ClientCnxn 的构造方法中创建了 SendThread 发送线程和 EventThread 事件处理线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxn#start</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 启动sendThread、eventThread</span></span><br><span class="line">        sendThread.start();</span><br><span class="line">        eventThread.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当完成 SendThread 和 EventThread 这两个线程的创建和初始化后，在 Zookeeper 的构造方法中最后会通过 cnxn.start() 方法启动这两个线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxn.SendThread#run</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 设置clientCnxnSocket相关属性，sessionId用于 Log and Exception messages</span></span><br><span class="line">            clientCnxnSocket.introduce(<span class="built_in">this</span>, sessionId, outgoingQueue);</span><br><span class="line">            <span class="comment">//初始化当前时间 now = Time.currentElapsedTime() = System.nanoTime() / 1000000;</span></span><br><span class="line">            clientCnxnSocket.updateNow();</span><br><span class="line">            <span class="comment">// 更新发信、收信时间 this.lastSend = now;this.lastHeard = now;</span></span><br><span class="line">            clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">            <span class="type">int</span> to;</span><br><span class="line">            <span class="comment">// 最后ping读写时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">lastPingRwServer</span> <span class="operator">=</span> Time.currentElapsedTime();</span><br><span class="line">            <span class="comment">// 最大send ping时间间隔 10S</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SEND_PING_INTERVAL</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">//10 seconds</span></span><br><span class="line">            <span class="type">InetSocketAddress</span> <span class="variable">serverAddress</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// state != CLOSED &amp;&amp; state != AUTH_FAILED</span></span><br><span class="line">            <span class="keyword">while</span> (state.isAlive()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// clientCnxnSocket 没有连接到服务端</span></span><br><span class="line">                    <span class="keyword">if</span> (!clientCnxnSocket.isConnected()) &#123;</span><br><span class="line">                        <span class="comment">// don&#x27;t re-establish connection if we are closing</span></span><br><span class="line">                        <span class="keyword">if</span> (closing) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果读写服务器地址不为空，用读写服务器地址</span></span><br><span class="line">                        <span class="keyword">if</span> (rwServerAddress != <span class="literal">null</span>) &#123;</span><br><span class="line">                            serverAddress = rwServerAddress;</span><br><span class="line">                            rwServerAddress = <span class="literal">null</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 挨个访问服务器地址列表里的地址，间隔 1 s</span></span><br><span class="line">                            serverAddress = hostProvider.next(<span class="number">1000</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        onConnecting(serverAddress);</span><br><span class="line">                        <span class="comment">// 开始连接</span></span><br><span class="line">                        startConnect(serverAddress);</span><br><span class="line">                        <span class="comment">// Update now to start the connection timer right after we make a connection attempt</span></span><br><span class="line">                        clientCnxnSocket.updateNow();</span><br><span class="line">                        <span class="comment">// 更新Socket最后一次发送以及接收消息的时间</span></span><br><span class="line">                        clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (state.isConnected()) &#123;</span><br><span class="line">                        <span class="comment">// determine whether we need to send an AuthFailed event.</span></span><br><span class="line">                        <span class="keyword">if</span> (zooKeeperSaslClient != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="type">boolean</span> <span class="variable">sendAuthEvent</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.INITIAL) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    zooKeeperSaslClient.initialize(ClientCnxn.<span class="built_in">this</span>);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (SaslException e) &#123;</span><br><span class="line">                                    LOG.error(<span class="string">&quot;SASL authentication with Zookeeper Quorum member failed.&quot;</span>, e);</span><br><span class="line">                                    changeZkState(States.AUTH_FAILED);</span><br><span class="line">                                    sendAuthEvent = <span class="literal">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="type">KeeperState</span> <span class="variable">authState</span> <span class="operator">=</span> zooKeeperSaslClient.getKeeperState();</span><br><span class="line">                            <span class="keyword">if</span> (authState != <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (authState == KeeperState.AuthFailed) &#123;</span><br><span class="line">                                    <span class="comment">// An authentication error occurred during authentication with the Zookeeper Server.</span></span><br><span class="line">                                    changeZkState(States.AUTH_FAILED);</span><br><span class="line">                                    sendAuthEvent = <span class="literal">true</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (authState == KeeperState.SaslAuthenticated) &#123;</span><br><span class="line">                                        sendAuthEvent = <span class="literal">true</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (sendAuthEvent) &#123;</span><br><span class="line">                                eventThread.queueEvent(<span class="keyword">new</span> <span class="title class_">WatchedEvent</span>(Watcher.Event.EventType.None, authState, <span class="literal">null</span>));</span><br><span class="line">                                <span class="keyword">if</span> (state == States.AUTH_FAILED) &#123;</span><br><span class="line">                                    eventThread.queueEventOfDeath();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        to = readTimeout - clientCnxnSocket.getIdleRecv();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        to = connectTimeout - clientCnxnSocket.getIdleRecv();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 连接超时</span></span><br><span class="line">                    <span class="keyword">if</span> (to &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">warnInfo</span> <span class="operator">=</span> String.format(</span><br><span class="line">                            <span class="string">&quot;Client session timed out, have not heard from server in %dms for session id 0x%s&quot;</span>,</span><br><span class="line">                            clientCnxnSocket.getIdleRecv(),</span><br><span class="line">                            Long.toHexString(sessionId));</span><br><span class="line">                        LOG.warn(warnInfo);</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SessionTimeoutException</span>(warnInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (state.isConnected()) &#123;</span><br><span class="line">                        <span class="comment">//1000(1 second) is to prevent race condition missing to send the second ping</span></span><br><span class="line">                        <span class="comment">//also make sure not to send too many pings when readTimeout is small</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">timeToNextPing</span> <span class="operator">=</span> readTimeout / <span class="number">2</span></span><br><span class="line">                                             - clientCnxnSocket.getIdleSend()</span><br><span class="line">                                             - ((clientCnxnSocket.getIdleSend() &gt; <span class="number">1000</span>) ? <span class="number">1000</span> : <span class="number">0</span>);</span><br><span class="line">                        <span class="comment">//send a ping request either time is due or no packet sent out within MAX_SEND_PING_INTERVAL</span></span><br><span class="line">                        <span class="keyword">if</span> (timeToNextPing &lt;= <span class="number">0</span> || clientCnxnSocket.getIdleSend() &gt; MAX_SEND_PING_INTERVAL) &#123;</span><br><span class="line">                            sendPing();</span><br><span class="line">                            clientCnxnSocket.updateLastSend();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (timeToNextPing &lt; to) &#123;</span><br><span class="line">                                to = timeToNextPing;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// If we are in read-only mode, seek for read/write server</span></span><br><span class="line">                    <span class="keyword">if</span> (state == States.CONNECTEDREADONLY) &#123;</span><br><span class="line">                        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> Time.currentElapsedTime();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">idlePingRwServer</span> <span class="operator">=</span> (<span class="type">int</span>) (now - lastPingRwServer);</span><br><span class="line">                        <span class="keyword">if</span> (idlePingRwServer &gt;= pingRwTimeout) &#123;</span><br><span class="line">                            lastPingRwServer = now;</span><br><span class="line">                            idlePingRwServer = <span class="number">0</span>;</span><br><span class="line">                            pingRwTimeout = Math.min(<span class="number">2</span> * pingRwTimeout, maxPingRwTimeout);</span><br><span class="line">                            pingRwServer();</span><br><span class="line">                        &#125;</span><br><span class="line">                        to = Math.min(to, pingRwTimeout - idlePingRwServer);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 处理真正的 I/O 操作</span></span><br><span class="line">                    clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.<span class="built_in">this</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (closing) &#123;</span><br><span class="line">                        <span class="comment">// closing so this is expected</span></span><br><span class="line">                        LOG.warn(</span><br><span class="line">                            <span class="string">&quot;An exception was thrown while closing send thread for session 0x&#123;&#125;.&quot;</span>,</span><br><span class="line">                            Long.toHexString(getSessionId()),</span><br><span class="line">                            e);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        LOG.warn(</span><br><span class="line">                            <span class="string">&quot;Session 0x&#123;&#125; for sever &#123;&#125;, Closing socket connection. &quot;</span></span><br><span class="line">                                + <span class="string">&quot;Attempting reconnect except it is a SessionExpiredException.&quot;</span>,</span><br><span class="line">                            Long.toHexString(getSessionId()),</span><br><span class="line">                            serverAddress,</span><br><span class="line">                            e);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// At this point, there might still be new packets appended to outgoingQueue.</span></span><br><span class="line">                        <span class="comment">// they will be handled in next connection or cleared up if closed.</span></span><br><span class="line">                        cleanAndNotifyState();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">                <span class="comment">// When it comes to this point, it guarantees that later queued</span></span><br><span class="line">                <span class="comment">// packet to outgoingQueue will be notified of death.</span></span><br><span class="line">                cleanup();</span><br><span class="line">            &#125;</span><br><span class="line">            clientCnxnSocket.close();</span><br><span class="line">            <span class="keyword">if</span> (state.isAlive()) &#123;</span><br><span class="line">                eventThread.queueEvent(<span class="keyword">new</span> <span class="title class_">WatchedEvent</span>(Event.EventType.None, Event.KeeperState.Disconnected, <span class="literal">null</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            eventThread.queueEvent(<span class="keyword">new</span> <span class="title class_">WatchedEvent</span>(Event.EventType.None, Event.KeeperState.Closed, <span class="literal">null</span>));</span><br><span class="line">            ZooTrace.logTraceMessage(</span><br><span class="line">                LOG,</span><br><span class="line">                ZooTrace.getTextTraceLevel(),</span><br><span class="line">                <span class="string">&quot;SendThread exited loop for session: 0x&quot;</span> + Long.toHexString(getSessionId()));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxn.SendThread#startConnect</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startConnect</span><span class="params">(InetSocketAddress addr)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">// initializing it for new connection</span></span><br><span class="line">            saslLoginFailed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!isFirstConnect) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(ThreadLocalRandom.current().nextLong(<span class="number">1000</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置状态为 CONNECTING</span></span><br><span class="line">            changeZkState(States.CONNECTING);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">hostPort</span> <span class="operator">=</span> addr.getHostString() + <span class="string">&quot;:&quot;</span> + addr.getPort();</span><br><span class="line">            MDC.put(<span class="string">&quot;myid&quot;</span>, hostPort);</span><br><span class="line">            setName(getName().replaceAll(<span class="string">&quot;\\(.*\\)&quot;</span>, <span class="string">&quot;(&quot;</span> + hostPort + <span class="string">&quot;)&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (clientConfig.isSaslClientEnabled()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (zooKeeperSaslClient != <span class="literal">null</span>) &#123;</span><br><span class="line">                        zooKeeperSaslClient.shutdown();</span><br><span class="line">                    &#125;</span><br><span class="line">                    zooKeeperSaslClient = <span class="keyword">new</span> <span class="title class_">ZooKeeperSaslClient</span>(SaslServerPrincipal.getServerPrincipal(addr, clientConfig), clientConfig);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (LoginException e) &#123;</span><br><span class="line">                    <span class="comment">// An authentication error occurred when the SASL client tried to initialize:</span></span><br><span class="line">                    <span class="comment">// for Kerberos this means that the client failed to authenticate with the KDC.</span></span><br><span class="line">                    <span class="comment">// This is different from an authentication error that occurs during communication</span></span><br><span class="line">                    <span class="comment">// with the Zookeeper server, which is handled below.</span></span><br><span class="line">                    LOG.warn(</span><br><span class="line">                        <span class="string">&quot;SASL configuration failed. &quot;</span></span><br><span class="line">                            + <span class="string">&quot;Will continue connection to Zookeeper server without &quot;</span></span><br><span class="line">                            + <span class="string">&quot;SASL authentication, if Zookeeper server allows it.&quot;</span>, e);</span><br><span class="line">                    eventThread.queueEvent(<span class="keyword">new</span> <span class="title class_">WatchedEvent</span>(Watcher.Event.EventType.None, Watcher.Event.KeeperState.AuthFailed, <span class="literal">null</span>));</span><br><span class="line">                    saslLoginFailed = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            logStartConnect(addr);</span><br><span class="line">            <span class="comment">// 调用 ClientCnxnSocket 的 connect 方法尝试连接</span></span><br><span class="line">            clientCnxnSocket.connect(addr);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在 SendThread 的 run 方法中会启动初始化连接的流程，并且最终会调用到 ClientCnxnSocketNetty 的 connect 方法来建立客户端网络通信的连接，netty连接逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxnSocketNetty#connect</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(InetSocketAddress addr)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        firstConnect = <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 netty Bootstrap</span></span><br><span class="line">        <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>().group(eventLoopGroup) <span class="comment">// 设置 eventLoopGroup</span></span><br><span class="line">                                             .channel(NettyUtils.nioOrEpollSocketChannel()) <span class="comment">// 选择合适的 SocketChannel</span></span><br><span class="line">                                             .option(ChannelOption.SO_LINGER, -<span class="number">1</span>) <span class="comment">// 对应套接字选项SO_LINGER</span></span><br><span class="line">                                             .option(ChannelOption.TCP_NODELAY, <span class="literal">true</span>) <span class="comment">// 对应套接字选项 TCP_NODELAY</span></span><br><span class="line">                                             .handler(<span class="keyword">new</span> <span class="title class_">ZKClientPipelineFactory</span>(addr.getHostString(), addr.getPort())); <span class="comment">// 设置处理器</span></span><br><span class="line">        bootstrap = configureBootstrapAllocator(bootstrap);</span><br><span class="line">        bootstrap.validate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 connectLock</span></span><br><span class="line">        connectLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Netty 异步调用</span></span><br><span class="line">            connectFuture = bootstrap.connect(addr);</span><br><span class="line">            <span class="comment">// 监听并处理返回结果</span></span><br><span class="line">            connectFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="comment">// this lock guarantees that channel won&#x27;t be assigned after cleanup().</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">connected</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                    connectLock.lock();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!channelFuture.isSuccess()) &#123;</span><br><span class="line">                            LOG.warn(<span class="string">&quot;future isn&#x27;t success.&quot;</span>, channelFuture.cause());</span><br><span class="line">                            <span class="comment">// 连接失败则直接返回</span></span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (connectFuture == <span class="literal">null</span>) &#123;</span><br><span class="line">                            LOG.info(<span class="string">&quot;connect attempt cancelled&quot;</span>);</span><br><span class="line">                            <span class="comment">// If the connect attempt was cancelled but succeeded</span></span><br><span class="line">                            <span class="comment">// anyway, make sure to close the channel, otherwise</span></span><br><span class="line">                            <span class="comment">// we may leak a file descriptor.</span></span><br><span class="line">                            <span class="comment">// 如果 connectFuture 为空则证明尝试连接被取消</span></span><br><span class="line">                            <span class="comment">// 但是因为可能已经连接成功了，所以应当确保 channel 被正常关闭</span></span><br><span class="line">                            channelFuture.channel().close();</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// setup channel, variables, connection, etc.</span></span><br><span class="line">                        channel = channelFuture.channel();</span><br><span class="line"></span><br><span class="line">                        disconnected.set(<span class="literal">false</span>);</span><br><span class="line">                        initialized = <span class="literal">false</span>;</span><br><span class="line">                        <span class="comment">// lenBuffer 仅用于读取传入消息的长度（该 Buffer 长度为 4 byte）</span></span><br><span class="line">                        lenBuffer.clear();</span><br><span class="line">                        incomingBuffer = lenBuffer;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 构建ConnectRequest 设置 Session、之前的观察者和身份验证</span></span><br><span class="line">                        sendThread.primeConnection();</span><br><span class="line">                        updateNow();</span><br><span class="line">                        updateLastSendAndHeard();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (sendThread.tunnelAuthInProgress()) &#123;</span><br><span class="line">                            waitSasl.drainPermits();</span><br><span class="line">                            needSasl.set(<span class="literal">true</span>);</span><br><span class="line">                            sendPrimePacket();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            needSasl.set(<span class="literal">false</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        connected = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        connectFuture = <span class="literal">null</span>;</span><br><span class="line">                        connectLock.unlock();</span><br><span class="line">                        <span class="keyword">if</span> (connected) &#123;</span><br><span class="line">                            LOG.info(<span class="string">&quot;channel is connected: &#123;&#125;&quot;</span>, channelFuture.channel());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// need to wake on connect success or failure to avoid</span></span><br><span class="line">                        <span class="comment">// timing out ClientCnxn.SendThread which may be</span></span><br><span class="line">                        <span class="comment">// blocked waiting for first connect in doTransport().</span></span><br><span class="line">                        <span class="comment">// 唤醒发送线程中的发送逻辑（向 outgoingQueue 中添加一个 WakeupPacket 空包）</span></span><br><span class="line">                        wakeupCnxn();</span><br><span class="line">                        <span class="comment">// 避免 ClientCnxn 中的 SendThread 在 doTransport() 中等待第一次连接而被阻塞并最终超时</span></span><br><span class="line">                        firstConnect.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放connectLock</span></span><br><span class="line">            connectLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>connect方法注意点：</p>
<ul>
<li><p>设置 Bootstrap 的Handler为 ZKClientPipelineFactory，准确来说是 ZKClientHandler（如下）；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">            <span class="keyword">if</span> (clientConfig.getBoolean(ZKClientConfig.SECURE_CLIENT)) &#123;</span><br><span class="line">                initSSL(pipeline);</span><br><span class="line">            &#125;</span><br><span class="line">            pipeline.addLast(<span class="string">&quot;handler&quot;</span>, <span class="keyword">new</span> <span class="title class_">ZKClientHandler</span>());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化设置 incomingBuffer = lenBuffer，保证第一次读入的是数据包中真实数据的长度（首部 4byte ByteBuffer）</p>
</li>
<li><p>完成连接后需要通过 wakeupCnxn() 方法来唤醒发送线程的发送逻辑（实质是发送一个空的 WakeupPacket）</p>
</li>
</ul>
</li>
<li><p>SendThread 从 outgoingQueue 获取并发送 Packet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxn.SendThread#run</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (state.isAlive()) &#123;</span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!clientCnxnSocket.isConnected()) &#123;</span><br><span class="line">            	<span class="comment">// 连接服务端逻辑..</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 省略部分代码..</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 发送 outgoingQueue 中的数据包并将已发送的数据包转移到 PendingQueue 中</span></span><br><span class="line">      clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.<span class="built_in">this</span>);</span><br><span class="line">        	</span><br><span class="line">      <span class="comment">// 省略部分代码..</span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>当完成了客户端连接后即可进入到请求发送的逻辑中，客户端发送请求的逻辑主要位于 ClientCnxn 的 SendThread 线程中，在初始化时我们已经启动了该线程，所以当连接建立完成后会通过调用 clientCnxnSocket （ ClientCnxnSocketNetty ）的 <strong>doTransport</strong> 方法发送位于 outgoingQueue 中的 Packet 请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxnSocketNetty#doTransport</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doTransport</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">int</span> waitTimeOut,</span></span><br><span class="line"><span class="params">        Queue&lt;Packet&gt; pendingQueue,</span></span><br><span class="line"><span class="params">        ClientCnxn cnxn)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 该线程方法会等待连接的建立且超时即返回</span></span><br><span class="line">            <span class="keyword">if</span> (!firstConnect.await(waitTimeOut, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Packet</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (needSasl.get()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!waitSasl.tryAcquire(waitTimeOut, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 从 outgoingQueue 队列中获取要发送的 Packet</span></span><br><span class="line">                head = outgoingQueue.poll(waitTimeOut, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// check if being waken up on closing.</span></span><br><span class="line">            <span class="comment">// 检查当前是否正处于关闭流程中</span></span><br><span class="line">            <span class="keyword">if</span> (!sendThread.getZkState().isAlive()) &#123;</span><br><span class="line">                <span class="comment">// adding back the packet to notify of failure in conLossPacket(). 添加数据包以通知conLossPacket()中的失败</span></span><br><span class="line">                addBack(head);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// channel disconnection happened</span></span><br><span class="line">            <span class="comment">// 当通道断开时</span></span><br><span class="line">            <span class="keyword">if</span> (disconnected.get()) &#123;</span><br><span class="line">                addBack(head);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EndOfStreamException</span>(<span class="string">&quot;channel for sessionid 0x&quot;</span> + Long.toHexString(sessionId) + <span class="string">&quot; is lost&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用 doWrite 方法执行实际的发送数据操作</span></span><br><span class="line">                doWrite(pendingQueue, head, cnxn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            updateNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在 doTransport 方法中首先会 await 等待连接建立，并且在超时后会立即返回（因此在连接建立后需要第一时间唤醒该线程以避免其超时返回），之后会从 outgoingQueue 中取出待发送的 Packet ，并在进行一系列验证后通过 doWrite 方法来实际发送该 Packet </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doWrite</span><span class="params">(Queue&lt;Packet&gt; pendingQueue, Packet p, ClientCnxn cnxn)</span> &#123;</span><br><span class="line">        updateNow();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">anyPacketsSent</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 跳过处理 WakeupPacket 数据包</span></span><br><span class="line">            <span class="keyword">if</span> (p != WakeupPacket.getInstance()) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p.requestHeader != <span class="literal">null</span>)</span><br><span class="line">                    &amp;&amp; (p.requestHeader.getType() != ZooDefs.OpCode.ping)</span><br><span class="line">                    &amp;&amp; (p.requestHeader.getType() != ZooDefs.OpCode.auth)) &#123;</span><br><span class="line">                    p.requestHeader.setXid(cnxn.getXid());</span><br><span class="line">                    <span class="keyword">synchronized</span> (pendingQueue) &#123;</span><br><span class="line">                        <span class="comment">// 将该 Packet 添加到 pendingQueue 队列中</span></span><br><span class="line">                        pendingQueue.add(p);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 只发送数据包到通道，而不刷新通道</span></span><br><span class="line">                sendPktOnly(p);</span><br><span class="line">                <span class="comment">// 记录本轮存在需要被发送的数据</span></span><br><span class="line">                anyPacketsSent = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (outgoingQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从outgoingQueue 队列获取 Packet</span></span><br><span class="line">            p = outgoingQueue.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> maybe we should flush in the loop above every N packets/bytes?</span></span><br><span class="line">        <span class="comment">// But, how do we determine the right value for N ...</span></span><br><span class="line">        <span class="comment">// 如果本轮存在需要被发送的数据，则调用 flush 刷新 Netty 通道</span></span><br><span class="line">        <span class="keyword">if</span> (anyPacketsSent) &#123;</span><br><span class="line">            channel.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在 doWrite 方法中会在验证该 Packet 非 WakeupPacket 后为其设置请求头中的 xid ，并将其添加到 pendingQueue 中，最后通过 sendPktOnly 方法将其发送到通道中（暂不刷新通道，方法代码如下），然后如果 outgoingQueue 中仍存在待发送的 Packet 则继续重复执行添加 pendingQueue 并发送的逻辑，当 outgoingQueue 中的 Packet 全部处理完成后调用 channel.flush() 刷新通道，将本轮数据一起发送</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxnSocketNetty#sendPktOnly</span></span><br><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">sendPktOnly</span><span class="params">(Packet p)</span> &#123;</span><br><span class="line">	<span class="comment">// 仅发送数据包到通道，而不调用 flush() 方法刷新通道</span></span><br><span class="line">    <span class="keyword">return</span> sendPkt(p, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxnSocketNetty#sendPkt</span></span><br><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">sendPkt</span><span class="params">(Packet p, <span class="type">boolean</span> doFlush)</span> &#123;</span><br><span class="line">	<span class="comment">// 创建 ByteBuffer</span></span><br><span class="line">    p.createBB();</span><br><span class="line">    updateLastSend();</span><br><span class="line">    <span class="comment">// 将 ByteBuffer 转化为 Netty 的 ByteBuf</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">writeBuffer</span> <span class="operator">=</span> Unpooled.wrappedBuffer(p.bb);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">result</span> <span class="operator">=</span> doFlush</span><br><span class="line">            ? channel.writeAndFlush(writeBuffer)</span><br><span class="line">            : channel.write(writeBuffer);</span><br><span class="line">    result.addListener(onSendPktDoneListener);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>同步RPC调用流程（Create Api）</p>
<p><strong>同步Create Api入口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ZooKeeper#create(java.lang.String, byte[], java.util.List&lt;org.apache.zookeeper.data.ACL&gt;, org.apache.zookeeper.CreateMode)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">create</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> String path,</span></span><br><span class="line"><span class="params">        <span class="type">byte</span>[] data,</span></span><br><span class="line"><span class="params">        List&lt;ACL&gt; acl,</span></span><br><span class="line"><span class="params">        CreateMode createMode)</span> <span class="keyword">throws</span> KeeperException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">clientPath</span> <span class="operator">=</span> path;</span><br><span class="line">        <span class="comment">// 相关信息验证</span></span><br><span class="line">        PathUtils.validatePath(clientPath, createMode.isSequential());</span><br><span class="line">        EphemeralType.validateTTL(createMode, -<span class="number">1</span>);</span><br><span class="line">        validateACL(acl);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">serverPath</span> <span class="operator">=</span> prependChroot(clientPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 Request 请求包和 Response 响应包</span></span><br><span class="line">        <span class="type">RequestHeader</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestHeader</span>();</span><br><span class="line">        h.setType(createMode.isContainer() ? ZooDefs.OpCode.createContainer : ZooDefs.OpCode.create);</span><br><span class="line">        <span class="type">CreateRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateRequest</span>();</span><br><span class="line">        <span class="type">CreateResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateResponse</span>();</span><br><span class="line">        request.setData(data);</span><br><span class="line">        request.setFlags(createMode.toFlag());</span><br><span class="line">        request.setPath(serverPath);</span><br><span class="line">        request.setAcl(acl);</span><br><span class="line">        <span class="comment">// 提交请求并接收返回头</span></span><br><span class="line">        <span class="type">ReplyHeader</span> <span class="variable">r</span> <span class="operator">=</span> cnxn.submitRequest(h, request, response, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 处理异常</span></span><br><span class="line">        <span class="keyword">if</span> (r.getErr() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (cnxn.chrootPath == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> response.getPath();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> response.getPath().substring(cnxn.chrootPath.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>同步Api中 Create 方法的逻辑可以概括为以下五步:</p>
<ul>
<li>验证相关信息的有效性（包括验证客户端的路径以及创建模式的选择）</li>
<li>创建 <strong>Request</strong> 请求包和 <strong>Response</strong> 响应包，并为 Request 请求包填充数据</li>
<li>通过调用 <strong>ClientCnxn</strong> 的 <strong>submitRequest</strong> 方法提交请求并接收请求结果</li>
<li>处理请求结果中的异常</li>
<li>返回请求结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxn#submitRequest(org.apache.zookeeper.proto.RequestHeader, org.apache.jute.Record, org.apache.jute.Record, org.apache.zookeeper.ZooKeeper.WatchRegistration, org.apache.zookeeper.WatchDeregistration)</span></span><br><span class="line"><span class="keyword">public</span> ReplyHeader <span class="title function_">submitRequest</span><span class="params">(</span></span><br><span class="line"><span class="params">        RequestHeader h,</span></span><br><span class="line"><span class="params">        Record request,</span></span><br><span class="line"><span class="params">        Record response,</span></span><br><span class="line"><span class="params">        WatchRegistration watchRegistration,</span></span><br><span class="line"><span class="params">        WatchDeregistration watchDeregistration)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ReplyHeader</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReplyHeader</span>();</span><br><span class="line">        <span class="comment">// 根据 Request 数据和 Response 数据打包创建 Packet</span></span><br><span class="line">        <span class="type">Packet</span> <span class="variable">packet</span> <span class="operator">=</span> queuePacket(</span><br><span class="line">            h,</span><br><span class="line">            r,</span><br><span class="line">            request,</span><br><span class="line">            response,</span><br><span class="line">            <span class="literal">null</span>,</span><br><span class="line">            <span class="literal">null</span>,</span><br><span class="line">            <span class="literal">null</span>,</span><br><span class="line">            <span class="literal">null</span>,</span><br><span class="line">            watchRegistration,</span><br><span class="line">            watchDeregistration);</span><br><span class="line">        <span class="keyword">synchronized</span> (packet) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requestTimeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Wait for request completion with timeout</span></span><br><span class="line">                <span class="comment">// 等待请求完成超时</span></span><br><span class="line">                waitForPacketFinish(r, packet);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Wait for request completion infinitely</span></span><br><span class="line">                <span class="comment">// 等待请求完成</span></span><br><span class="line">                <span class="keyword">while</span> (!packet.finished) &#123;</span><br><span class="line">                    packet.wait();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.getErr() == Code.REQUESTTIMEOUT.intValue()) &#123;</span><br><span class="line">            <span class="comment">// 如果请求超时则清空 outgoingQueue 和 pendingQueue</span></span><br><span class="line">            sendThread.cleanAndNotifyState();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先会调用 queuePacket 方法创建 Packet 并将其入队 outgoing ，之后同步该 Packet，最后根据是否设置了超时时间来选择是否使用超时逻辑，如果设置了超时时间，当请求在超时时间内未完成即返回并清空相关队列（outgoingQueue 和 pendingQueue），而如果未设置超时时间则该线程无限期的 wait 在该 Packet 直至接收到该请求的响应（在接收到请求的响应后该线程会被 notify）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Packet <span class="title function_">queuePacket</span><span class="params">(</span></span><br><span class="line"><span class="params">        RequestHeader h,</span></span><br><span class="line"><span class="params">        ReplyHeader r,</span></span><br><span class="line"><span class="params">        Record request,</span></span><br><span class="line"><span class="params">        Record response,</span></span><br><span class="line"><span class="params">        AsyncCallback cb,</span></span><br><span class="line"><span class="params">        String clientPath,</span></span><br><span class="line"><span class="params">        String serverPath,</span></span><br><span class="line"><span class="params">        Object ctx,</span></span><br><span class="line"><span class="params">        WatchRegistration watchRegistration,</span></span><br><span class="line"><span class="params">        WatchDeregistration watchDeregistration)</span> &#123;</span><br><span class="line">        <span class="type">Packet</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note that we do not generate the Xid for the packet yet. It is</span></span><br><span class="line">        <span class="comment">// generated later at send-time, by an implementation of ClientCnxnSocket::doIO(),</span></span><br><span class="line">        <span class="comment">// where the packet is actually sent.</span></span><br><span class="line">        <span class="comment">// 创建一个 Packet 实例并将相关数据填入</span></span><br><span class="line">        packet = <span class="keyword">new</span> <span class="title class_">Packet</span>(h, r, request, response, watchRegistration);</span><br><span class="line">        packet.cb = cb;</span><br><span class="line">        packet.ctx = ctx;</span><br><span class="line">        packet.clientPath = clientPath;</span><br><span class="line">        packet.serverPath = serverPath;</span><br><span class="line">        packet.watchDeregistration = watchDeregistration;</span><br><span class="line">        <span class="comment">// The synchronized block here is for two purpose:</span></span><br><span class="line">        <span class="comment">// 1. synchronize with the final cleanup() in SendThread.run() to avoid race</span></span><br><span class="line">        <span class="comment">// 2. synchronized against each packet. So if a closeSession packet is added,</span></span><br><span class="line">        <span class="comment">// later packet will be notified.</span></span><br><span class="line">        <span class="comment">// 同步状态</span></span><br><span class="line">        <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!state.isAlive() || closing) &#123;</span><br><span class="line">                <span class="comment">// 如果当前连接已断开或者正在关闭则返回相应的错误信息</span></span><br><span class="line">                conLossPacket(packet);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// If the client is asking to close the session then</span></span><br><span class="line">                <span class="comment">// mark as closing</span></span><br><span class="line">                <span class="comment">// 如果客户端要求关闭会话，则将其状态标记为正在关闭（Closing）</span></span><br><span class="line">                <span class="keyword">if</span> (h.getType() == OpCode.closeSession) &#123;</span><br><span class="line">                    closing = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果请求超时则清空 outgoingQueue 和 pendingQueue</span></span><br><span class="line">                outgoingQueue.add(packet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 唤醒发送线程发送 outgoing 队列中的 Packet（Netty 中为空实现）</span></span><br><span class="line">        sendThread.getClientCnxnSocket().packetAdded();</span><br><span class="line">        <span class="keyword">return</span> packet;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在 queuePacket 方法中会创建一个 Packet 实例，并将入参中的 request 请求包和 response 响应包等数据填充到该 Packet 中。但需要注意的是，到目前为止还没有为包生成 Xid ，它是在稍后发送时由 ClientCnxnSocket::doIO() 实现生成的，因为 Packet 实际上是在那里被发送的。然后会同步在状态值 state 上，这里之所以要同步在该状态上的原因有两点：</p>
<ul>
<li>同步 SendThread.run() 中的 cleanup() 操作以避免竞争</li>
<li>通过对每个包进行同步，如果一个 closeSession 包被添加，后面的包都会被通知</li>
</ul>
<p>到这里为止（ <strong>Packet 入队 outgoingQueue 且线程 wait</strong> ）同步版本的 Create API 实现第一部分已经分析完成，下面我们来大概总结一下主要的流程：</p>
<ul>
<li>首先在 Zookeeper 的 Create() 方法中根据入参创建 Request 请求包和 Response 响应包</li>
<li>调用 ClientCnxn 的 submitRequest() 方法提交该请求，在 submitRequest() 方法中会调用 queuePacket() 方法</li>
<li>在 queuePacket() 方法中将入参中的 Request 请求包和 Response 响应包以及其它信息封装为 Packet ，然后将其入队 outgoingQueue 并唤醒发送逻辑</li>
<li>返回到 ClientCnxn 的 submitRequest() 方法中，根据是否设置超时时间选择不同的逻辑来将该线程 wait</li>
</ul>
<p><strong>处理响应并出队 pendingQueue（且 Packet.notifyAll）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxnSocketNetty.ZKClientHandler#channelRead0</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf buf)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            updateNow();</span><br><span class="line">            <span class="keyword">while</span> (buf.isReadable()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (incomingBuffer.remaining() &gt; buf.readableBytes()) &#123;</span><br><span class="line">                    <span class="comment">// 如果 incomingBuffer 中剩余的空间大于 ByteBuf 中可读数据长度</span></span><br><span class="line">                    <span class="comment">// 重置 incomingBuffer 中的 limit 为 incomingBuffer 当前的 position 加上 ByteBuf 中可读的数据长度</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">newLimit</span> <span class="operator">=</span> incomingBuffer.position() + buf.readableBytes();</span><br><span class="line">                    incomingBuffer.limit(newLimit);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将 ByteBuf 中的数据读入到 incomingBuffer（ ByteBuffer）中</span></span><br><span class="line">                buf.readBytes(incomingBuffer);</span><br><span class="line">                incomingBuffer.limit(incomingBuffer.capacity());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!incomingBuffer.hasRemaining()) &#123;</span><br><span class="line">                    incomingBuffer.flip();</span><br><span class="line">                    <span class="keyword">if</span> (incomingBuffer == lenBuffer) &#123;</span><br><span class="line">                        recvCount.getAndIncrement();</span><br><span class="line">                        <span class="comment">// 当 incomingBuffer 等于 lenBuffer 时首先读取数据包中数据的长度 4byte</span></span><br><span class="line">                        readLength();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">                        <span class="comment">// 如果未进行初始化则首先读取连接结果</span></span><br><span class="line">                        readConnectResult();</span><br><span class="line">                        <span class="comment">// 重置 lenBuffer 并重新初始化 incomingBuffer 为 lenBuffer 来读取数据包中真正数据的长度</span></span><br><span class="line">                        lenBuffer.clear();</span><br><span class="line">                        incomingBuffer = lenBuffer;</span><br><span class="line">                        initialized = <span class="literal">true</span>;</span><br><span class="line">                        updateLastHeard();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 读取数据包中真正的数据</span></span><br><span class="line">                        sendThread.readResponse(incomingBuffer);</span><br><span class="line">                        <span class="comment">// 重置 lenBuffer 并重新初始化 incomingBuffer 为 lenBuffer 来读取数据包中真正数据的长度</span></span><br><span class="line">                        lenBuffer.clear();</span><br><span class="line">                        incomingBuffer = lenBuffer;</span><br><span class="line">                        updateLastHeard();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 唤醒发送逻辑</span></span><br><span class="line">            wakeupCnxn();</span><br><span class="line">            <span class="comment">// Note: SimpleChannelInboundHandler releases the ByteBuf for us</span></span><br><span class="line">            <span class="comment">// so we don&#x27;t need to do it.</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>首先在初始化连接的过程中（connect 方法中）我们就已将 incomingBuffer 设置为 lenBuffer（4 byte ByteBuffer），因此当数据到达时 incomingBuffer 会先将 ByteBuf 中的前 4byte 数据读入，然后调用 readLength 方法来获取这 4byte 所代表的 int 数值（真实数据的长度），之后再创建一个新的长度为真实数据长度的 ByteBuffer 赋值给 incomingBuffer，这样在下一轮的读取过程中 incomingBuffer 就可以从 ByteBuf 中一次性完整的读出所有的真实数据，最后调用 readResponse 方法来处理读取到的真实数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxn.SendThread#readResponse</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">readResponse</span><span class="params">(ByteBuffer incomingBuffer)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="type">ByteBufferInputStream</span> <span class="variable">bbis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteBufferInputStream</span>(incomingBuffer);</span><br><span class="line">            <span class="type">BinaryInputArchive</span> <span class="variable">bbia</span> <span class="operator">=</span> BinaryInputArchive.getArchive(bbis);</span><br><span class="line">            <span class="comment">// 创建临时响应头</span></span><br><span class="line">            <span class="type">ReplyHeader</span> <span class="variable">replyHdr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReplyHeader</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解析数据包中的数据填充临时响应头，然后根据临时响应头中的 xid 进行分类处理</span></span><br><span class="line">            replyHdr.deserialize(bbia, <span class="string">&quot;header&quot;</span>);</span><br><span class="line">            <span class="keyword">switch</span> (replyHdr.getXid()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PING_XID:</span><br><span class="line">                LOG.debug(<span class="string">&quot;Got ping response for session id: 0x&#123;&#125; after &#123;&#125;ms.&quot;</span>,</span><br><span class="line">                    Long.toHexString(sessionId),</span><br><span class="line">                    ((System.nanoTime() - lastPingSentNs) / <span class="number">1000000</span>));</span><br><span class="line">                <span class="comment">// xid == -2 为心跳包</span></span><br><span class="line">                <span class="comment">// 心跳包不做处理直接返回</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">              <span class="keyword">case</span> AUTHPACKET_XID:</span><br><span class="line">                  <span class="comment">// xid == -4 为认证包</span></span><br><span class="line">                LOG.debug(<span class="string">&quot;Got auth session id: 0x&#123;&#125;&quot;</span>, Long.toHexString(sessionId));</span><br><span class="line">                <span class="keyword">if</span> (replyHdr.getErr() == KeeperException.Code.AUTHFAILED.intValue()) &#123;</span><br><span class="line">                    changeZkState(States.AUTH_FAILED);</span><br><span class="line">                    eventThread.queueEvent(<span class="keyword">new</span> <span class="title class_">WatchedEvent</span>(Watcher.Event.EventType.None,</span><br><span class="line">                        Watcher.Event.KeeperState.AuthFailed, <span class="literal">null</span>));</span><br><span class="line">                    eventThread.queueEventOfDeath();</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> NOTIFICATION_XID:</span><br><span class="line">                <span class="comment">// xid == -1 为通知包</span></span><br><span class="line">                LOG.debug(<span class="string">&quot;Got notification session id: 0x&#123;&#125;&quot;</span>,</span><br><span class="line">                    Long.toHexString(sessionId));</span><br><span class="line">                <span class="type">WatcherEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WatcherEvent</span>();</span><br><span class="line">                event.deserialize(bbia, <span class="string">&quot;response&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// convert from a server path to a client path</span></span><br><span class="line">                <span class="keyword">if</span> (chrootPath != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">serverPath</span> <span class="operator">=</span> event.getPath();</span><br><span class="line">                    <span class="keyword">if</span> (serverPath.compareTo(chrootPath) == <span class="number">0</span>) &#123;</span><br><span class="line">                        event.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serverPath.length() &gt; chrootPath.length()) &#123;</span><br><span class="line">                        event.setPath(serverPath.substring(chrootPath.length()));</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         LOG.warn(<span class="string">&quot;Got server path &#123;&#125; which is too short for chroot path &#123;&#125;.&quot;</span>,</span><br><span class="line">                             event.getPath(), chrootPath);</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">WatchedEvent</span> <span class="variable">we</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WatchedEvent</span>(event);</span><br><span class="line">                LOG.debug(<span class="string">&quot;Got &#123;&#125; for session id 0x&#123;&#125;&quot;</span>, we, Long.toHexString(sessionId));</span><br><span class="line">                eventThread.queueEvent(we);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If SASL authentication is currently in progress, construct and</span></span><br><span class="line">            <span class="comment">// send a response packet immediately, rather than queuing a</span></span><br><span class="line">            <span class="comment">// response as with other packets.</span></span><br><span class="line">            <span class="keyword">if</span> (tunnelAuthInProgress()) &#123;</span><br><span class="line">                <span class="type">GetSASLRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetSASLRequest</span>();</span><br><span class="line">                request.deserialize(bbia, <span class="string">&quot;token&quot;</span>);</span><br><span class="line">                zooKeeperSaslClient.respondToServer(request.getToken(), ClientCnxn.<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Packet packet;</span><br><span class="line">            <span class="keyword">synchronized</span> (pendingQueue) &#123;</span><br><span class="line">                <span class="comment">// 如果 pendingQueue 为空则直接抛异常，否则出队一个 Packet</span></span><br><span class="line">                <span class="keyword">if</span> (pendingQueue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Nothing in the queue, but got &quot;</span> + replyHdr.getXid());</span><br><span class="line">                &#125;</span><br><span class="line">                packet = pendingQueue.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Since requests are processed in order, we better get a response</span></span><br><span class="line"><span class="comment">             * to the first request!</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 由于请求是按顺序处理的，所以获得对第一个请求的响应</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果 pendingQueue 刚刚出队的 Packet 不是当前响应所对应的 Packet 则证明出现异常</span></span><br><span class="line">                <span class="keyword">if</span> (packet.requestHeader.getXid() != replyHdr.getXid()) &#123;</span><br><span class="line">                    packet.replyHeader.setErr(KeeperException.Code.CONNECTIONLOSS.intValue());</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Xid out of order. Got Xid &quot;</span> + replyHdr.getXid()</span><br><span class="line">                                          + <span class="string">&quot; with err &quot;</span> + replyHdr.getErr()</span><br><span class="line">                                          + <span class="string">&quot; expected Xid &quot;</span> + packet.requestHeader.getXid()</span><br><span class="line">                                          + <span class="string">&quot; for a packet with details: &quot;</span> + packet);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 填充 Packet 响应头数据</span></span><br><span class="line">                packet.replyHeader.setXid(replyHdr.getXid());</span><br><span class="line">                packet.replyHeader.setErr(replyHdr.getErr());</span><br><span class="line">                packet.replyHeader.setZxid(replyHdr.getZxid());</span><br><span class="line">                <span class="comment">// 更新最后处理的 zxid</span></span><br><span class="line">                <span class="keyword">if</span> (replyHdr.getZxid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    lastZxid = replyHdr.getZxid();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果 Packet 中存在 Response 响应包（数据为空）且响应头解析未出现错误则继续解析响应体数据</span></span><br><span class="line">                <span class="keyword">if</span> (packet.response != <span class="literal">null</span> &amp;&amp; replyHdr.getErr() == <span class="number">0</span>) &#123;</span><br><span class="line">                    packet.response.deserialize(bbia, <span class="string">&quot;response&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                LOG.debug(<span class="string">&quot;Reading reply session id: 0x&#123;&#125;, packet:: &#123;&#125;&quot;</span>, Long.toHexString(sessionId), packet);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 完整响应数据解析后调用</span></span><br><span class="line">                finishPacket(packet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>readResponse 方法首先从刚刚读入数据的 ByteBuffer 中解析出一个临时响应头，然后根据这个临时响应头中的 xid 来进行分类处理， 当处理完成后会从 pendingQueue 中出队一个 Packet，这个 Packet 正常来说应当是我们之前发送最后一个请求后入队的那个 Packet （请求顺序性），因此判断这个出队的 Packet 的 xid 是否等于当前正在处理的这个请求中的 Packet 的 xid ，如果不是则证明出现了丢包或断连等问题，所以向临时响应头中添加一个错误信息，然后将临时响应头中的数据填充到刚刚出队的那个 Packet 的 ReplyHeader 响应头中并更新最后处理的 zxid 属性值（ lastZxid ），最终如果确认该 Packet 中存在 Response（需要返回响应信息）并且在解析响应头的过程中未发现错误，则开始从 ByteBuffer 中解析出响应体并赋给 Packet 的 Response 属性，当全部处理完成时，最终调用 finishPacket 方法完成 ByteBuffer 的 Response 解析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxn#finishPacket</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishPacket</span><span class="params">(Packet p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">err</span> <span class="operator">=</span> p.replyHeader.getErr();</span><br><span class="line">        <span class="keyword">if</span> (p.watchRegistration != <span class="literal">null</span>) &#123;</span><br><span class="line">            p.watchRegistration.register(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Add all the removed watch events to the event queue, so that the</span></span><br><span class="line">        <span class="comment">// clients will be notified with &#x27;Data/Child WatchRemoved&#x27; event type.</span></span><br><span class="line">        <span class="comment">// watch事件处理</span></span><br><span class="line">        <span class="keyword">if</span> (p.watchDeregistration != <span class="literal">null</span>) &#123;</span><br><span class="line">            Map&lt;EventType, Set&lt;Watcher&gt;&gt; materializedWatchers = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                materializedWatchers = p.watchDeregistration.unregister(err);</span><br><span class="line">                <span class="keyword">for</span> (Entry&lt;EventType, Set&lt;Watcher&gt;&gt; entry : materializedWatchers.entrySet()) &#123;</span><br><span class="line">                    Set&lt;Watcher&gt; watchers = entry.getValue();</span><br><span class="line">                    <span class="keyword">if</span> (watchers.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        queueEvent(p.watchDeregistration.getClientPath(), err, watchers, entry.getKey());</span><br><span class="line">                        <span class="comment">// ignore connectionloss when removing from local</span></span><br><span class="line">                        <span class="comment">// session</span></span><br><span class="line">                        p.replyHeader.setErr(Code.OK.intValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (KeeperException.NoWatcherException nwe) &#123;</span><br><span class="line">                p.replyHeader.setErr(nwe.code().intValue());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (KeeperException ke) &#123;</span><br><span class="line">                p.replyHeader.setErr(ke.code().intValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.cb == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 Packet 中不存在方法回调（同步 API）</span></span><br><span class="line">            <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">                <span class="comment">// 设置 Packet 处理完成</span></span><br><span class="line">                p.finished = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒所有 wait 在该 Packet 上的线程</span></span><br><span class="line">                p.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 Packet 中不存在方法回调（异步 API），先设置 Packet 处理完成</span></span><br><span class="line">            p.finished = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 进入异步 Packet 的处理逻辑</span></span><br><span class="line">            eventThread.queuePacket(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>finishPacket 方法在响应处理完成后就会被调用，在这个方法中首先会对 Watch 事件进行处理，然后判断当前 Packet 中是否存在回调方法（本次调用是同步还是异步），如果不存在回调方法则证明本次调用为同步调用，因此更新 Packet 的 finished 状态后通过 Packet 的 notifyAll 方法唤醒所有 wait 在该 Packet 上的线程（wait 逻辑位于 ClientCnxn 的 submitRequest 方法），而如果存在回调方法，则应通过调用 EventThread 的 queuePacket 方法进入对于异步回调的处理逻辑中</p>
</li>
</ol>
<ol start="4">
<li>异步RPC调用流程（Create Api）<br>异步Create Api入口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ZooKeeper#create(java.lang.String, byte[], java.util.List&lt;org.apache.zookeeper.data.ACL&gt;, org.apache.zookeeper.CreateMode, org.apache.zookeeper.AsyncCallback.StringCallback, java.lang.Object)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> String path,</span></span><br><span class="line"><span class="params">        <span class="type">byte</span>[] data,</span></span><br><span class="line"><span class="params">        List&lt;ACL&gt; acl,</span></span><br><span class="line"><span class="params">        CreateMode createMode,</span></span><br><span class="line"><span class="params">        StringCallback cb,</span></span><br><span class="line"><span class="params">        Object ctx)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">clientPath</span> <span class="operator">=</span> path;</span><br><span class="line">        <span class="comment">// 相关信息验证（与同步模式相同）</span></span><br><span class="line">        PathUtils.validatePath(clientPath, createMode.isSequential());</span><br><span class="line">        EphemeralType.validateTTL(createMode, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">serverPath</span> <span class="operator">=</span> prependChroot(clientPath);</span><br><span class="line">        <span class="comment">// 创建 Request 请求包和 Response 响应包（与同步模式相同）</span></span><br><span class="line">        <span class="type">RequestHeader</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestHeader</span>();</span><br><span class="line">        h.setType(createMode.isContainer() ? ZooDefs.OpCode.createContainer : ZooDefs.OpCode.create);</span><br><span class="line">        <span class="type">CreateRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateRequest</span>();</span><br><span class="line">        <span class="type">CreateResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateResponse</span>();</span><br><span class="line">        <span class="type">ReplyHeader</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReplyHeader</span>();</span><br><span class="line">        request.setData(data);</span><br><span class="line">        request.setFlags(createMode.toFlag());</span><br><span class="line">        request.setPath(serverPath);</span><br><span class="line">        request.setAcl(acl);</span><br><span class="line">        <span class="comment">// 直接调用 queuePacket 方法创建 Packet 并入队 outgoingQueue</span></span><br><span class="line">        cnxn.queuePacket(h, r, request, response, cb, clientPath, serverPath, ctx, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

异步模式的 API 和同步版 API 是大体相同的，只不过在异步版本的 API 中仅需要调用 queuePacket 方法创建 Packet 并入队 outgoingQueue ，然后直接返回即可，而不需要再在 submitRequest 方法中 wait 等待请求响应的返回<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxn.EventThread#queuePacket</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queuePacket</span><span class="params">(Packet packet)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (wasKilled) &#123;</span><br><span class="line">                <span class="comment">// EventThread 在接收到 eventOfDeath 后 wasKilled 将被设为 true</span></span><br><span class="line">                <span class="keyword">synchronized</span> (waitingEvents) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isRunning) &#123;</span><br><span class="line">                        <span class="comment">// 如果 EventThread 仍在运行（isRunning == true）则将 Packet 入队 waitingEvents</span></span><br><span class="line">                        waitingEvents.add(packet);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 否则直接调用 processEvent 方法处理该 Packet</span></span><br><span class="line">                        processEvent(packet);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果 EventThread 线程正常运行则直接将 Packet 入队 waitingEvents</span></span><br><span class="line">                waitingEvents.add(packet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

在接收并处理 Response 的过程中同步版和异步版的 API 前面的处理逻辑都是完全相同的，差异之处在于在 finishPacket 方法中同步版调用会直接唤醒所有 wait 在该 Packet 上面的线程然后返回，而对于异步版本则会调用到 queuePacket 方法来对响应做进一步的处理queuePacket 方法主要执行的就是将 Packet 入队 waitingEvents 的逻辑，但是需要注意的是对于 EventThread 存在两个标志量（下文会细讲），且当 wasKilled 为 true 时并不是意味着 EventThread 已经完全不能处理 Packet 了，还需要再次判断 isRunning 来确定当前 EventThread 是否真的已经停止运行了，如果当前 wasKilled 为 true 且 isRunning 为 false 则证明 EventThread 已经真正的结束了，所以该方法会自己调用 processEvent 方法来处理该 Packet当我们在 queuePacket 方法中将 Packet 入队 waitingEvents 后，在 ClientCnxn 的内部类（线程）EventThread 中会通过 run 方法不断取出队列中的 Packet ，然后调用 processEvent 方法进行处理。这里设计很巧妙的就是对于关闭该线程时的操作，在该线程中使用了两个标志量 wasKilled 和 isRunning ，当外部将要关闭它时会通过发送类型为 eventOfDeath 的 Packet 先设置 wasKilled 为 true，此时进入关闭的第一阶段。EventThread 得到该关闭消息后开始进行扫尾工作，在每次处理完一个 Packet 后就会判断 waitingEvents 中是否还存在未处理的 Packet ，如果存在就继续处理，如果不存在就将 isRunning 设置为 false 并跳出循环，此时标志着 EventThread 已经完成了扫尾工作，可以正常关闭了。因此，EventThread 可以安全的进入到最后一个线程的关闭阶段。这样的三阶段关闭流程保证了数据的安全性，保证了 EventThread 不会在 waitingEvents 还存在数据时就关闭而导致数据丢失，同时也正是因为这样，当通过 queuePacket 方法向 waitingEvents 中添加元素时，就算 wasKilled 已经为 true 了，但只要 isRunning 还为 true 就证明 waitingEvents 中还存在数据既 EventThread 还可以处理数据，所以仍然可以放心的将 Packet 入队 waitingEvents 来交给 EventThread 处理，且不会发生数据丢失的情况<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxn.EventThread.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processEvent</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 重构后的代码，省略巨多各种事件类型的判断和处理逻辑...</span></span><br><span class="line">		<span class="comment">// 当进行异步 Create 时，事件类型为 CreateResponse </span></span><br><span class="line">    	<span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> CreateResponse) &#123;</span><br><span class="line">    		<span class="comment">// 获取 Packet 中的回调信息</span></span><br><span class="line">        	<span class="type">StringCallback</span> <span class="variable">cb</span> <span class="operator">=</span> (StringCallback) p.cb;</span><br><span class="line">        	<span class="comment">// 获取 Packet 中的响应体</span></span><br><span class="line">            <span class="type">CreateResponse</span> <span class="variable">rsp</span> <span class="operator">=</span> (CreateResponse) p.response;</span><br><span class="line">            <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">            	cb.processResult(rc, clientPath, p.ctx,</span><br><span class="line">                	(chrootPath == <span class="literal">null</span> ? rsp.getPath() : rsp.getPath().substring(chrootPath.length())));</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 进行方法回调</span></span><br><span class="line">				cb.processResult(rc, clientPath, p.ctx, <span class="literal">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

在 processEvent 方法中会根据传入 Packet 的类型来选择不同的处理逻辑对 Packet 进行处理，因为我们这里分析的是 Create API ，而其对应的响应类型为 CreateResponse ，所以会进入到如上图代码的逻辑中，具体的处理方式也就是获取到 Packet 中所保存的回调方法，然后对其进行回调即可，至此也就完成了整个异步版本的方法调用</li>
</ol>
<h2 id="同步、异步比较"><a href="#同步、异步比较" class="headerlink" title="同步、异步比较"></a>同步、异步比较</h2><p>首先经过上面的源码分析我们先总结一下几个比较重要的数据结构和属性：</p>
<ul>
<li>outgoingQueue ：保存待发送的 Packet 的队列</li>
<li>pendingQueue ：保存已发送但还未接收到响应的 Packet 的队列</li>
<li>waitingEvents ：保存已接收到响应待回调的 Packet 的队列</li>
<li>EventThread.wasKilled ：外部发送信号终止 EventThread ，但此时可能尚未真正停止</li>
<li>EventThread.isRunning ：标志着 EventThread 尚在运行（waitingEvents 中还存在未处理的 Packet），当该属性为 false 时证明线程进入终止状态</li>
</ul>
<p>总结同步版 API 主流程：</p>
<ul>
<li>创建 Packet 并入队 outgoingQueue ，然后线程 wait 在该 Packet 进行等待</li>
<li>SendThread 从 outgoingQueue 中取出 Packet 后进行发送，并入队 pendingQueue</li>
<li>接收响应后从 pendingQueue 中出队 Packet ，然后将响应数据解析到 Packet中</li>
<li>解析完成后调用 Packet.notifyAll 方法唤醒所有阻塞在该 Packet 上的线程</li>
</ul>
<p>总结 异步版 API 主流程：</p>
<ul>
<li>创建 Packet 并入队 outgoingQueue ，然后方法直接返回</li>
<li>SendThread 从 outgoingQueue 中取出 Packet 后进行发送，并入队 pendingQueue</li>
<li>接收响应后从 pendingQueue 中出队 Packet ，然后将响应数据解析到 Packet中</li>
<li>解析完成后将该 Packet 入队 waitingEvents ，然后 EventThread 会从 waitingEvents 中取出 Packet 并调用其回调方法</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="tlv"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">tlv</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tlv</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
