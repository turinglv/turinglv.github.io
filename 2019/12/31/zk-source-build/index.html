<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="客户端结构解析客户端结构图    客户端核心类zk客户端的核心组件如下：  ZooKeeper实例 ：客户端入口 ClientWatcherManager ：客户端Watcher管理器 HostProvider：客户端地址列表管理器 ClientCnxn：客户端核心线程。包含两个线程，即SendThread和EventThread。前者是一个I&#x2F;O线程，主要负责ZooKeeper客户端和服务端之间">
<meta property="og:type" content="article">
<meta property="og:title" content="Zookeeper -- 客户端源码解析">
<meta property="og:url" content="http://example.com/2019/12/31/zk-source-build/index.html">
<meta property="og:site_name" content="温故而知新">
<meta property="og:description" content="客户端结构解析客户端结构图    客户端核心类zk客户端的核心组件如下：  ZooKeeper实例 ：客户端入口 ClientWatcherManager ：客户端Watcher管理器 HostProvider：客户端地址列表管理器 ClientCnxn：客户端核心线程。包含两个线程，即SendThread和EventThread。前者是一个I&#x2F;O线程，主要负责ZooKeeper客户端和服务端之间">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/zk-source-build/20161104212932485.jpeg">
<meta property="og:image" content="http://example.com/images/zk-source-build/ef78b098db54fbec2d979e0e7edc23fe276181.png">
<meta property="og:image" content="http://example.com/images/zk-source-build/b3110ff83e94e0680dc5a266ffa6f603193666.png">
<meta property="og:image" content="http://example.com/images/zk-source-build//image-20210926101915851.png">
<meta property="og:image" content="http://example.com/images/zk-source-build//image-20210926104109116.png">
<meta property="article:published_time" content="2019-12-31T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-11T13:27:38.360Z">
<meta property="article:author" content="tlv">
<meta property="article:tag" content="Zookeeper">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/zk-source-build/20161104212932485.jpeg">

<link rel="canonical" href="http://example.com/2019/12/31/zk-source-build/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Zookeeper -- 客户端源码解析 | 温故而知新</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">温故而知新</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">8</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/12/31/zk-source-build/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="tlv">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="温故而知新">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Zookeeper -- 客户端源码解析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-01T00:00:00+08:00">2020-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-11 21:27:38" itemprop="dateModified" datetime="2022-05-11T21:27:38+08:00">2022-05-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Distributed/" itemprop="url" rel="index"><span itemprop="name">Distributed</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Distributed/Zookeeper/" itemprop="url" rel="index"><span itemprop="name">Zookeeper</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>37k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>34 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="客户端结构解析"><a href="#客户端结构解析" class="headerlink" title="客户端结构解析"></a>客户端结构解析</h2><h3 id="客户端结构图"><a href="#客户端结构图" class="headerlink" title="客户端结构图"></a>客户端结构图</h3><img src="/images/zk-source-build/20161104212932485.jpeg" alt="Zookeeper Client" style="zoom:80%;" />



<h3 id="客户端核心类"><a href="#客户端核心类" class="headerlink" title="客户端核心类"></a>客户端核心类</h3><p>zk客户端的核心组件如下：</p>
<ul>
<li>ZooKeeper实例 ：客户端入口</li>
<li>ClientWatcherManager ：客户端Watcher管理器</li>
<li>HostProvider：客户端地址列表管理器</li>
<li>ClientCnxn：客户端核心线程。包含两个线程，即SendThread和EventThread。前者是一个I/O线程，主要负责ZooKeeper客户端和服务端之间的网络I/O通信，后者是一个事件线程，主要负责对服务端事件进行处理。</li>
<li>ClientCnxnSocket：底层Socket通信层，有两个实现ClientCnxnSocketNetty、ClientCnxnSocketNIO</li>
</ul>
<p><img src="/images/zk-source-build/ef78b098db54fbec2d979e0e7edc23fe276181.png" alt="img"></p>
<h2 id="客户端启动流程"><a href="#客户端启动流程" class="headerlink" title="客户端启动流程"></a>客户端启动流程</h2><p>Zookeeper客户端初始化与启动环节，就是Zookeeper对象的实例化过程</p>
<ul>
<li>初始化 ZooKeeper 对象<ul>
<li>通过调用 ZooKeeper 的构造方法来实例化一个 ZooKeeper 对象，在初始化过程中， 会创建一个客户端的 Watcher 管理器： ClientWatchManager</li>
</ul>
</li>
<li>设置默认Watcher<ul>
<li>若在Zookeeper构造方法中传入Watcher对象时，那么Zookeeper就会将该Watcher对象保存在ZKWatcherManager的defaultWatcher中，并作为整个客户端会话期间的默认Watcher</li>
</ul>
</li>
<li>设置Zookeeper服务器地址列表<ul>
<li>对于构造方法中传入的服务器地址，客户端会将其存放在服务器地址列表管理器HostProvider 中</li>
<li>默认使用StaticHostProvider解析服务端地址<ul>
<li>Chroot：每个客户端可以设置自己的命名空间，若客户端设置了Chroot，客户端对服务器的任何操作都将被限制在自己的命名空间下，如设置Choot为/app/X，那么该客户端的所有节点路径都是以/app/X为根节点</li>
<li>StaticHostProvider将InetSocketAddress列表进行shuffle，形成一个环形循环队列，然后再依次取出服务器地址</li>
</ul>
</li>
</ul>
</li>
<li>创建ClientCnxn<ul>
<li>ZooKeeper 客户端首先会创建一个网络连接器 ClientCnxn, 用来管理客户端与服务器的网络交互。</li>
<li>初始化客户端两个核心队列 outgoingQueue 和 pendingQueue, 分别作为客户端的请求 发送队列和服务端响应的等待队列。ClientCnxn 连接器的底层 I/O 处理器是 ClientCnxnSocket,因此在这一步中，客户端还会同时创建 ClientCnxnSocket 处理器</li>
</ul>
</li>
</ul>
<p>启动流程图如下：</p>
<p><img src="/images/zk-source-build/b3110ff83e94e0680dc5a266ffa6f603193666.png" alt="img"></p>
<h2 id="会话创建阶段"><a href="#会话创建阶段" class="headerlink" title="会话创建阶段"></a>会话创建阶段</h2><ul>
<li>启动 SendThread 、EventThread</li>
<li>获取一个服务器地址<ul>
<li>serverAddress = hostProvider.next(1000);</li>
</ul>
</li>
<li>创建TCP连接<ul>
<li>org.apache.zookeeper.ClientCnxnSocket#connect</li>
</ul>
</li>
<li>构造ConnectRequest请求：以ClientCnxnSocketNetty为例，operationComplete中执行sendThread.primeConnection()，构造出一个ConnectRequest请求，该请求代表了客户端试图与服务端创建一个会话。同时，ZooKeeper客户端还会进一步将该请求包装成网络I/O层的Packet对象，放入请求发送队列outgoingQueue中去</li>
<li>发送请求：ClientCnxnSocket负责从outgoingQueue中取出一个待发送的Packet对象，将其序列化成ByteBuffer向服务端进行发送</li>
</ul>
<h3 id="客户端网络协议"><a href="#客户端网络协议" class="headerlink" title="客户端网络协议"></a>客户端网络协议</h3><h4 id="TCP自定义协议栈"><a href="#TCP自定义协议栈" class="headerlink" title="TCP自定义协议栈"></a>TCP自定义协议栈</h4><p>基于TCP/IP协议，Zookeeper实现了自己的通信协议来玩按成客户端与服务端、服务端与服务端之间的网络通信，对于请求，主要包含请求头和请求体，对于响应，主要包含响应头和响应体</p>
<table>
<thead>
<tr>
<th>len</th>
<th>请求头</th>
<th>请求体</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th>len</th>
<th>响应头</th>
<th>响应体</th>
</tr>
</thead>
</table>
<ul>
<li><p>请求协议</p>
<p><img src="/images/zk-source-build//image-20210926101915851.png" alt="image-20210926101915851"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RequestHeader</span> &#123;</span><br><span class="line">	<span class="type">int</span> xid;</span><br><span class="line">  <span class="type">int</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RequestHeader包含 <strong>xid</strong>、<strong>type</strong></p>
<ul>
<li> xid ：代表请求的顺序号，用于保证请求的顺序发送和接收</li>
<li>而 type 代表请求的类型</li>
</ul>
</li>
<li><p>响应协议</p>
<p><img src="/images/zk-source-build//image-20210926104109116.png" alt="image-20210926104109116"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReplyHeader</span> &#123;</span><br><span class="line">	<span class="type">int</span> xid;</span><br><span class="line">  <span class="type">long</span> zxid;</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReplyHeader 主要包括 <strong>xid</strong> 和 <strong>zxid</strong> 以及 <strong>err</strong> </p>
<ul>
<li>xid：与请求头中的xid一致</li>
<li>zxid：表示分布事务 id ，为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数</li>
<li>err：是一个错误码，表示当请求处理过程出现异常情况时，就会在错误码中标识出来，常见的包括处理成功（Code.OK）、节点不存在（Code.NONODE）、没有权限（Code.NOAUTH）</li>
</ul>
</li>
</ul>
<h4 id="Packet协议"><a href="#Packet协议" class="headerlink" title="Packet协议"></a>Packet协议</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Packet</span> &#123;</span><br><span class="line">	RequestHeader requestHeader;	<span class="comment">// 请求头信息</span></span><br><span class="line">	ReplyHeader replyHeader;		<span class="comment">// 响应头信息</span></span><br><span class="line"></span><br><span class="line">	Record request;		<span class="comment">// 请求数据</span></span><br><span class="line">	Record response;	<span class="comment">// 响应数据</span></span><br><span class="line"></span><br><span class="line">	AsyncCallback cb;	<span class="comment">// 异步回调</span></span><br><span class="line">  Object ctx;			<span class="comment">// 异步回调所需使用的 context</span></span><br><span class="line"></span><br><span class="line">	String clientPath;	<span class="comment">// 客户端路径视图</span></span><br><span class="line">  String serverPath;	<span class="comment">// 服务器的路径视图</span></span><br><span class="line">	<span class="type">boolean</span> finished;	<span class="comment">// 是否已经处理完成</span></span><br><span class="line">    </span><br><span class="line">  ByteBuffer bb;		</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> readOnly;</span><br><span class="line">  WatchRegistration watchRegistration;</span><br><span class="line">  WatchDeregistration watchDeregistration;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 省略方法逻辑..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="核心源码解析"><a href="#核心源码解析" class="headerlink" title="核心源码解析"></a>核心源码解析</h2><ol>
<li><p>建立网络连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ZooKeeper#ZooKeeper(java.lang.String, int, org.apache.zookeeper.Watcher, boolean, org.apache.zookeeper.client.HostProvider, org.apache.zookeeper.client.ZKClientConfig)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ZooKeeper</span><span class="params">(</span></span><br><span class="line"><span class="params">        String connectString,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> sessionTimeout,</span></span><br><span class="line"><span class="params">        Watcher watcher,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> canBeReadOnly,</span></span><br><span class="line"><span class="params">        HostProvider hostProvider,</span></span><br><span class="line"><span class="params">        ZKClientConfig clientConfig</span></span><br><span class="line"><span class="params">    )</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        LOG.info(</span><br><span class="line">            <span class="string">&quot;Initiating client connection, connectString=&#123;&#125; sessionTimeout=&#123;&#125; watcher=&#123;&#125;&quot;</span>,</span><br><span class="line">            connectString,</span><br><span class="line">            sessionTimeout,</span><br><span class="line">            watcher);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.clientConfig = clientConfig != <span class="literal">null</span> ? clientConfig : <span class="keyword">new</span> <span class="title class_">ZKClientConfig</span>();</span><br><span class="line">        <span class="built_in">this</span>.hostProvider = hostProvider;</span><br><span class="line">        <span class="type">ConnectStringParser</span> <span class="variable">connectStringParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectStringParser</span>(connectString);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接管理器</span></span><br><span class="line">        cnxn = createConnection(</span><br><span class="line">            connectStringParser.getChrootPath(),</span><br><span class="line">            hostProvider,</span><br><span class="line">            sessionTimeout,</span><br><span class="line">            <span class="built_in">this</span>.clientConfig,</span><br><span class="line">            watcher,</span><br><span class="line">            getClientCnxnSocket(),</span><br><span class="line">            canBeReadOnly);</span><br><span class="line">        cnxn.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先建立一个 Zookeeper 客户端时需要创建一个 Zookeeper 对象，且在这个 Zookeeper 对象创建的过程中会创建一个客户端连接管理器（ClientCnxn），接着在创建 ClientCnxn 的过程中又需要创建一个 ClientCnxnSocket 用于实现客户端间的通信，跟进这个 getClientCnxnSocket 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ZooKeeper#getClientCnxnSocket</span></span><br><span class="line"><span class="keyword">private</span> ClientCnxnSocket <span class="title function_">getClientCnxnSocket</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 从配置文件中获取 ClientCnxnSocket 配置信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">clientCnxnSocketName</span> <span class="operator">=</span> getClientConfig().getProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);</span><br><span class="line">        <span class="comment">// 如果配置文件中没有提供 ClientCnxnSocket 配置信息 或者 配置信息为ClientCnxnSocketNIO 则默认使用 NIO</span></span><br><span class="line">        <span class="keyword">if</span> (clientCnxnSocketName == <span class="literal">null</span> || clientCnxnSocketName.equals(ClientCnxnSocketNIO.class.getSimpleName())) &#123;</span><br><span class="line">            clientCnxnSocketName = ClientCnxnSocketNIO.class.getName();</span><br><span class="line">        <span class="comment">// 如果配置信息为ClientCnxnSocketNetty 则使用 Netty</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clientCnxnSocketName.equals(ClientCnxnSocketNetty.class.getSimpleName())) &#123;</span><br><span class="line">            clientCnxnSocketName = ClientCnxnSocketNetty.class.getName();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过反射获取 ClientCnxnSocket 的构造方法</span></span><br><span class="line">            Constructor&lt;?&gt; clientCxnConstructor = Class.forName(clientCnxnSocketName)</span><br><span class="line">                                                       .getDeclaredConstructor(ZKClientConfig.class);</span><br><span class="line">            <span class="comment">// 通过以客户端配置为入参调用构造方法来创建一个 ClientCnxnSocket 实例</span></span><br><span class="line">            <span class="type">ClientCnxnSocket</span> <span class="variable">clientCxnSocket</span> <span class="operator">=</span> (ClientCnxnSocket) clientCxnConstructor.newInstance(getClientConfig());</span><br><span class="line">            <span class="keyword">return</span> clientCxnSocket;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Couldn&#x27;t instantiate &quot;</span> + clientCnxnSocketName, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>getClientCnxnSocket 方法中会选择 ClientCnxnSocket 的实现方式，目前的 Zookeeper 中存在两个实现版本，一个是使用 Java JDK 中的 NIO 实现的 ClientCnxnSocketNIO ，另一个是使用 Netty 实现的 ClientCnxnSocketNetty ，而选择的方式优先根据配置文件中的配置进行选择，如果没有进行配置则默认选择 ClientCnxnSocketNIO 实现版本，之后再通过反射的方式创建其实例对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxnSocketNetty#ClientCnxnSocketNetty</span></span><br><span class="line">ClientCnxnSocketNetty(ZKClientConfig clientConfig) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.clientConfig = clientConfig;</span><br><span class="line">        <span class="comment">// Client only has 1 outgoing socket, so the event loop group only needs</span></span><br><span class="line">        <span class="comment">// a single thread.</span></span><br><span class="line">  			<span class="comment">// 创建一个 eventLoopGroup 用于后面对异步请求的处理</span></span><br><span class="line">        <span class="comment">// 且因为客户端只有一个 outgoing Socket 因此只需要一个线程即可</span></span><br><span class="line">        eventLoopGroup = NettyUtils.newNioOrEpollEventLoopGroup(<span class="number">1</span> <span class="comment">/* nThreads */</span>);</span><br><span class="line">        initProperties();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.common.NettyUtils#newNioOrEpollEventLoopGroup(int)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> EventLoopGroup <span class="title function_">newNioOrEpollEventLoopGroup</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 Epoll 可用（ Linux ）则优先使用 EpollEventLoopGroup 否则使用 NioEventLoopGroup</span></span><br><span class="line">        <span class="keyword">if</span> (Epoll.isAvailable()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EpollEventLoopGroup</span>(nThreads);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(nThreads);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以 Netty 实现为准，所以选择 ClientCnxnSocketNetty 实现版本，在 ClientCnxnSocketNetty 的构造方法中会选择具体的 EventLoopGroup 的实现，如果是在 Linux 优先选择使用性能更高的 EpollEventLoopGroup 实现，且这里配置的线程数目为一，因此这是典型的单线程Reactor实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ZooKeeper#createConnection</span></span><br><span class="line">ClientCnxn <span class="title function_">createConnection</span><span class="params">(</span></span><br><span class="line"><span class="params">        String chrootPath,</span></span><br><span class="line"><span class="params">        HostProvider hostProvider,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> sessionTimeout,</span></span><br><span class="line"><span class="params">        ZKClientConfig clientConfig,</span></span><br><span class="line"><span class="params">        Watcher defaultWatcher,</span></span><br><span class="line"><span class="params">        ClientCnxnSocket clientCnxnSocket,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> canBeReadOnly</span></span><br><span class="line"><span class="params">    )</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientCnxn</span>(</span><br><span class="line">            chrootPath,</span><br><span class="line">            hostProvider,</span><br><span class="line">            sessionTimeout,</span><br><span class="line">            clientConfig,</span><br><span class="line">            defaultWatcher,</span><br><span class="line">            clientCnxnSocket,</span><br><span class="line">            canBeReadOnly);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxn#ClientCnxn(java.lang.String, org.apache.zookeeper.client.HostProvider, int, org.apache.zookeeper.client.ZKClientConfig, org.apache.zookeeper.Watcher, org.apache.zookeeper.ClientCnxnSocket, long, byte[], boolean)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ClientCnxn</span><span class="params">(</span></span><br><span class="line"><span class="params">        String chrootPath,</span></span><br><span class="line"><span class="params">        HostProvider hostProvider,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> sessionTimeout,</span></span><br><span class="line"><span class="params">        ZKClientConfig clientConfig,</span></span><br><span class="line"><span class="params">        Watcher defaultWatcher,</span></span><br><span class="line"><span class="params">        ClientCnxnSocket clientCnxnSocket,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> sessionId,</span></span><br><span class="line"><span class="params">        <span class="type">byte</span>[] sessionPasswd,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> canBeReadOnly</span></span><br><span class="line"><span class="params">    )</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.chrootPath = chrootPath;</span><br><span class="line">        <span class="built_in">this</span>.hostProvider = hostProvider;</span><br><span class="line">        <span class="built_in">this</span>.sessionTimeout = sessionTimeout;</span><br><span class="line">        <span class="built_in">this</span>.clientConfig = clientConfig;</span><br><span class="line">        <span class="built_in">this</span>.sessionId = sessionId;</span><br><span class="line">        <span class="built_in">this</span>.sessionPasswd = sessionPasswd;</span><br><span class="line">        <span class="built_in">this</span>.readOnly = canBeReadOnly;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.watchManager = <span class="keyword">new</span> <span class="title class_">ZKWatchManager</span>(</span><br><span class="line">                clientConfig.getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET),</span><br><span class="line">                defaultWatcher);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.connectTimeout = sessionTimeout / hostProvider.size();</span><br><span class="line">        <span class="built_in">this</span>.readTimeout = sessionTimeout * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化SendThread，管理客户端和服务端之间的网络I/O，依赖于clientCnxnSocket，守护线程</span></span><br><span class="line">        <span class="built_in">this</span>.sendThread = <span class="keyword">new</span> <span class="title class_">SendThread</span>(clientCnxnSocket);</span><br><span class="line">        <span class="comment">// 初始化EventThread，用于事件处理，会被设置为守护线程</span></span><br><span class="line">        <span class="built_in">this</span>.eventThread = <span class="keyword">new</span> <span class="title class_">EventThread</span>();</span><br><span class="line">        <span class="comment">// 初始化超时机制</span></span><br><span class="line">        initRequestTimeout();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>经过getClientCnxnSocket，继续看Zookeeper 构造方法中的createConnection方法，本质上是创建了一个ClientCnxn对象，并在 ClientCnxn 的构造方法中创建了 SendThread 发送线程和 EventThread 事件处理线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxn#start</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 启动sendThread、eventThread</span></span><br><span class="line">        sendThread.start();</span><br><span class="line">        eventThread.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当完成 SendThread 和 EventThread 这两个线程的创建和初始化后，在 Zookeeper 的构造方法中最后会通过 cnxn.start() 方法启动这两个线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxn.SendThread#run</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 设置clientCnxnSocket相关属性，sessionId用于 Log and Exception messages</span></span><br><span class="line">            clientCnxnSocket.introduce(<span class="built_in">this</span>, sessionId, outgoingQueue);</span><br><span class="line">            <span class="comment">//初始化当前时间 now = Time.currentElapsedTime() = System.nanoTime() / 1000000;</span></span><br><span class="line">            clientCnxnSocket.updateNow();</span><br><span class="line">            <span class="comment">// 更新发信、收信时间 this.lastSend = now;this.lastHeard = now;</span></span><br><span class="line">            clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">            <span class="type">int</span> to;</span><br><span class="line">            <span class="comment">// 最后ping读写时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">lastPingRwServer</span> <span class="operator">=</span> Time.currentElapsedTime();</span><br><span class="line">            <span class="comment">// 最大send ping时间间隔 10S</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SEND_PING_INTERVAL</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">//10 seconds</span></span><br><span class="line">            <span class="type">InetSocketAddress</span> <span class="variable">serverAddress</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// state != CLOSED &amp;&amp; state != AUTH_FAILED</span></span><br><span class="line">            <span class="keyword">while</span> (state.isAlive()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// clientCnxnSocket 没有连接到服务端</span></span><br><span class="line">                    <span class="keyword">if</span> (!clientCnxnSocket.isConnected()) &#123;</span><br><span class="line">                        <span class="comment">// don&#x27;t re-establish connection if we are closing</span></span><br><span class="line">                        <span class="keyword">if</span> (closing) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果读写服务器地址不为空，用读写服务器地址</span></span><br><span class="line">                        <span class="keyword">if</span> (rwServerAddress != <span class="literal">null</span>) &#123;</span><br><span class="line">                            serverAddress = rwServerAddress;</span><br><span class="line">                            rwServerAddress = <span class="literal">null</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 挨个访问服务器地址列表里的地址，间隔 1 s</span></span><br><span class="line">                            serverAddress = hostProvider.next(<span class="number">1000</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        onConnecting(serverAddress);</span><br><span class="line">                        <span class="comment">// 开始连接</span></span><br><span class="line">                        startConnect(serverAddress);</span><br><span class="line">                        <span class="comment">// Update now to start the connection timer right after we make a connection attempt</span></span><br><span class="line">                        clientCnxnSocket.updateNow();</span><br><span class="line">                        <span class="comment">// 更新Socket最后一次发送以及接收消息的时间</span></span><br><span class="line">                        clientCnxnSocket.updateLastSendAndHeard();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (state.isConnected()) &#123;</span><br><span class="line">                        <span class="comment">// determine whether we need to send an AuthFailed event.</span></span><br><span class="line">                        <span class="keyword">if</span> (zooKeeperSaslClient != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="type">boolean</span> <span class="variable">sendAuthEvent</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">if</span> (zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.INITIAL) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    zooKeeperSaslClient.initialize(ClientCnxn.<span class="built_in">this</span>);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (SaslException e) &#123;</span><br><span class="line">                                    LOG.error(<span class="string">&quot;SASL authentication with Zookeeper Quorum member failed.&quot;</span>, e);</span><br><span class="line">                                    changeZkState(States.AUTH_FAILED);</span><br><span class="line">                                    sendAuthEvent = <span class="literal">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="type">KeeperState</span> <span class="variable">authState</span> <span class="operator">=</span> zooKeeperSaslClient.getKeeperState();</span><br><span class="line">                            <span class="keyword">if</span> (authState != <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (authState == KeeperState.AuthFailed) &#123;</span><br><span class="line">                                    <span class="comment">// An authentication error occurred during authentication with the Zookeeper Server.</span></span><br><span class="line">                                    changeZkState(States.AUTH_FAILED);</span><br><span class="line">                                    sendAuthEvent = <span class="literal">true</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (authState == KeeperState.SaslAuthenticated) &#123;</span><br><span class="line">                                        sendAuthEvent = <span class="literal">true</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (sendAuthEvent) &#123;</span><br><span class="line">                                eventThread.queueEvent(<span class="keyword">new</span> <span class="title class_">WatchedEvent</span>(Watcher.Event.EventType.None, authState, <span class="literal">null</span>));</span><br><span class="line">                                <span class="keyword">if</span> (state == States.AUTH_FAILED) &#123;</span><br><span class="line">                                    eventThread.queueEventOfDeath();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        to = readTimeout - clientCnxnSocket.getIdleRecv();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        to = connectTimeout - clientCnxnSocket.getIdleRecv();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 连接超时</span></span><br><span class="line">                    <span class="keyword">if</span> (to &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">warnInfo</span> <span class="operator">=</span> String.format(</span><br><span class="line">                            <span class="string">&quot;Client session timed out, have not heard from server in %dms for session id 0x%s&quot;</span>,</span><br><span class="line">                            clientCnxnSocket.getIdleRecv(),</span><br><span class="line">                            Long.toHexString(sessionId));</span><br><span class="line">                        LOG.warn(warnInfo);</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SessionTimeoutException</span>(warnInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (state.isConnected()) &#123;</span><br><span class="line">                        <span class="comment">//1000(1 second) is to prevent race condition missing to send the second ping</span></span><br><span class="line">                        <span class="comment">//also make sure not to send too many pings when readTimeout is small</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">timeToNextPing</span> <span class="operator">=</span> readTimeout / <span class="number">2</span></span><br><span class="line">                                             - clientCnxnSocket.getIdleSend()</span><br><span class="line">                                             - ((clientCnxnSocket.getIdleSend() &gt; <span class="number">1000</span>) ? <span class="number">1000</span> : <span class="number">0</span>);</span><br><span class="line">                        <span class="comment">//send a ping request either time is due or no packet sent out within MAX_SEND_PING_INTERVAL</span></span><br><span class="line">                        <span class="keyword">if</span> (timeToNextPing &lt;= <span class="number">0</span> || clientCnxnSocket.getIdleSend() &gt; MAX_SEND_PING_INTERVAL) &#123;</span><br><span class="line">                            sendPing();</span><br><span class="line">                            clientCnxnSocket.updateLastSend();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (timeToNextPing &lt; to) &#123;</span><br><span class="line">                                to = timeToNextPing;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// If we are in read-only mode, seek for read/write server</span></span><br><span class="line">                    <span class="keyword">if</span> (state == States.CONNECTEDREADONLY) &#123;</span><br><span class="line">                        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> Time.currentElapsedTime();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">idlePingRwServer</span> <span class="operator">=</span> (<span class="type">int</span>) (now - lastPingRwServer);</span><br><span class="line">                        <span class="keyword">if</span> (idlePingRwServer &gt;= pingRwTimeout) &#123;</span><br><span class="line">                            lastPingRwServer = now;</span><br><span class="line">                            idlePingRwServer = <span class="number">0</span>;</span><br><span class="line">                            pingRwTimeout = Math.min(<span class="number">2</span> * pingRwTimeout, maxPingRwTimeout);</span><br><span class="line">                            pingRwServer();</span><br><span class="line">                        &#125;</span><br><span class="line">                        to = Math.min(to, pingRwTimeout - idlePingRwServer);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 处理真正的 I/O 操作</span></span><br><span class="line">                    clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.<span class="built_in">this</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (closing) &#123;</span><br><span class="line">                        <span class="comment">// closing so this is expected</span></span><br><span class="line">                        LOG.warn(</span><br><span class="line">                            <span class="string">&quot;An exception was thrown while closing send thread for session 0x&#123;&#125;.&quot;</span>,</span><br><span class="line">                            Long.toHexString(getSessionId()),</span><br><span class="line">                            e);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        LOG.warn(</span><br><span class="line">                            <span class="string">&quot;Session 0x&#123;&#125; for sever &#123;&#125;, Closing socket connection. &quot;</span></span><br><span class="line">                                + <span class="string">&quot;Attempting reconnect except it is a SessionExpiredException.&quot;</span>,</span><br><span class="line">                            Long.toHexString(getSessionId()),</span><br><span class="line">                            serverAddress,</span><br><span class="line">                            e);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// At this point, there might still be new packets appended to outgoingQueue.</span></span><br><span class="line">                        <span class="comment">// they will be handled in next connection or cleared up if closed.</span></span><br><span class="line">                        cleanAndNotifyState();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">                <span class="comment">// When it comes to this point, it guarantees that later queued</span></span><br><span class="line">                <span class="comment">// packet to outgoingQueue will be notified of death.</span></span><br><span class="line">                cleanup();</span><br><span class="line">            &#125;</span><br><span class="line">            clientCnxnSocket.close();</span><br><span class="line">            <span class="keyword">if</span> (state.isAlive()) &#123;</span><br><span class="line">                eventThread.queueEvent(<span class="keyword">new</span> <span class="title class_">WatchedEvent</span>(Event.EventType.None, Event.KeeperState.Disconnected, <span class="literal">null</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            eventThread.queueEvent(<span class="keyword">new</span> <span class="title class_">WatchedEvent</span>(Event.EventType.None, Event.KeeperState.Closed, <span class="literal">null</span>));</span><br><span class="line">            ZooTrace.logTraceMessage(</span><br><span class="line">                LOG,</span><br><span class="line">                ZooTrace.getTextTraceLevel(),</span><br><span class="line">                <span class="string">&quot;SendThread exited loop for session: 0x&quot;</span> + Long.toHexString(getSessionId()));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxn.SendThread#startConnect</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startConnect</span><span class="params">(InetSocketAddress addr)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">// initializing it for new connection</span></span><br><span class="line">            saslLoginFailed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!isFirstConnect) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(ThreadLocalRandom.current().nextLong(<span class="number">1000</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置状态为 CONNECTING</span></span><br><span class="line">            changeZkState(States.CONNECTING);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">hostPort</span> <span class="operator">=</span> addr.getHostString() + <span class="string">&quot;:&quot;</span> + addr.getPort();</span><br><span class="line">            MDC.put(<span class="string">&quot;myid&quot;</span>, hostPort);</span><br><span class="line">            setName(getName().replaceAll(<span class="string">&quot;\\(.*\\)&quot;</span>, <span class="string">&quot;(&quot;</span> + hostPort + <span class="string">&quot;)&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (clientConfig.isSaslClientEnabled()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (zooKeeperSaslClient != <span class="literal">null</span>) &#123;</span><br><span class="line">                        zooKeeperSaslClient.shutdown();</span><br><span class="line">                    &#125;</span><br><span class="line">                    zooKeeperSaslClient = <span class="keyword">new</span> <span class="title class_">ZooKeeperSaslClient</span>(SaslServerPrincipal.getServerPrincipal(addr, clientConfig), clientConfig);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (LoginException e) &#123;</span><br><span class="line">                    <span class="comment">// An authentication error occurred when the SASL client tried to initialize:</span></span><br><span class="line">                    <span class="comment">// for Kerberos this means that the client failed to authenticate with the KDC.</span></span><br><span class="line">                    <span class="comment">// This is different from an authentication error that occurs during communication</span></span><br><span class="line">                    <span class="comment">// with the Zookeeper server, which is handled below.</span></span><br><span class="line">                    LOG.warn(</span><br><span class="line">                        <span class="string">&quot;SASL configuration failed. &quot;</span></span><br><span class="line">                            + <span class="string">&quot;Will continue connection to Zookeeper server without &quot;</span></span><br><span class="line">                            + <span class="string">&quot;SASL authentication, if Zookeeper server allows it.&quot;</span>, e);</span><br><span class="line">                    eventThread.queueEvent(<span class="keyword">new</span> <span class="title class_">WatchedEvent</span>(Watcher.Event.EventType.None, Watcher.Event.KeeperState.AuthFailed, <span class="literal">null</span>));</span><br><span class="line">                    saslLoginFailed = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            logStartConnect(addr);</span><br><span class="line">            <span class="comment">// 调用 ClientCnxnSocket 的 connect 方法尝试连接</span></span><br><span class="line">            clientCnxnSocket.connect(addr);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在 SendThread 的 run 方法中会启动初始化连接的流程，并且最终会调用到 ClientCnxnSocketNetty 的 connect 方法来建立客户端网络通信的连接，netty连接逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxnSocketNetty#connect</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(InetSocketAddress addr)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        firstConnect = <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 netty Bootstrap</span></span><br><span class="line">        <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>().group(eventLoopGroup) <span class="comment">// 设置 eventLoopGroup</span></span><br><span class="line">                                             .channel(NettyUtils.nioOrEpollSocketChannel()) <span class="comment">// 选择合适的 SocketChannel</span></span><br><span class="line">                                             .option(ChannelOption.SO_LINGER, -<span class="number">1</span>) <span class="comment">// 对应套接字选项SO_LINGER</span></span><br><span class="line">                                             .option(ChannelOption.TCP_NODELAY, <span class="literal">true</span>) <span class="comment">// 对应套接字选项 TCP_NODELAY</span></span><br><span class="line">                                             .handler(<span class="keyword">new</span> <span class="title class_">ZKClientPipelineFactory</span>(addr.getHostString(), addr.getPort())); <span class="comment">// 设置处理器</span></span><br><span class="line">        bootstrap = configureBootstrapAllocator(bootstrap);</span><br><span class="line">        bootstrap.validate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 connectLock</span></span><br><span class="line">        connectLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Netty 异步调用</span></span><br><span class="line">            connectFuture = bootstrap.connect(addr);</span><br><span class="line">            <span class="comment">// 监听并处理返回结果</span></span><br><span class="line">            connectFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="comment">// this lock guarantees that channel won&#x27;t be assigned after cleanup().</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">connected</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                    connectLock.lock();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!channelFuture.isSuccess()) &#123;</span><br><span class="line">                            LOG.warn(<span class="string">&quot;future isn&#x27;t success.&quot;</span>, channelFuture.cause());</span><br><span class="line">                            <span class="comment">// 连接失败则直接返回</span></span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (connectFuture == <span class="literal">null</span>) &#123;</span><br><span class="line">                            LOG.info(<span class="string">&quot;connect attempt cancelled&quot;</span>);</span><br><span class="line">                            <span class="comment">// If the connect attempt was cancelled but succeeded</span></span><br><span class="line">                            <span class="comment">// anyway, make sure to close the channel, otherwise</span></span><br><span class="line">                            <span class="comment">// we may leak a file descriptor.</span></span><br><span class="line">                            <span class="comment">// 如果 connectFuture 为空则证明尝试连接被取消</span></span><br><span class="line">                            <span class="comment">// 但是因为可能已经连接成功了，所以应当确保 channel 被正常关闭</span></span><br><span class="line">                            channelFuture.channel().close();</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// setup channel, variables, connection, etc.</span></span><br><span class="line">                        channel = channelFuture.channel();</span><br><span class="line"></span><br><span class="line">                        disconnected.set(<span class="literal">false</span>);</span><br><span class="line">                        initialized = <span class="literal">false</span>;</span><br><span class="line">                        <span class="comment">// lenBuffer 仅用于读取传入消息的长度（该 Buffer 长度为 4 byte）</span></span><br><span class="line">                        lenBuffer.clear();</span><br><span class="line">                        incomingBuffer = lenBuffer;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 构建ConnectRequest 设置 Session、之前的观察者和身份验证</span></span><br><span class="line">                        sendThread.primeConnection();</span><br><span class="line">                        updateNow();</span><br><span class="line">                        updateLastSendAndHeard();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (sendThread.tunnelAuthInProgress()) &#123;</span><br><span class="line">                            waitSasl.drainPermits();</span><br><span class="line">                            needSasl.set(<span class="literal">true</span>);</span><br><span class="line">                            sendPrimePacket();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            needSasl.set(<span class="literal">false</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        connected = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        connectFuture = <span class="literal">null</span>;</span><br><span class="line">                        connectLock.unlock();</span><br><span class="line">                        <span class="keyword">if</span> (connected) &#123;</span><br><span class="line">                            LOG.info(<span class="string">&quot;channel is connected: &#123;&#125;&quot;</span>, channelFuture.channel());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// need to wake on connect success or failure to avoid</span></span><br><span class="line">                        <span class="comment">// timing out ClientCnxn.SendThread which may be</span></span><br><span class="line">                        <span class="comment">// blocked waiting for first connect in doTransport().</span></span><br><span class="line">                        <span class="comment">// 唤醒发送线程中的发送逻辑（向 outgoingQueue 中添加一个 WakeupPacket 空包）</span></span><br><span class="line">                        wakeupCnxn();</span><br><span class="line">                        <span class="comment">// 避免 ClientCnxn 中的 SendThread 在 doTransport() 中等待第一次连接而被阻塞并最终超时</span></span><br><span class="line">                        firstConnect.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放connectLock</span></span><br><span class="line">            connectLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>connect方法注意点：</p>
<ul>
<li><p>设置 Bootstrap 的Handler为 ZKClientPipelineFactory，准确来说是 ZKClientHandler（如下）；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">            <span class="keyword">if</span> (clientConfig.getBoolean(ZKClientConfig.SECURE_CLIENT)) &#123;</span><br><span class="line">                initSSL(pipeline);</span><br><span class="line">            &#125;</span><br><span class="line">            pipeline.addLast(<span class="string">&quot;handler&quot;</span>, <span class="keyword">new</span> <span class="title class_">ZKClientHandler</span>());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化设置 incomingBuffer = lenBuffer，保证第一次读入的是数据包中真实数据的长度（首部 4byte ByteBuffer）</p>
</li>
<li><p>完成连接后需要通过 wakeupCnxn() 方法来唤醒发送线程的发送逻辑（实质是发送一个空的 WakeupPacket）</p>
</li>
</ul>
</li>
<li><p>SendThread 从 outgoingQueue 获取并发送 Packet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxn.SendThread#run</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (state.isAlive()) &#123;</span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!clientCnxnSocket.isConnected()) &#123;</span><br><span class="line">            	<span class="comment">// 连接服务端逻辑..</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 省略部分代码..</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 发送 outgoingQueue 中的数据包并将已发送的数据包转移到 PendingQueue 中</span></span><br><span class="line">      clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.<span class="built_in">this</span>);</span><br><span class="line">        	</span><br><span class="line">      <span class="comment">// 省略部分代码..</span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>当完成了客户端连接后即可进入到请求发送的逻辑中，客户端发送请求的逻辑主要位于 ClientCnxn 的 SendThread 线程中，在初始化时我们已经启动了该线程，所以当连接建立完成后会通过调用 clientCnxnSocket （ ClientCnxnSocketNetty ）的 <strong>doTransport</strong> 方法发送位于 outgoingQueue 中的 Packet 请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxnSocketNetty#doTransport</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doTransport</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">int</span> waitTimeOut,</span></span><br><span class="line"><span class="params">        Queue&lt;Packet&gt; pendingQueue,</span></span><br><span class="line"><span class="params">        ClientCnxn cnxn)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 该线程方法会等待连接的建立且超时即返回</span></span><br><span class="line">            <span class="keyword">if</span> (!firstConnect.await(waitTimeOut, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Packet</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (needSasl.get()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!waitSasl.tryAcquire(waitTimeOut, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 从 outgoingQueue 队列中获取要发送的 Packet</span></span><br><span class="line">                head = outgoingQueue.poll(waitTimeOut, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// check if being waken up on closing.</span></span><br><span class="line">            <span class="comment">// 检查当前是否正处于关闭流程中</span></span><br><span class="line">            <span class="keyword">if</span> (!sendThread.getZkState().isAlive()) &#123;</span><br><span class="line">                <span class="comment">// adding back the packet to notify of failure in conLossPacket(). 添加数据包以通知conLossPacket()中的失败</span></span><br><span class="line">                addBack(head);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// channel disconnection happened</span></span><br><span class="line">            <span class="comment">// 当通道断开时</span></span><br><span class="line">            <span class="keyword">if</span> (disconnected.get()) &#123;</span><br><span class="line">                addBack(head);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EndOfStreamException</span>(<span class="string">&quot;channel for sessionid 0x&quot;</span> + Long.toHexString(sessionId) + <span class="string">&quot; is lost&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用 doWrite 方法执行实际的发送数据操作</span></span><br><span class="line">                doWrite(pendingQueue, head, cnxn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            updateNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在 doTransport 方法中首先会 await 等待连接建立，并且在超时后会立即返回（因此在连接建立后需要第一时间唤醒该线程以避免其超时返回），之后会从 outgoingQueue 中取出待发送的 Packet ，并在进行一系列验证后通过 doWrite 方法来实际发送该 Packet </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doWrite</span><span class="params">(Queue&lt;Packet&gt; pendingQueue, Packet p, ClientCnxn cnxn)</span> &#123;</span><br><span class="line">        updateNow();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">anyPacketsSent</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 跳过处理 WakeupPacket 数据包</span></span><br><span class="line">            <span class="keyword">if</span> (p != WakeupPacket.getInstance()) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p.requestHeader != <span class="literal">null</span>)</span><br><span class="line">                    &amp;&amp; (p.requestHeader.getType() != ZooDefs.OpCode.ping)</span><br><span class="line">                    &amp;&amp; (p.requestHeader.getType() != ZooDefs.OpCode.auth)) &#123;</span><br><span class="line">                    p.requestHeader.setXid(cnxn.getXid());</span><br><span class="line">                    <span class="keyword">synchronized</span> (pendingQueue) &#123;</span><br><span class="line">                        <span class="comment">// 将该 Packet 添加到 pendingQueue 队列中</span></span><br><span class="line">                        pendingQueue.add(p);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 只发送数据包到通道，而不刷新通道</span></span><br><span class="line">                sendPktOnly(p);</span><br><span class="line">                <span class="comment">// 记录本轮存在需要被发送的数据</span></span><br><span class="line">                anyPacketsSent = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (outgoingQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从outgoingQueue 队列获取 Packet</span></span><br><span class="line">            p = outgoingQueue.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> maybe we should flush in the loop above every N packets/bytes?</span></span><br><span class="line">        <span class="comment">// But, how do we determine the right value for N ...</span></span><br><span class="line">        <span class="comment">// 如果本轮存在需要被发送的数据，则调用 flush 刷新 Netty 通道</span></span><br><span class="line">        <span class="keyword">if</span> (anyPacketsSent) &#123;</span><br><span class="line">            channel.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在 doWrite 方法中会在验证该 Packet 非 WakeupPacket 后为其设置请求头中的 xid ，并将其添加到 pendingQueue 中，最后通过 sendPktOnly 方法将其发送到通道中（暂不刷新通道，方法代码如下），然后如果 outgoingQueue 中仍存在待发送的 Packet 则继续重复执行添加 pendingQueue 并发送的逻辑，当 outgoingQueue 中的 Packet 全部处理完成后调用 channel.flush() 刷新通道，将本轮数据一起发送</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxnSocketNetty#sendPktOnly</span></span><br><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">sendPktOnly</span><span class="params">(Packet p)</span> &#123;</span><br><span class="line">	<span class="comment">// 仅发送数据包到通道，而不调用 flush() 方法刷新通道</span></span><br><span class="line">    <span class="keyword">return</span> sendPkt(p, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxnSocketNetty#sendPkt</span></span><br><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">sendPkt</span><span class="params">(Packet p, <span class="type">boolean</span> doFlush)</span> &#123;</span><br><span class="line">	<span class="comment">// 创建 ByteBuffer</span></span><br><span class="line">    p.createBB();</span><br><span class="line">    updateLastSend();</span><br><span class="line">    <span class="comment">// 将 ByteBuffer 转化为 Netty 的 ByteBuf</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">writeBuffer</span> <span class="operator">=</span> Unpooled.wrappedBuffer(p.bb);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">result</span> <span class="operator">=</span> doFlush</span><br><span class="line">            ? channel.writeAndFlush(writeBuffer)</span><br><span class="line">            : channel.write(writeBuffer);</span><br><span class="line">    result.addListener(onSendPktDoneListener);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>同步RPC调用流程（Create Api）</p>
<p><strong>同步Create Api入口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ZooKeeper#create(java.lang.String, byte[], java.util.List&lt;org.apache.zookeeper.data.ACL&gt;, org.apache.zookeeper.CreateMode)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">create</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> String path,</span></span><br><span class="line"><span class="params">        <span class="type">byte</span>[] data,</span></span><br><span class="line"><span class="params">        List&lt;ACL&gt; acl,</span></span><br><span class="line"><span class="params">        CreateMode createMode)</span> <span class="keyword">throws</span> KeeperException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">clientPath</span> <span class="operator">=</span> path;</span><br><span class="line">        <span class="comment">// 相关信息验证</span></span><br><span class="line">        PathUtils.validatePath(clientPath, createMode.isSequential());</span><br><span class="line">        EphemeralType.validateTTL(createMode, -<span class="number">1</span>);</span><br><span class="line">        validateACL(acl);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">serverPath</span> <span class="operator">=</span> prependChroot(clientPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 Request 请求包和 Response 响应包</span></span><br><span class="line">        <span class="type">RequestHeader</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestHeader</span>();</span><br><span class="line">        h.setType(createMode.isContainer() ? ZooDefs.OpCode.createContainer : ZooDefs.OpCode.create);</span><br><span class="line">        <span class="type">CreateRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateRequest</span>();</span><br><span class="line">        <span class="type">CreateResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateResponse</span>();</span><br><span class="line">        request.setData(data);</span><br><span class="line">        request.setFlags(createMode.toFlag());</span><br><span class="line">        request.setPath(serverPath);</span><br><span class="line">        request.setAcl(acl);</span><br><span class="line">        <span class="comment">// 提交请求并接收返回头</span></span><br><span class="line">        <span class="type">ReplyHeader</span> <span class="variable">r</span> <span class="operator">=</span> cnxn.submitRequest(h, request, response, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 处理异常</span></span><br><span class="line">        <span class="keyword">if</span> (r.getErr() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (cnxn.chrootPath == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> response.getPath();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> response.getPath().substring(cnxn.chrootPath.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>同步Api中 Create 方法的逻辑可以概括为以下五步:</p>
<ul>
<li>验证相关信息的有效性（包括验证客户端的路径以及创建模式的选择）</li>
<li>创建 <strong>Request</strong> 请求包和 <strong>Response</strong> 响应包，并为 Request 请求包填充数据</li>
<li>通过调用 <strong>ClientCnxn</strong> 的 <strong>submitRequest</strong> 方法提交请求并接收请求结果</li>
<li>处理请求结果中的异常</li>
<li>返回请求结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxn#submitRequest(org.apache.zookeeper.proto.RequestHeader, org.apache.jute.Record, org.apache.jute.Record, org.apache.zookeeper.ZooKeeper.WatchRegistration, org.apache.zookeeper.WatchDeregistration)</span></span><br><span class="line"><span class="keyword">public</span> ReplyHeader <span class="title function_">submitRequest</span><span class="params">(</span></span><br><span class="line"><span class="params">        RequestHeader h,</span></span><br><span class="line"><span class="params">        Record request,</span></span><br><span class="line"><span class="params">        Record response,</span></span><br><span class="line"><span class="params">        WatchRegistration watchRegistration,</span></span><br><span class="line"><span class="params">        WatchDeregistration watchDeregistration)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ReplyHeader</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReplyHeader</span>();</span><br><span class="line">        <span class="comment">// 根据 Request 数据和 Response 数据打包创建 Packet</span></span><br><span class="line">        <span class="type">Packet</span> <span class="variable">packet</span> <span class="operator">=</span> queuePacket(</span><br><span class="line">            h,</span><br><span class="line">            r,</span><br><span class="line">            request,</span><br><span class="line">            response,</span><br><span class="line">            <span class="literal">null</span>,</span><br><span class="line">            <span class="literal">null</span>,</span><br><span class="line">            <span class="literal">null</span>,</span><br><span class="line">            <span class="literal">null</span>,</span><br><span class="line">            watchRegistration,</span><br><span class="line">            watchDeregistration);</span><br><span class="line">        <span class="keyword">synchronized</span> (packet) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requestTimeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Wait for request completion with timeout</span></span><br><span class="line">                <span class="comment">// 等待请求完成超时</span></span><br><span class="line">                waitForPacketFinish(r, packet);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Wait for request completion infinitely</span></span><br><span class="line">                <span class="comment">// 等待请求完成</span></span><br><span class="line">                <span class="keyword">while</span> (!packet.finished) &#123;</span><br><span class="line">                    packet.wait();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.getErr() == Code.REQUESTTIMEOUT.intValue()) &#123;</span><br><span class="line">            <span class="comment">// 如果请求超时则清空 outgoingQueue 和 pendingQueue</span></span><br><span class="line">            sendThread.cleanAndNotifyState();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先会调用 queuePacket 方法创建 Packet 并将其入队 outgoing ，之后同步该 Packet，最后根据是否设置了超时时间来选择是否使用超时逻辑，如果设置了超时时间，当请求在超时时间内未完成即返回并清空相关队列（outgoingQueue 和 pendingQueue），而如果未设置超时时间则该线程无限期的 wait 在该 Packet 直至接收到该请求的响应（在接收到请求的响应后该线程会被 notify）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Packet <span class="title function_">queuePacket</span><span class="params">(</span></span><br><span class="line"><span class="params">        RequestHeader h,</span></span><br><span class="line"><span class="params">        ReplyHeader r,</span></span><br><span class="line"><span class="params">        Record request,</span></span><br><span class="line"><span class="params">        Record response,</span></span><br><span class="line"><span class="params">        AsyncCallback cb,</span></span><br><span class="line"><span class="params">        String clientPath,</span></span><br><span class="line"><span class="params">        String serverPath,</span></span><br><span class="line"><span class="params">        Object ctx,</span></span><br><span class="line"><span class="params">        WatchRegistration watchRegistration,</span></span><br><span class="line"><span class="params">        WatchDeregistration watchDeregistration)</span> &#123;</span><br><span class="line">        <span class="type">Packet</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note that we do not generate the Xid for the packet yet. It is</span></span><br><span class="line">        <span class="comment">// generated later at send-time, by an implementation of ClientCnxnSocket::doIO(),</span></span><br><span class="line">        <span class="comment">// where the packet is actually sent.</span></span><br><span class="line">        <span class="comment">// 创建一个 Packet 实例并将相关数据填入</span></span><br><span class="line">        packet = <span class="keyword">new</span> <span class="title class_">Packet</span>(h, r, request, response, watchRegistration);</span><br><span class="line">        packet.cb = cb;</span><br><span class="line">        packet.ctx = ctx;</span><br><span class="line">        packet.clientPath = clientPath;</span><br><span class="line">        packet.serverPath = serverPath;</span><br><span class="line">        packet.watchDeregistration = watchDeregistration;</span><br><span class="line">        <span class="comment">// The synchronized block here is for two purpose:</span></span><br><span class="line">        <span class="comment">// 1. synchronize with the final cleanup() in SendThread.run() to avoid race</span></span><br><span class="line">        <span class="comment">// 2. synchronized against each packet. So if a closeSession packet is added,</span></span><br><span class="line">        <span class="comment">// later packet will be notified.</span></span><br><span class="line">        <span class="comment">// 同步状态</span></span><br><span class="line">        <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!state.isAlive() || closing) &#123;</span><br><span class="line">                <span class="comment">// 如果当前连接已断开或者正在关闭则返回相应的错误信息</span></span><br><span class="line">                conLossPacket(packet);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// If the client is asking to close the session then</span></span><br><span class="line">                <span class="comment">// mark as closing</span></span><br><span class="line">                <span class="comment">// 如果客户端要求关闭会话，则将其状态标记为正在关闭（Closing）</span></span><br><span class="line">                <span class="keyword">if</span> (h.getType() == OpCode.closeSession) &#123;</span><br><span class="line">                    closing = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果请求超时则清空 outgoingQueue 和 pendingQueue</span></span><br><span class="line">                outgoingQueue.add(packet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 唤醒发送线程发送 outgoing 队列中的 Packet（Netty 中为空实现）</span></span><br><span class="line">        sendThread.getClientCnxnSocket().packetAdded();</span><br><span class="line">        <span class="keyword">return</span> packet;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在 queuePacket 方法中会创建一个 Packet 实例，并将入参中的 request 请求包和 response 响应包等数据填充到该 Packet 中。但需要注意的是，到目前为止还没有为包生成 Xid ，它是在稍后发送时由 ClientCnxnSocket::doIO() 实现生成的，因为 Packet 实际上是在那里被发送的。然后会同步在状态值 state 上，这里之所以要同步在该状态上的原因有两点：</p>
<ul>
<li>同步 SendThread.run() 中的 cleanup() 操作以避免竞争</li>
<li>通过对每个包进行同步，如果一个 closeSession 包被添加，后面的包都会被通知</li>
</ul>
<p>到这里为止（ <strong>Packet 入队 outgoingQueue 且线程 wait</strong> ）同步版本的 Create API 实现第一部分已经分析完成，下面我们来大概总结一下主要的流程：</p>
<ul>
<li>首先在 Zookeeper 的 Create() 方法中根据入参创建 Request 请求包和 Response 响应包</li>
<li>调用 ClientCnxn 的 submitRequest() 方法提交该请求，在 submitRequest() 方法中会调用 queuePacket() 方法</li>
<li>在 queuePacket() 方法中将入参中的 Request 请求包和 Response 响应包以及其它信息封装为 Packet ，然后将其入队 outgoingQueue 并唤醒发送逻辑</li>
<li>返回到 ClientCnxn 的 submitRequest() 方法中，根据是否设置超时时间选择不同的逻辑来将该线程 wait</li>
</ul>
<p><strong>处理响应并出队 pendingQueue（且 Packet.notifyAll）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxnSocketNetty.ZKClientHandler#channelRead0</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf buf)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            updateNow();</span><br><span class="line">            <span class="keyword">while</span> (buf.isReadable()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (incomingBuffer.remaining() &gt; buf.readableBytes()) &#123;</span><br><span class="line">                    <span class="comment">// 如果 incomingBuffer 中剩余的空间大于 ByteBuf 中可读数据长度</span></span><br><span class="line">                    <span class="comment">// 重置 incomingBuffer 中的 limit 为 incomingBuffer 当前的 position 加上 ByteBuf 中可读的数据长度</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">newLimit</span> <span class="operator">=</span> incomingBuffer.position() + buf.readableBytes();</span><br><span class="line">                    incomingBuffer.limit(newLimit);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将 ByteBuf 中的数据读入到 incomingBuffer（ ByteBuffer）中</span></span><br><span class="line">                buf.readBytes(incomingBuffer);</span><br><span class="line">                incomingBuffer.limit(incomingBuffer.capacity());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!incomingBuffer.hasRemaining()) &#123;</span><br><span class="line">                    incomingBuffer.flip();</span><br><span class="line">                    <span class="keyword">if</span> (incomingBuffer == lenBuffer) &#123;</span><br><span class="line">                        recvCount.getAndIncrement();</span><br><span class="line">                        <span class="comment">// 当 incomingBuffer 等于 lenBuffer 时首先读取数据包中数据的长度 4byte</span></span><br><span class="line">                        readLength();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">                        <span class="comment">// 如果未进行初始化则首先读取连接结果</span></span><br><span class="line">                        readConnectResult();</span><br><span class="line">                        <span class="comment">// 重置 lenBuffer 并重新初始化 incomingBuffer 为 lenBuffer 来读取数据包中真正数据的长度</span></span><br><span class="line">                        lenBuffer.clear();</span><br><span class="line">                        incomingBuffer = lenBuffer;</span><br><span class="line">                        initialized = <span class="literal">true</span>;</span><br><span class="line">                        updateLastHeard();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 读取数据包中真正的数据</span></span><br><span class="line">                        sendThread.readResponse(incomingBuffer);</span><br><span class="line">                        <span class="comment">// 重置 lenBuffer 并重新初始化 incomingBuffer 为 lenBuffer 来读取数据包中真正数据的长度</span></span><br><span class="line">                        lenBuffer.clear();</span><br><span class="line">                        incomingBuffer = lenBuffer;</span><br><span class="line">                        updateLastHeard();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 唤醒发送逻辑</span></span><br><span class="line">            wakeupCnxn();</span><br><span class="line">            <span class="comment">// Note: SimpleChannelInboundHandler releases the ByteBuf for us</span></span><br><span class="line">            <span class="comment">// so we don&#x27;t need to do it.</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>首先在初始化连接的过程中（connect 方法中）我们就已将 incomingBuffer 设置为 lenBuffer（4 byte ByteBuffer），因此当数据到达时 incomingBuffer 会先将 ByteBuf 中的前 4byte 数据读入，然后调用 readLength 方法来获取这 4byte 所代表的 int 数值（真实数据的长度），之后再创建一个新的长度为真实数据长度的 ByteBuffer 赋值给 incomingBuffer，这样在下一轮的读取过程中 incomingBuffer 就可以从 ByteBuf 中一次性完整的读出所有的真实数据，最后调用 readResponse 方法来处理读取到的真实数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxn.SendThread#readResponse</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">readResponse</span><span class="params">(ByteBuffer incomingBuffer)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="type">ByteBufferInputStream</span> <span class="variable">bbis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteBufferInputStream</span>(incomingBuffer);</span><br><span class="line">            <span class="type">BinaryInputArchive</span> <span class="variable">bbia</span> <span class="operator">=</span> BinaryInputArchive.getArchive(bbis);</span><br><span class="line">            <span class="comment">// 创建临时响应头</span></span><br><span class="line">            <span class="type">ReplyHeader</span> <span class="variable">replyHdr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReplyHeader</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解析数据包中的数据填充临时响应头，然后根据临时响应头中的 xid 进行分类处理</span></span><br><span class="line">            replyHdr.deserialize(bbia, <span class="string">&quot;header&quot;</span>);</span><br><span class="line">            <span class="keyword">switch</span> (replyHdr.getXid()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PING_XID:</span><br><span class="line">                LOG.debug(<span class="string">&quot;Got ping response for session id: 0x&#123;&#125; after &#123;&#125;ms.&quot;</span>,</span><br><span class="line">                    Long.toHexString(sessionId),</span><br><span class="line">                    ((System.nanoTime() - lastPingSentNs) / <span class="number">1000000</span>));</span><br><span class="line">                <span class="comment">// xid == -2 为心跳包</span></span><br><span class="line">                <span class="comment">// 心跳包不做处理直接返回</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">              <span class="keyword">case</span> AUTHPACKET_XID:</span><br><span class="line">                  <span class="comment">// xid == -4 为认证包</span></span><br><span class="line">                LOG.debug(<span class="string">&quot;Got auth session id: 0x&#123;&#125;&quot;</span>, Long.toHexString(sessionId));</span><br><span class="line">                <span class="keyword">if</span> (replyHdr.getErr() == KeeperException.Code.AUTHFAILED.intValue()) &#123;</span><br><span class="line">                    changeZkState(States.AUTH_FAILED);</span><br><span class="line">                    eventThread.queueEvent(<span class="keyword">new</span> <span class="title class_">WatchedEvent</span>(Watcher.Event.EventType.None,</span><br><span class="line">                        Watcher.Event.KeeperState.AuthFailed, <span class="literal">null</span>));</span><br><span class="line">                    eventThread.queueEventOfDeath();</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> NOTIFICATION_XID:</span><br><span class="line">                <span class="comment">// xid == -1 为通知包</span></span><br><span class="line">                LOG.debug(<span class="string">&quot;Got notification session id: 0x&#123;&#125;&quot;</span>,</span><br><span class="line">                    Long.toHexString(sessionId));</span><br><span class="line">                <span class="type">WatcherEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WatcherEvent</span>();</span><br><span class="line">                event.deserialize(bbia, <span class="string">&quot;response&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// convert from a server path to a client path</span></span><br><span class="line">                <span class="keyword">if</span> (chrootPath != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">serverPath</span> <span class="operator">=</span> event.getPath();</span><br><span class="line">                    <span class="keyword">if</span> (serverPath.compareTo(chrootPath) == <span class="number">0</span>) &#123;</span><br><span class="line">                        event.setPath(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serverPath.length() &gt; chrootPath.length()) &#123;</span><br><span class="line">                        event.setPath(serverPath.substring(chrootPath.length()));</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         LOG.warn(<span class="string">&quot;Got server path &#123;&#125; which is too short for chroot path &#123;&#125;.&quot;</span>,</span><br><span class="line">                             event.getPath(), chrootPath);</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">WatchedEvent</span> <span class="variable">we</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WatchedEvent</span>(event);</span><br><span class="line">                LOG.debug(<span class="string">&quot;Got &#123;&#125; for session id 0x&#123;&#125;&quot;</span>, we, Long.toHexString(sessionId));</span><br><span class="line">                eventThread.queueEvent(we);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If SASL authentication is currently in progress, construct and</span></span><br><span class="line">            <span class="comment">// send a response packet immediately, rather than queuing a</span></span><br><span class="line">            <span class="comment">// response as with other packets.</span></span><br><span class="line">            <span class="keyword">if</span> (tunnelAuthInProgress()) &#123;</span><br><span class="line">                <span class="type">GetSASLRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetSASLRequest</span>();</span><br><span class="line">                request.deserialize(bbia, <span class="string">&quot;token&quot;</span>);</span><br><span class="line">                zooKeeperSaslClient.respondToServer(request.getToken(), ClientCnxn.<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Packet packet;</span><br><span class="line">            <span class="keyword">synchronized</span> (pendingQueue) &#123;</span><br><span class="line">                <span class="comment">// 如果 pendingQueue 为空则直接抛异常，否则出队一个 Packet</span></span><br><span class="line">                <span class="keyword">if</span> (pendingQueue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Nothing in the queue, but got &quot;</span> + replyHdr.getXid());</span><br><span class="line">                &#125;</span><br><span class="line">                packet = pendingQueue.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Since requests are processed in order, we better get a response</span></span><br><span class="line"><span class="comment">             * to the first request!</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 由于请求是按顺序处理的，所以获得对第一个请求的响应</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果 pendingQueue 刚刚出队的 Packet 不是当前响应所对应的 Packet 则证明出现异常</span></span><br><span class="line">                <span class="keyword">if</span> (packet.requestHeader.getXid() != replyHdr.getXid()) &#123;</span><br><span class="line">                    packet.replyHeader.setErr(KeeperException.Code.CONNECTIONLOSS.intValue());</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Xid out of order. Got Xid &quot;</span> + replyHdr.getXid()</span><br><span class="line">                                          + <span class="string">&quot; with err &quot;</span> + replyHdr.getErr()</span><br><span class="line">                                          + <span class="string">&quot; expected Xid &quot;</span> + packet.requestHeader.getXid()</span><br><span class="line">                                          + <span class="string">&quot; for a packet with details: &quot;</span> + packet);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 填充 Packet 响应头数据</span></span><br><span class="line">                packet.replyHeader.setXid(replyHdr.getXid());</span><br><span class="line">                packet.replyHeader.setErr(replyHdr.getErr());</span><br><span class="line">                packet.replyHeader.setZxid(replyHdr.getZxid());</span><br><span class="line">                <span class="comment">// 更新最后处理的 zxid</span></span><br><span class="line">                <span class="keyword">if</span> (replyHdr.getZxid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    lastZxid = replyHdr.getZxid();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果 Packet 中存在 Response 响应包（数据为空）且响应头解析未出现错误则继续解析响应体数据</span></span><br><span class="line">                <span class="keyword">if</span> (packet.response != <span class="literal">null</span> &amp;&amp; replyHdr.getErr() == <span class="number">0</span>) &#123;</span><br><span class="line">                    packet.response.deserialize(bbia, <span class="string">&quot;response&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                LOG.debug(<span class="string">&quot;Reading reply session id: 0x&#123;&#125;, packet:: &#123;&#125;&quot;</span>, Long.toHexString(sessionId), packet);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 完整响应数据解析后调用</span></span><br><span class="line">                finishPacket(packet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>readResponse 方法首先从刚刚读入数据的 ByteBuffer 中解析出一个临时响应头，然后根据这个临时响应头中的 xid 来进行分类处理， 当处理完成后会从 pendingQueue 中出队一个 Packet，这个 Packet 正常来说应当是我们之前发送最后一个请求后入队的那个 Packet （请求顺序性），因此判断这个出队的 Packet 的 xid 是否等于当前正在处理的这个请求中的 Packet 的 xid ，如果不是则证明出现了丢包或断连等问题，所以向临时响应头中添加一个错误信息，然后将临时响应头中的数据填充到刚刚出队的那个 Packet 的 ReplyHeader 响应头中并更新最后处理的 zxid 属性值（ lastZxid ），最终如果确认该 Packet 中存在 Response（需要返回响应信息）并且在解析响应头的过程中未发现错误，则开始从 ByteBuffer 中解析出响应体并赋给 Packet 的 Response 属性，当全部处理完成时，最终调用 finishPacket 方法完成 ByteBuffer 的 Response 解析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxn#finishPacket</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishPacket</span><span class="params">(Packet p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">err</span> <span class="operator">=</span> p.replyHeader.getErr();</span><br><span class="line">        <span class="keyword">if</span> (p.watchRegistration != <span class="literal">null</span>) &#123;</span><br><span class="line">            p.watchRegistration.register(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Add all the removed watch events to the event queue, so that the</span></span><br><span class="line">        <span class="comment">// clients will be notified with &#x27;Data/Child WatchRemoved&#x27; event type.</span></span><br><span class="line">        <span class="comment">// watch事件处理</span></span><br><span class="line">        <span class="keyword">if</span> (p.watchDeregistration != <span class="literal">null</span>) &#123;</span><br><span class="line">            Map&lt;EventType, Set&lt;Watcher&gt;&gt; materializedWatchers = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                materializedWatchers = p.watchDeregistration.unregister(err);</span><br><span class="line">                <span class="keyword">for</span> (Entry&lt;EventType, Set&lt;Watcher&gt;&gt; entry : materializedWatchers.entrySet()) &#123;</span><br><span class="line">                    Set&lt;Watcher&gt; watchers = entry.getValue();</span><br><span class="line">                    <span class="keyword">if</span> (watchers.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        queueEvent(p.watchDeregistration.getClientPath(), err, watchers, entry.getKey());</span><br><span class="line">                        <span class="comment">// ignore connectionloss when removing from local</span></span><br><span class="line">                        <span class="comment">// session</span></span><br><span class="line">                        p.replyHeader.setErr(Code.OK.intValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (KeeperException.NoWatcherException nwe) &#123;</span><br><span class="line">                p.replyHeader.setErr(nwe.code().intValue());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (KeeperException ke) &#123;</span><br><span class="line">                p.replyHeader.setErr(ke.code().intValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.cb == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 Packet 中不存在方法回调（同步 API）</span></span><br><span class="line">            <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">                <span class="comment">// 设置 Packet 处理完成</span></span><br><span class="line">                p.finished = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 唤醒所有 wait 在该 Packet 上的线程</span></span><br><span class="line">                p.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 Packet 中不存在方法回调（异步 API），先设置 Packet 处理完成</span></span><br><span class="line">            p.finished = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 进入异步 Packet 的处理逻辑</span></span><br><span class="line">            eventThread.queuePacket(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>finishPacket 方法在响应处理完成后就会被调用，在这个方法中首先会对 Watch 事件进行处理，然后判断当前 Packet 中是否存在回调方法（本次调用是同步还是异步），如果不存在回调方法则证明本次调用为同步调用，因此更新 Packet 的 finished 状态后通过 Packet 的 notifyAll 方法唤醒所有 wait 在该 Packet 上的线程（wait 逻辑位于 ClientCnxn 的 submitRequest 方法），而如果存在回调方法，则应通过调用 EventThread 的 queuePacket 方法进入对于异步回调的处理逻辑中</p>
</li>
</ol>
<ol start="4">
<li>异步RPC调用流程（Create Api）<br>异步Create Api入口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ZooKeeper#create(java.lang.String, byte[], java.util.List&lt;org.apache.zookeeper.data.ACL&gt;, org.apache.zookeeper.CreateMode, org.apache.zookeeper.AsyncCallback.StringCallback, java.lang.Object)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> String path,</span></span><br><span class="line"><span class="params">        <span class="type">byte</span>[] data,</span></span><br><span class="line"><span class="params">        List&lt;ACL&gt; acl,</span></span><br><span class="line"><span class="params">        CreateMode createMode,</span></span><br><span class="line"><span class="params">        StringCallback cb,</span></span><br><span class="line"><span class="params">        Object ctx)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">clientPath</span> <span class="operator">=</span> path;</span><br><span class="line">        <span class="comment">// 相关信息验证（与同步模式相同）</span></span><br><span class="line">        PathUtils.validatePath(clientPath, createMode.isSequential());</span><br><span class="line">        EphemeralType.validateTTL(createMode, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">serverPath</span> <span class="operator">=</span> prependChroot(clientPath);</span><br><span class="line">        <span class="comment">// 创建 Request 请求包和 Response 响应包（与同步模式相同）</span></span><br><span class="line">        <span class="type">RequestHeader</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestHeader</span>();</span><br><span class="line">        h.setType(createMode.isContainer() ? ZooDefs.OpCode.createContainer : ZooDefs.OpCode.create);</span><br><span class="line">        <span class="type">CreateRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateRequest</span>();</span><br><span class="line">        <span class="type">CreateResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateResponse</span>();</span><br><span class="line">        <span class="type">ReplyHeader</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReplyHeader</span>();</span><br><span class="line">        request.setData(data);</span><br><span class="line">        request.setFlags(createMode.toFlag());</span><br><span class="line">        request.setPath(serverPath);</span><br><span class="line">        request.setAcl(acl);</span><br><span class="line">        <span class="comment">// 直接调用 queuePacket 方法创建 Packet 并入队 outgoingQueue</span></span><br><span class="line">        cnxn.queuePacket(h, r, request, response, cb, clientPath, serverPath, ctx, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

异步模式的 API 和同步版 API 是大体相同的，只不过在异步版本的 API 中仅需要调用 queuePacket 方法创建 Packet 并入队 outgoingQueue ，然后直接返回即可，而不需要再在 submitRequest 方法中 wait 等待请求响应的返回<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.zookeeper.ClientCnxn.EventThread#queuePacket</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queuePacket</span><span class="params">(Packet packet)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (wasKilled) &#123;</span><br><span class="line">                <span class="comment">// EventThread 在接收到 eventOfDeath 后 wasKilled 将被设为 true</span></span><br><span class="line">                <span class="keyword">synchronized</span> (waitingEvents) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isRunning) &#123;</span><br><span class="line">                        <span class="comment">// 如果 EventThread 仍在运行（isRunning == true）则将 Packet 入队 waitingEvents</span></span><br><span class="line">                        waitingEvents.add(packet);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 否则直接调用 processEvent 方法处理该 Packet</span></span><br><span class="line">                        processEvent(packet);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果 EventThread 线程正常运行则直接将 Packet 入队 waitingEvents</span></span><br><span class="line">                waitingEvents.add(packet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

在接收并处理 Response 的过程中同步版和异步版的 API 前面的处理逻辑都是完全相同的，差异之处在于在 finishPacket 方法中同步版调用会直接唤醒所有 wait 在该 Packet 上面的线程然后返回，而对于异步版本则会调用到 queuePacket 方法来对响应做进一步的处理queuePacket 方法主要执行的就是将 Packet 入队 waitingEvents 的逻辑，但是需要注意的是对于 EventThread 存在两个标志量（下文会细讲），且当 wasKilled 为 true 时并不是意味着 EventThread 已经完全不能处理 Packet 了，还需要再次判断 isRunning 来确定当前 EventThread 是否真的已经停止运行了，如果当前 wasKilled 为 true 且 isRunning 为 false 则证明 EventThread 已经真正的结束了，所以该方法会自己调用 processEvent 方法来处理该 Packet当我们在 queuePacket 方法中将 Packet 入队 waitingEvents 后，在 ClientCnxn 的内部类（线程）EventThread 中会通过 run 方法不断取出队列中的 Packet ，然后调用 processEvent 方法进行处理。这里设计很巧妙的就是对于关闭该线程时的操作，在该线程中使用了两个标志量 wasKilled 和 isRunning ，当外部将要关闭它时会通过发送类型为 eventOfDeath 的 Packet 先设置 wasKilled 为 true，此时进入关闭的第一阶段。EventThread 得到该关闭消息后开始进行扫尾工作，在每次处理完一个 Packet 后就会判断 waitingEvents 中是否还存在未处理的 Packet ，如果存在就继续处理，如果不存在就将 isRunning 设置为 false 并跳出循环，此时标志着 EventThread 已经完成了扫尾工作，可以正常关闭了。因此，EventThread 可以安全的进入到最后一个线程的关闭阶段。这样的三阶段关闭流程保证了数据的安全性，保证了 EventThread 不会在 waitingEvents 还存在数据时就关闭而导致数据丢失，同时也正是因为这样，当通过 queuePacket 方法向 waitingEvents 中添加元素时，就算 wasKilled 已经为 true 了，但只要 isRunning 还为 true 就证明 waitingEvents 中还存在数据既 EventThread 还可以处理数据，所以仍然可以放心的将 Packet 入队 waitingEvents 来交给 EventThread 处理，且不会发生数据丢失的情况<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClientCnxn.EventThread.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processEvent</span><span class="params">(Object event)</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 重构后的代码，省略巨多各种事件类型的判断和处理逻辑...</span></span><br><span class="line">		<span class="comment">// 当进行异步 Create 时，事件类型为 CreateResponse </span></span><br><span class="line">    	<span class="keyword">if</span> (p.response <span class="keyword">instanceof</span> CreateResponse) &#123;</span><br><span class="line">    		<span class="comment">// 获取 Packet 中的回调信息</span></span><br><span class="line">        	<span class="type">StringCallback</span> <span class="variable">cb</span> <span class="operator">=</span> (StringCallback) p.cb;</span><br><span class="line">        	<span class="comment">// 获取 Packet 中的响应体</span></span><br><span class="line">            <span class="type">CreateResponse</span> <span class="variable">rsp</span> <span class="operator">=</span> (CreateResponse) p.response;</span><br><span class="line">            <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">            	cb.processResult(rc, clientPath, p.ctx,</span><br><span class="line">                	(chrootPath == <span class="literal">null</span> ? rsp.getPath() : rsp.getPath().substring(chrootPath.length())));</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 进行方法回调</span></span><br><span class="line">				cb.processResult(rc, clientPath, p.ctx, <span class="literal">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

在 processEvent 方法中会根据传入 Packet 的类型来选择不同的处理逻辑对 Packet 进行处理，因为我们这里分析的是 Create API ，而其对应的响应类型为 CreateResponse ，所以会进入到如上图代码的逻辑中，具体的处理方式也就是获取到 Packet 中所保存的回调方法，然后对其进行回调即可，至此也就完成了整个异步版本的方法调用</li>
</ol>
<h2 id="同步、异步比较"><a href="#同步、异步比较" class="headerlink" title="同步、异步比较"></a>同步、异步比较</h2><p>首先经过上面的源码分析我们先总结一下几个比较重要的数据结构和属性：</p>
<ul>
<li>outgoingQueue ：保存待发送的 Packet 的队列</li>
<li>pendingQueue ：保存已发送但还未接收到响应的 Packet 的队列</li>
<li>waitingEvents ：保存已接收到响应待回调的 Packet 的队列</li>
<li>EventThread.wasKilled ：外部发送信号终止 EventThread ，但此时可能尚未真正停止</li>
<li>EventThread.isRunning ：标志着 EventThread 尚在运行（waitingEvents 中还存在未处理的 Packet），当该属性为 false 时证明线程进入终止状态</li>
</ul>
<p>总结同步版 API 主流程：</p>
<ul>
<li>创建 Packet 并入队 outgoingQueue ，然后线程 wait 在该 Packet 进行等待</li>
<li>SendThread 从 outgoingQueue 中取出 Packet 后进行发送，并入队 pendingQueue</li>
<li>接收响应后从 pendingQueue 中出队 Packet ，然后将响应数据解析到 Packet中</li>
<li>解析完成后调用 Packet.notifyAll 方法唤醒所有阻塞在该 Packet 上的线程</li>
</ul>
<p>总结 异步版 API 主流程：</p>
<ul>
<li>创建 Packet 并入队 outgoingQueue ，然后方法直接返回</li>
<li>SendThread 从 outgoingQueue 中取出 Packet 后进行发送，并入队 pendingQueue</li>
<li>接收响应后从 pendingQueue 中出队 Packet ，然后将响应数据解析到 Packet中</li>
<li>解析完成后将该 Packet 入队 waitingEvents ，然后 EventThread 会从 waitingEvents 中取出 Packet 并调用其回调方法</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Zookeeper/" rel="tag"># Zookeeper</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2019/12/31/mysql-base/" rel="next" title="MySQL -- 基础架构">
      MySQL -- 基础架构 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">客户端结构解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="nav-number">1.1.</span> <span class="nav-text">客户端结构图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="nav-number">1.2.</span> <span class="nav-text">客户端核心类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">客户端启动流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D%E5%88%9B%E5%BB%BA%E9%98%B6%E6%AE%B5"><span class="nav-number">3.</span> <span class="nav-text">会话创建阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.1.</span> <span class="nav-text">客户端网络协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%E6%A0%88"><span class="nav-number">3.1.1.</span> <span class="nav-text">TCP自定义协议栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Packet%E5%8D%8F%E8%AE%AE"><span class="nav-number">3.1.2.</span> <span class="nav-text">Packet协议</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">核心源码解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E6%AF%94%E8%BE%83"><span class="nav-number">5.</span> <span class="nav-text">同步、异步比较</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="tlv"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">tlv</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tlv</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'http://example.com/2019/12/31/zk-source-build/',]
      });
      });
  </script>

</body>
</html>
